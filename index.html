<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AWS Network Topology Map</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');
  :root {
    --bg-primary:#0a0e17;--bg-secondary:#111827;--bg-tertiary:#1a2236;
    --bg-input:#0d1220;--border:#1e2d4a;--border-focus:#3b82f6;
    --text-primary:#e2e8f0;--text-secondary:#94a3b8;--text-muted:#64748b;
    --accent-blue:#3b82f6;--accent-cyan:#06b6d4;--accent-green:#10b981;
    --accent-purple:#8b5cf6;--accent-orange:#f59e0b;--accent-red:#ef4444;
    --accent-pink:#ec4899;
    --vpc-stroke:#3b82f6;--subnet-public:#06b6d4;--subnet-private:#8b5cf6;
    --igw-color:#10b981;--nat-color:#f59e0b;--tgw-color:#ec4899;
    --vgw-color:#ef4444;--vpce-color:#a78bfa;--pcx-color:#fb923c;
    --alb-color:#38bdf8;--vpn-color:#f97316;
    --txt-scale:1;--dp-txt-scale:1;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:'IBM Plex Sans',sans-serif;background:var(--bg-primary);color:var(--text-primary);height:100vh;overflow:hidden;display:flex}
  .sidebar{width:360px;min-width:360px;background:var(--bg-secondary);border-right:1px solid var(--border);display:flex;flex-direction:column;height:100vh;z-index:10;transition:width .2s,min-width .2s}
  .sidebar.collapsed{width:0;min-width:0;overflow:hidden;border-right:none}
  .sidebar-toggle{position:absolute;top:8px;left:360px;z-index:11;width:24px;height:24px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:left .2s,background .15s;line-height:1}
  .sidebar-toggle:hover{background:var(--border);color:var(--text-primary)}
  .sidebar.collapsed~.sidebar-toggle{left:4px}
  .sidebar-header{padding:14px 16px;border-bottom:1px solid var(--border);background:var(--bg-tertiary)}
  .sidebar-header h1{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600;letter-spacing:1.5px;text-transform:uppercase;color:var(--accent-cyan);margin-bottom:3px}
  .sidebar-header p{font-size:11px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace}
  .global-txt-ctrl{display:flex;align-items:center;gap:6px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
  .gtc-label{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted);letter-spacing:.5px;text-transform:uppercase}
  .gtc-btn{width:26px;height:26px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
  .gtc-btn:hover{background:var(--border);color:var(--text-primary)}
  .gtc-val{font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--accent-cyan);min-width:36px;text-align:center}
  .sidebar-body{flex:1;overflow-y:auto;padding:0}
  .sidebar-body::-webkit-scrollbar{width:6px}
  .sidebar-body::-webkit-scrollbar-track{background:transparent}
  .sidebar-body::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
  .sec-hdr{display:flex;align-items:center;justify-content:space-between;padding:7px 14px;background:var(--bg-tertiary);border-bottom:1px solid var(--border);cursor:pointer;user-select:none}
  .sec-hdr:hover{background:rgba(30,45,74,.5)}
  .sec-hdr span{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1px}
  .sec-hdr .arr{color:var(--text-muted);font-size:10px;transition:transform .2s}
  .sec-hdr.collapsed .arr{transform:rotate(-90deg)}
  .sec-body{padding:6px 10px;border-bottom:1px solid var(--border)}
  .sec-body.hidden{display:none}
  .ig{margin-bottom:5px}
  .ig-lbl{display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;padding:0 2px}
  .ig-lbl span{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:500;color:var(--text-secondary);letter-spacing:.4px}
  .ig-lbl code{font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);background:var(--bg-primary);padding:1px 4px;border-radius:3px}
  .ji{width:100%;height:48px;background:var(--bg-input);border:1px solid var(--border);border-radius:5px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));padding:5px 7px;resize:vertical;transition:border-color .2s;line-height:1.4}
  .ji:focus{outline:none;border-color:var(--border-focus);box-shadow:0 0 0 2px rgba(59,130,246,.15)}
  .ji.valid{border-color:var(--accent-green)}.ji.invalid{border-color:var(--accent-red)}
  .sidebar-actions{padding:10px 12px;border-top:1px solid var(--border);display:flex;gap:8px}
  .btn{flex:1;padding:9px 14px;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:600;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s}
  .btn-primary{background:var(--accent-blue);color:#fff}.btn-primary:hover{background:#2563eb}
  .btn-secondary{background:var(--bg-tertiary);color:var(--text-secondary);border:1px solid var(--border)}.btn-secondary:hover{background:var(--border);color:var(--text-primary)}
  .btn-demo{background:transparent;color:var(--accent-cyan);border:1px solid var(--accent-cyan);opacity:.7}.btn-demo:hover{opacity:1;background:rgba(6,182,212,.08)}
  .main{flex:1;position:relative;background:var(--bg-primary);overflow:hidden}
  .main svg{width:100%;height:100%;display:block}
  .grid-bg{position:absolute;inset:0;background-image:radial-gradient(circle at 1px 1px,rgba(50,70,100,.35) 1px,transparent 0);background-size:24px 24px;pointer-events:none}
  .empty-state{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none}
  .empty-state .icon{width:80px;height:80px;border:2px dashed var(--border);border-radius:16px;display:flex;align-items:center;justify-content:center;margin-bottom:20px;color:var(--text-muted);font-size:32px}
  .empty-state h2{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:500;color:var(--text-muted);margin-bottom:8px}
  .empty-state p{font-size:12px;color:var(--text-muted);opacity:.6}
  .stats-bar{position:absolute;top:12px;left:0;right:0;display:none;gap:5px;flex-wrap:wrap;z-index:5;justify-content:center;padding:0 440px 0 40px;transition:padding-right .2s}
  .main:has(.detail-panel.open) .stats-bar{padding-right:860px}
  .main:has(.detail-panel.open) .export-bar{right:432px}
  .stat-chip{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale));font-weight:500;padding:4px 8px;border-radius:4px;background:rgba(17,24,39,.9);border:1px solid var(--border);backdrop-filter:blur(8px);color:var(--text-secondary);cursor:pointer;transition:border-color .15s,background .15s}
  .stat-chip:hover{border-color:var(--accent-blue);background:rgba(59,130,246,.12)}
  .stat-chip b{color:var(--text-primary);font-weight:600;margin-right:3px}
  .legend{position:absolute;bottom:12px;left:12px;display:none;flex-direction:column;gap:3px;background:rgba(17,24,39,.92);border:1px solid var(--border);border-radius:8px;padding:10px 14px;backdrop-filter:blur(8px);z-index:5;transition:all .2s}
  .legend-title{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:600;letter-spacing:1px;text-transform:uppercase;color:var(--text-muted);margin-bottom:3px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:8px;user-select:none}
  .legend-title .lg-arr{font-size:7px;transition:transform .2s}
  .legend.collapsed .legend-title .lg-arr{transform:rotate(-90deg)}
  .legend.collapsed .legend-item,.legend.collapsed .legend-hint{display:none}
  .legend-item{display:flex;align-items:center;gap:7px;font-size:10px;color:var(--text-secondary)}
  .legend-swatch{width:10px;height:10px;border-radius:2px;flex-shrink:0}
  .legend-hint{font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);margin-top:4px;padding-top:4px;border-top:1px solid var(--border);opacity:.7}
  .zoom-controls{position:absolute;bottom:12px;right:12px;display:flex;flex-direction:column;gap:4px;z-index:5}
  .zoom-btn{width:32px;height:32px;background:rgba(17,24,39,.92);border:1px solid var(--border);border-radius:6px;color:var(--text-secondary);font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-family:'IBM Plex Mono',monospace;transition:all .15s;backdrop-filter:blur(8px)}
  .zoom-btn:hover{background:var(--bg-tertiary);color:var(--text-primary)}
  .zoom-btn.wide{width:auto;padding:0 10px;font-size:9px;letter-spacing:.5px}
  .zoom-btn.active{border-color:var(--accent-blue);color:var(--accent-blue);background:rgba(59,130,246,.12)}
  .tooltip{position:absolute;display:none;background:rgba(10,14,23,.96);border:1px solid var(--border);border-radius:8px;padding:12px 16px;max-width:420px;min-width:200px;z-index:100;pointer-events:none;backdrop-filter:blur(12px);box-shadow:0 8px 32px rgba(0,0,0,.5)}
  .tt-title{font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600;color:var(--accent-cyan);margin-bottom:5px;word-break:break-all}
  .tt-sub{font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--text-muted);margin-bottom:7px;word-break:break-all}
  .tt-sec{margin-bottom:5px}
  .tt-sh{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:.8px;color:var(--text-muted);margin-bottom:2px}
  .tt-r{font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--text-secondary);line-height:1.6;padding-left:8px}
  .tt-r .a{color:var(--accent-green)}.tt-r .d{color:var(--accent-red)}.tt-r .p{color:var(--accent-orange)}.tt-r .i{color:var(--accent-cyan)}
  .vpc-group rect{stroke-dasharray:6 3;rx:8;ry:8}
  .vpc-label{font-family:'IBM Plex Mono',monospace;font-size:calc(13px * var(--txt-scale));font-weight:600;fill:var(--vpc-stroke);text-transform:uppercase;letter-spacing:.5px}
  .vpc-cidr{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));fill:var(--text-muted)}
  .subnet-node rect{rx:5;ry:5;cursor:pointer}
  .subnet-label{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:500;fill:#fff;pointer-events:none}
  .subnet-cidr{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale));fill:rgba(255,255,255,.7);pointer-events:none}
  .subnet-badge{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));font-weight:600;pointer-events:none}
  .gw-node{cursor:pointer}
  .gw-label{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;pointer-events:none}
  .gw-id{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));fill:var(--text-muted);pointer-events:none}
  .gw-name{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));fill:var(--text-secondary);pointer-events:none}
  .route-group{opacity:.35;filter:url(#alphaClamp)}
  .struct-group{opacity:1}
  .route-line{fill:none;stroke-width:1.5;opacity:1;pointer-events:none}
  .route-line.route-structural{stroke-dasharray:6 3;animation:dashFlow 1s linear infinite}
  .route-trunk{fill:none;stroke-width:1.5;opacity:1;pointer-events:none}
  .route-trunk.animated{stroke-dasharray:6 3;animation:dashFlow 1s linear infinite}
  .route-structural{opacity:1}
  .route-trunk.route-structural{stroke-dasharray:6 3;animation:dashFlow 1s linear infinite}
  .hl-active .route-group{opacity:.06}
  .hl-active .struct-group{opacity:.06}
  .hl-active .route-structural{opacity:.06}
  .peering-group{opacity:.35;filter:url(#alphaClamp)}
  .peering-line{fill:none;stroke-width:2;opacity:1;stroke-dasharray:9 9;animation:dashFlow 1.2s linear infinite}
  .peering-label-g{opacity:1}
  .hl-active .peering-group{opacity:.03}
  .hl-active .vpce-summary{opacity:.15}
  .hl-active .dns-summary{opacity:.15}
  .hl-active .peering-label-g{opacity:.08}
  .hl-active .gw-node{opacity:.15}
  .hl-active .gw-node.gw-hl{opacity:1}
  .hl-active .lz-gw-node{opacity:.15}
  .hl-active .lz-gw-node.lz-hl{opacity:1}
  .hl-active .lz-tgw-node{opacity:.15}
  .hl-active .lz-tgw-node.lz-hl{opacity:1}
  .hl-active .internet-node{opacity:.08}
  .hl-active .internet-node.lz-hl{opacity:1}
  .export-bar.collapsed .export-btn,.export-bar.collapsed .export-btn+.export-btn{display:none}
  .export-bar .eb-toggle{padding:4px 10px;background:rgba(17,24,39,.92);border:1px solid var(--border);border-radius:5px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:8px;cursor:pointer;white-space:nowrap;transition:all .15s}
  .export-bar .eb-toggle:hover{color:var(--text-primary);border-color:var(--accent-blue)}
  .hl-locked-indicator{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,.95);border:1px solid var(--accent-cyan);border-radius:6px;padding:5px 14px;font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--accent-cyan);display:none;z-index:10;cursor:pointer;backdrop-filter:blur(8px)}
  .hl-locked-indicator:hover{background:rgba(17,24,39,1);border-color:#fff}
  .hl-active .route-label-g:not(.visible){opacity:.08}
  .hl-active .region-boundary{opacity:.08}
  .hl-active .dns-section{opacity:.08}
  .hl-active .s3-section{opacity:.08}
  .hl-active .cf-section{opacity:.08}
  .hl-active .legend{opacity:.08}
  .route-hitarea{fill:none;stroke:transparent;stroke-width:16;cursor:pointer;pointer-events:stroke !important}
  .dp-nav-btn{display:inline-block;font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--accent-blue);cursor:pointer;margin-left:6px;padding:1px 5px;border:1px solid rgba(59,130,246,.3);border-radius:3px;background:rgba(59,130,246,.08);transition:background .15s}
  .dp-nav-btn:hover{background:rgba(59,130,246,.2)}
  .route-label-g{display:none;pointer-events:none}.route-label-g.visible{display:block}
  .label-layer{pointer-events:none}
  .internet-label{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:600;fill:var(--text-secondary)}
  @keyframes dashFlow{from{stroke-dashoffset:0}to{stroke-dashoffset:-18}}
  .animated{animation:dashFlow 1s linear infinite}
  .export-bar{position:absolute;top:12px;right:12px;display:none;gap:4px;z-index:6;flex-direction:column}
  .export-btn{padding:6px 10px;background:rgba(17,24,39,.92);border:1px solid var(--border);border-radius:5px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale));font-weight:500;cursor:pointer;backdrop-filter:blur(8px);transition:all .15s;text-align:left;white-space:nowrap}
  .export-btn:hover{background:var(--bg-tertiary);color:var(--text-primary);border-color:var(--accent-blue)}
  .export-btn span{color:var(--text-muted);font-size:7px;display:block;margin-top:1px}
  .upload-row{padding:8px 12px;border-bottom:1px solid var(--border);display:flex;gap:6px}
  .btn-upload{flex:1;padding:9px 14px;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:600;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s;background:var(--accent-green);color:#fff;text-align:center}
  .btn-upload:hover{background:#059669}
  .upload-status{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--accent-green);padding:4px 12px;display:none;border-bottom:1px solid var(--border)}
  /* Detail panel - right side slide-out */
  .detail-panel{position:absolute;top:0;right:0;width:420px;height:100%;background:rgba(10,14,23,.97);border-left:1px solid var(--border);backdrop-filter:blur(16px);z-index:50;display:none;flex-direction:column;box-shadow:-4px 0 24px rgba(0,0,0,.4)}
  .detail-panel.open{display:flex}
  .dp-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:flex-start;gap:8px;flex-shrink:0}
  .dp-title{font-family:'IBM Plex Mono',monospace;font-size:calc(13px * var(--txt-scale) * var(--dp-txt-scale));font-weight:600;color:var(--accent-cyan);word-break:break-all;line-height:1.4}
  .dp-subtitle{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);margin-top:4px;word-break:break-all;line-height:1.5}
  .dp-close{width:28px;height:28px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:5px;color:var(--text-muted);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
  .dp-close:hover{background:var(--border);color:var(--text-primary)}
  .dp-body{flex:1;overflow-y:auto;padding:0}
  .dp-body::-webkit-scrollbar{width:6px}
  .dp-body::-webkit-scrollbar-track{background:transparent}
  .dp-body::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
  .dp-section{border-bottom:1px solid var(--border)}
  .dp-sec-hdr{display:flex;align-items:center;justify-content:space-between;padding:9px 16px;cursor:pointer;user-select:none;transition:background .15s}
  .dp-sec-hdr:hover{background:rgba(30,45,74,.3)}
  .dp-sec-title{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:.8px}
  .dp-sec-count{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);background:var(--bg-tertiary);padding:2px 6px;border-radius:3px}
  .dp-sec-arr{color:var(--text-muted);font-size:10px;transition:transform .2s;margin-left:6px}
  .dp-sec-hdr.collapsed .dp-sec-arr{transform:rotate(-90deg)}
  .dp-sec-body{padding:4px 16px 10px}
  .dp-sec-body.hidden{display:none}
  .dp-row{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-secondary);line-height:1.7;padding:3px 0;border-bottom:1px solid rgba(30,45,74,.3)}
  .dp-row:last-child{border-bottom:none}
  .dp-row[data-act]{cursor:pointer;transition:background .15s}
  .dp-row[data-act]:hover{background:rgba(59,130,246,.1)}
  .dp-link{text-decoration:none;transition:text-decoration .15s,opacity .15s}
  .dp-link:hover{text-decoration:underline;opacity:.85}
  .dp-row .lbl{color:var(--text-muted);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));display:block}
  .dp-row .val{color:var(--text-primary)}
  .dp-det{transition:max-height .15s}
  .dp-row.collapsed .dp-det{display:none}
  .dp-tog{font-size:9px;color:var(--accent-blue);margin-right:4px;display:inline-block;transition:transform .15s;cursor:pointer;user-select:none}
  .dp-row.collapsed .dp-tog{transform:rotate(-90deg)}
  .dp-row .a{color:var(--accent-green)}.dp-row .d{color:var(--accent-red)}.dp-row .p{color:var(--accent-orange)}.dp-row .i{color:var(--accent-cyan)}.dp-row .s{color:var(--accent-purple)}
  .dp-kv{display:flex;justify-content:space-between;align-items:baseline;gap:8px;padding:3px 0}
  .dp-kv .k{color:var(--text-muted);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));flex-shrink:0}
  .dp-kv .v{color:var(--text-primary);font-size:calc(11px * var(--txt-scale) * var(--dp-txt-scale));text-align:right;word-break:break-all;cursor:pointer}
  .dp-kv .v:hover{color:var(--accent-cyan)}
  .dp-badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px;font-weight:600;margin-left:4px}
  .dp-badge.running{background:rgba(16,185,129,.15);color:var(--accent-green)}
  .dp-badge.stopped{background:rgba(239,68,68,.15);color:var(--accent-red)}
  .dp-badge.pub{background:rgba(6,182,212,.15);color:var(--accent-cyan)}
  .dp-badge.prv{background:rgba(139,92,246,.15);color:var(--accent-purple)}
  .dp-empty{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);padding:6px 0;font-style:italic}
  /* text size controls */
  .dp-toolbar{display:flex;align-items:center;gap:6px;padding:6px 16px;border-bottom:1px solid var(--border);flex-shrink:0}
  .dp-size-btn{width:24px;height:24px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .dp-size-btn:hover{background:var(--border);color:var(--text-primary)}
  .dp-size-label{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted)}
  /* firewall visual */
  .fw-visual{padding:8px 0}
  .fw-rule-bar{display:flex;align-items:center;gap:6px;margin:3px 0;font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale))}
  .fw-arrow{width:40px;height:20px;position:relative;flex-shrink:0}
  .fw-arrow-line{position:absolute;top:9px;left:0;right:8px;height:2px}
  .fw-arrow-head{position:absolute;right:0;top:4px;width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent}
  .fw-arrow.allow .fw-arrow-line{background:var(--accent-green)}.fw-arrow.allow .fw-arrow-head{border-left:8px solid var(--accent-green)}
  .fw-arrow.deny .fw-arrow-line{background:var(--accent-red)}.fw-arrow.deny .fw-arrow-head{border-left:8px solid var(--accent-red)}
  .fw-port{padding:1px 5px;border-radius:3px;font-weight:600;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale))}
  .fw-port.allow{background:rgba(16,185,129,.12);color:var(--accent-green);border:1px solid rgba(16,185,129,.25)}
  .fw-port.deny{background:rgba(239,68,68,.12);color:var(--accent-red);border:1px solid rgba(239,68,68,.25)}
  .fw-src{color:var(--text-muted);font-size:8px;margin-left:auto;max-width:120px;text-align:right;word-break:break-all}
  .fw-proto{color:var(--accent-orange);font-size:8px;width:28px;flex-shrink:0;text-align:center}
  .fw-legend{display:flex;gap:12px;padding:4px 0 6px;font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);border-bottom:1px solid rgba(30,45,74,.3);margin-bottom:4px}
  .fw-legend span{display:flex;align-items:center;gap:3px}
  .fw-dot{width:6px;height:6px;border-radius:50%;flex-shrink:0}
  /* region labels on canvas */
  .region-label{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;fill:var(--text-muted);letter-spacing:1px;text-transform:uppercase;opacity:.6}
  .copyable{cursor:pointer;position:relative;border-bottom:1px dashed rgba(100,116,139,.4)}
  .copyable:hover{color:var(--accent-cyan);border-bottom-color:var(--accent-cyan)}
  .copy-toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(16,185,129,.9);color:#fff;font-family:'IBM Plex Mono',monospace;font-size:10px;padding:6px 16px;border-radius:5px;z-index:200;pointer-events:none;opacity:0;transition:opacity .2s}
  .copy-toast.show{opacity:1}
  @keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
  .loading-overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(10,14,23,.85);z-index:60;flex-direction:column;gap:12px}

  /* === DESIGN MODE === */
  .design-btn{background:var(--accent-orange);color:#fff;border:none;border-radius:5px;font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:600;padding:6px 10px;cursor:pointer;letter-spacing:.5px;transition:background .2s,box-shadow .2s;position:relative}
  .design-btn:hover{background:#e08700;box-shadow:0 0 8px rgba(245,158,11,.4)}
  .design-btn.active{background:#dc2626;box-shadow:0 0 10px rgba(220,38,38,.5)}
  .design-btn .change-badge{position:absolute;top:-5px;right:-5px;background:#dc2626;color:#fff;font-size:7px;min-width:14px;height:14px;border-radius:7px;display:flex;align-items:center;justify-content:center;padding:0 3px;font-weight:700}
  .design-toolbar{display:flex;gap:6px;padding:6px 8px;background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.25);border-radius:5px;margin-bottom:8px;flex-wrap:wrap;align-items:center}
  .design-toolbar button{background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1) * var(--dp-txt-scale,1));padding:3px 8px;cursor:pointer;transition:background .15s}
  .design-toolbar button:hover{background:rgba(245,158,11,.15);border-color:var(--accent-orange)}
  .design-toolbar button:disabled{opacity:.4;cursor:not-allowed}
  .design-form{background:var(--bg-card);border:1px solid var(--border);border-radius:5px;padding:8px;margin:6px 0}
  .design-form label{display:block;font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1) * var(--dp-txt-scale,1));color:var(--text-muted);margin-bottom:3px;text-transform:uppercase;letter-spacing:.5px}
  .design-form input,.design-form select{width:100%;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale,1) * var(--dp-txt-scale,1));padding:4px 6px;margin-bottom:6px;box-sizing:border-box}
  .design-form input:focus,.design-form select:focus{outline:none;border-color:var(--accent-orange)}
  .design-form input.invalid{border-color:#dc2626}
  .design-form .form-hint{font-size:calc(7px * var(--txt-scale,1) * var(--dp-txt-scale,1));color:var(--text-muted);margin-bottom:4px}
  .design-form .form-error{font-size:calc(7px * var(--txt-scale,1) * var(--dp-txt-scale,1));color:#dc2626;margin-bottom:4px}
  .design-form .form-actions{display:flex;gap:6px;margin-top:6px}
  .design-form .form-actions button{flex:1;padding:4px 8px;border-radius:4px;font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1) * var(--dp-txt-scale,1));cursor:pointer;border:1px solid var(--border)}
  .design-form .btn-confirm{background:var(--accent-orange);color:#fff;border-color:var(--accent-orange)}
  .design-form .btn-confirm:disabled{opacity:.4;cursor:not-allowed}
  .design-form .btn-cancel{background:transparent;color:var(--text-muted)}
  .change-log{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:var(--bg-card);border:1px solid var(--border);border-radius:6px;max-width:600px;width:90%;max-height:200px;overflow-y:auto;z-index:45;display:none;font-family:'IBM Plex Mono',monospace;box-shadow:0 4px 16px rgba(0,0,0,.3)}
  .change-log-header{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--bg-card);z-index:1}
  .change-log-header span{font-size:9px;font-weight:600;color:var(--accent-orange);text-transform:uppercase;letter-spacing:.5px}
  .change-log-header button{background:transparent;border:none;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:8px;cursor:pointer;padding:2px 6px}
  .change-log-header button:hover{color:#dc2626}
  .change-log-item{display:flex;justify-content:space-between;align-items:center;padding:4px 10px;border-bottom:1px solid rgba(30,45,74,.15);font-size:8px;color:var(--text-secondary)}
  .change-log-item:last-child{border-bottom:none}
  .change-log-item .cl-desc{flex:1}
  .change-log-item .cl-undo{background:transparent;border:1px solid var(--border);border-radius:3px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:7px;padding:1px 6px;cursor:pointer}
  .change-log-item .cl-undo:hover{border-color:#dc2626;color:#dc2626}
  .design-added rect,.design-added circle{stroke:var(--accent-green)!important;stroke-width:2!important;stroke-dasharray:4 2!important}
  .design-modified rect,.design-modified circle{stroke:var(--accent-orange)!important;stroke-width:2!important}
  .design-removed{opacity:.4!important}
  .design-removed rect,.design-removed circle{stroke:#dc2626!important;stroke-dasharray:6 3!important}

  /* === COMPLIANCE ENGINE === */
  .compliance-chip{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:10px;font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1));cursor:pointer;transition:background .15s;border:1px solid var(--border)}
  .compliance-chip.clean{background:rgba(16,185,129,.12);border-color:rgba(16,185,129,.3);color:#10b981}
  .compliance-chip.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.3);color:#f59e0b}
  .compliance-chip.critical{background:rgba(220,38,38,.12);border-color:rgba(220,38,38,.3);color:#dc2626}
  .compliance-chip:hover{filter:brightness(1.2)}
  .compliance-panel{padding:8px 0}
  .compliance-group{margin-bottom:10px}
  .compliance-group-header{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale,1) * var(--dp-txt-scale,1));font-weight:600;color:var(--text-primary);padding:4px 0;border-bottom:1px solid var(--border);margin-bottom:4px;text-transform:uppercase;letter-spacing:.5px}
  .finding-row{padding:5px 0;border-bottom:1px solid rgba(30,45,74,.12);cursor:pointer}
  .finding-row:hover{background:rgba(100,116,139,.06)}
  .finding-summary{display:flex;align-items:center;gap:6px;font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1) * var(--dp-txt-scale,1))}
  .sev-badge{font-size:calc(7px * var(--txt-scale,1) * var(--dp-txt-scale,1));font-weight:700;padding:1px 5px;border-radius:3px;text-transform:uppercase;letter-spacing:.5px;flex-shrink:0}
  .sev-CRITICAL{background:rgba(220,38,38,.2);color:#dc2626}
  .sev-HIGH{background:rgba(239,68,68,.15);color:#ef4444}
  .sev-MEDIUM{background:rgba(245,158,11,.15);color:#f59e0b}
  .sev-LOW{background:rgba(59,130,246,.15);color:#3b82f6}
  .finding-detail{display:none;padding:4px 0 4px 20px;font-family:'IBM Plex Mono',monospace;font-size:calc(7.5px * var(--txt-scale,1) * var(--dp-txt-scale,1));color:var(--text-muted);line-height:1.5}
  .finding-detail .fd-label{color:var(--text-secondary);font-weight:600;text-transform:uppercase;font-size:calc(6.5px * var(--txt-scale,1) * var(--dp-txt-scale,1));letter-spacing:.5px}
  .finding-row.expanded .finding-detail{display:block}
  .compliance-badge{position:absolute;top:-4px;right:-4px;width:10px;height:10px;border-radius:50%;border:1.5px solid var(--bg-card);z-index:2}
  .compliance-export-bar{display:flex;gap:6px;padding:6px 0;border-top:1px solid var(--border);margin-top:8px;flex-wrap:wrap}
  .compliance-export-bar button{background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale,1) * var(--dp-txt-scale,1));padding:3px 8px;cursor:pointer}
  .compliance-export-bar button:hover{background:rgba(96,165,250,.1);border-color:var(--accent-cyan)}
  .compliance-filter{display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap}
  .compliance-filter button{background:transparent;border:1px solid var(--border);border-radius:10px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:calc(7px * var(--txt-scale,1) * var(--dp-txt-scale,1));padding:2px 8px;cursor:pointer}
  .compliance-filter button.active{background:rgba(96,165,250,.15);border-color:var(--accent-cyan);color:var(--accent-cyan)}

</style>
</head>
<body>
<div class="sidebar">
  <div class="sidebar-header">
    <h1>AWS Network Map <span style="font-size:8px;color:var(--text-muted);font-weight:400">v27</span></h1>
    <p>Paste CLI JSON exports or upload folder</p>
    <div class="global-txt-ctrl">
      <span class="gtc-label">Text Size</span>
      <button class="gtc-btn" id="gTxtDown">-</button>
      <span class="gtc-val" id="gTxtVal">100%</span>
      <button class="gtc-btn" id="gTxtUp">+</button>
    </div>
  </div>
  <div class="upload-row">
    <button class="btn-upload" id="uploadBtn">Upload JSON Files</button>
    <input type="file" id="fileInput" multiple accept=".json" style="display:none" />
  </div>
  <div class="upload-status" id="uploadStatus"></div>
  <div class="sidebar-body" id="sidebarBody"></div>
  <div class="sidebar-actions">
    <button class="btn btn-demo" id="loadDemo">Demo</button>
    <button class="btn btn-secondary" id="clearBtn">Clear</button>
    <button class="btn btn-primary" id="renderBtn">Render Map</button>
  </div>
</div>
<button class="sidebar-toggle" id="sidebarToggle" title="Toggle sidebar">&#x25C0;</button>
<div class="main">
  <div class="grid-bg"></div>
  <div class="loading-overlay" id="loadingOverlay"><div style="width:40px;height:40px;border:3px solid var(--border);border-top-color:var(--accent-cyan);border-radius:50%;animation:spin 1s linear infinite"></div><div style="font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--text-muted)">Rendering map...</div></div>
  <div class="copy-toast" id="copyToast">Copied!</div>
  <div class="empty-state" id="emptyState"><div class="icon">&#9700;</div><h2>No data loaded</h2><p>Paste AWS CLI JSON exports and click Render Map</p></div>
  <svg id="mapSvg"></svg>
  <div class="stats-bar" id="statsBar"></div>
  <div class="legend" id="legend">
    <div class="legend-title" onclick="this.parentElement.classList.toggle('collapsed')">Legend <span class="lg-arr">&#9660;</span></div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--subnet-public)"></div>Public Subnet</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--subnet-private)"></div>Private Subnet</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--igw-color)"></div>Internet GW</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--nat-color)"></div>NAT GW</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--vgw-color)"></div>Virtual Private GW</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--tgw-color)"></div>Transit GW</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--vpce-color)"></div>VPC Endpoint</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--pcx-color)"></div>Peering / VPN</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--alb-color)"></div>Load Balancer</div>
    <div class="legend-item"><div class="legend-swatch" style="border:1.5px dashed var(--vpc-stroke);background:transparent"></div>VPC Boundary</div>
    <div class="legend-hint">Click subnets for full details | Hover to trace routes</div>
  </div>
  <div class="zoom-controls">
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomOut">-</button>
    <button class="zoom-btn" id="zoomFit">~</button>
    <div id="zoomLevel" style="font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted);text-align:center;padding:2px 0;min-width:32px">100%</div>
    <div id="detailBtns" style="display:flex;flex-direction:column;gap:4px;margin-top:4px;border-top:1px solid var(--border);padding-top:4px">
      <button class="zoom-btn wide" id="btnExpand" title="Show all resources with nested details">Expand</button>
      <button class="zoom-btn wide" id="btnCollapse" title="Collapse to VPCs and subnet names only">Collapse</button>
    </div>
    <div style="margin-top:6px;border-top:1px solid var(--border);padding-top:6px">
      <button class="design-btn" id="designToggle" title="Enter Design Mode to propose changes">Design</button>
    </div>
  </div>
  <div class="change-log" id="changeLog"></div>
  <div class="export-bar collapsed" id="exportBar">
    <button class="eb-toggle" id="ebToggle">Export &#9654;</button>
    <div style="display:flex;align-items:center;gap:8px;margin-right:12px;padding-right:12px;border-right:1px solid var(--border)">
      <label style="font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);text-transform:uppercase">Layout</label>
      <select id="layoutMode" style="background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:9px;padding:4px 6px;cursor:pointer">
        <option value="grid">Grid (columns)</option>
        <option value="landingzone">Landing Zone (hub-spoke)</option>
        <option value="executive">Executive Overview</option>
      </select>
      <input type="text" id="hubVpcName" placeholder="Hub VPC name (auto)" style="background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:9px;padding:4px 6px;width:120px;display:none" title="Specify hub VPC name or leave blank for auto-detect">
    </div>
    <button class="export-btn" id="expPng">PNG Image<span>Auto-scaled to fit</span></button>
    <button class="export-btn" id="expVsdx" style="border-color:var(--accent-green)">Visio VSDX<span>Import into Lucidchart</span></button>
    <button class="export-btn" id="expLucidDl">Lucid File (.lucid)<span>Download for manual import</span></button>
  </div>
  <div class="hl-locked-indicator" id="hlLockInd">Highlight locked -- click to unlock</div>
  <div class="tooltip" id="tooltip"></div>
  <div class="detail-panel" id="detailPanel">
    <div class="dp-header">
      <div><div class="dp-title" id="dpTitle"></div><div class="dp-subtitle" id="dpSub"></div></div>
      <button class="dp-close" id="dpClose">x</button>
    </div>
    <div class="dp-toolbar">
      <span class="dp-size-label">Text</span>
      <button class="dp-size-btn" id="dpSizeDown">-</button>
      <button class="dp-size-btn" id="dpSizeUp">+</button>
      <button class="dp-size-btn" id="dpSizeReset" style="font-size:9px;width:auto;padding:0 6px">Reset</button>
    </div>
    <div class="dp-body" id="dpBody"></div>
  </div>
</div>
<script>
// Preferences persistence
const PREFS_KEY='awsNetMapPrefs';
function loadPrefs(){try{const r=localStorage.getItem(PREFS_KEY);return r?JSON.parse(r):{}}catch(e){return {}}}
function savePrefs(p){const c=loadPrefs();Object.assign(c,p);try{localStorage.setItem(PREFS_KEY,JSON.stringify(c))}catch(e){}}
const _prefs=loadPrefs();

// Global text size scaling - works on sidebar, canvas, and detail panel
let gTxtScale=_prefs.gTxtScale||1.0;
function applyGlobalTxtScale(){
  document.documentElement.style.setProperty('--txt-scale',gTxtScale);
  document.getElementById('gTxtVal').textContent=Math.round(gTxtScale*100)+'%';
}
document.getElementById('gTxtUp').addEventListener('click',()=>{gTxtScale=Math.min(2.5,gTxtScale+0.15);applyGlobalTxtScale();savePrefs({gTxtScale})});
document.getElementById('gTxtDown').addEventListener('click',()=>{gTxtScale=Math.max(0.5,gTxtScale-0.15);applyGlobalTxtScale();savePrefs({gTxtScale})});

// Sidebar collapse toggle
document.getElementById('sidebarToggle').addEventListener('click',()=>{
  const sb=document.querySelector('.sidebar');
  const btn=document.getElementById('sidebarToggle');
  sb.classList.toggle('collapsed');
  btn.innerHTML=sb.classList.contains('collapsed')?'&#x25B6;':'&#x25C0;';
  savePrefs({sidebarCollapsed:sb.classList.contains('collapsed')});
});
// Restore sidebar state
if(_prefs.sidebarCollapsed){
  document.querySelector('.sidebar').classList.add('collapsed');
  document.getElementById('sidebarToggle').innerHTML='&#x25B6;';
}
// Apply saved text scale on load
if(_prefs.gTxtScale) applyGlobalTxtScale();

const inputSections=[
  {t:'Network',open:true,inputs:[
    {id:'in_vpcs',l:'VPCs',c:'describe-vpcs'},
    {id:'in_subnets',l:'Subnets',c:'describe-subnets'},
    {id:'in_rts',l:'Route Tables',c:'describe-route-tables'},
    {id:'in_sgs',l:'Security Groups',c:'describe-security-groups'},
    {id:'in_nacls',l:'Network ACLs',c:'describe-network-acls'},
    {id:'in_enis',l:'ENIs',c:'describe-network-interfaces'},
  ]},
  {t:'Gateways',open:true,inputs:[
    {id:'in_igws',l:'Internet GWs',c:'describe-internet-gateways'},
    {id:'in_nats',l:'NAT GWs',c:'describe-nat-gateways'},
    {id:'in_vpces',l:'VPC Endpoints',c:'describe-vpc-endpoints'},
  ]},
  {t:'Compute',open:false,inputs:[
    {id:'in_ec2',l:'EC2 Instances',c:'describe-instances'},
    {id:'in_rds',l:'RDS Instances',c:'rds describe-db-instances'},
    {id:'in_ecs',l:'ECS Services',c:'ecs describe-services (see export script)'},
    {id:'in_lambda',l:'Lambda (VPC)',c:'lambda list-functions'},
    {id:'in_elasticache',l:'ElastiCache',c:'elasticache describe-cache-clusters --show-cache-node-info'},
    {id:'in_redshift',l:'Redshift',c:'redshift describe-clusters'},
  ]},
  {t:'Load Balancers',open:false,inputs:[
    {id:'in_albs',l:'ALBs / NLBs',c:'elbv2 describe-load-balancers'},
    {id:'in_tgs',l:'Target Groups',c:'elbv2 describe-target-groups'},
  ]},
  {t:'Connectivity',open:false,inputs:[
    {id:'in_peer',l:'VPC Peering',c:'describe-vpc-peering-connections'},
    {id:'in_vpn',l:'VPN Connections',c:'describe-vpn-connections'},
    {id:'in_tgwatt',l:'TGW Attachments',c:'describe-transit-gateway-attachments'},
  ]},
  {t:'Edge',open:false,inputs:[
    {id:'in_cf',l:'CloudFront',c:'cloudfront list-distributions'},
  ]},
  {t:'Storage',open:false,inputs:[
    {id:'in_vols',l:'Volumes',c:'describe-volumes'},
    {id:'in_snaps',l:'Snapshots',c:'describe-snapshots --owner-ids self'},
    {id:'in_s3',l:'S3 Buckets',c:'s3api list-buckets'},
  ]},
  {t:'DNS',open:false,inputs:[
    {id:'in_r53',l:'Hosted Zones',c:'route53 list-hosted-zones'},
    {id:'in_r53records',l:'Record Sets',c:'route53 list-resource-record-sets --hosted-zone-id &lt;zone-id&gt;'},
  ]},
  {t:'Security',open:false,inputs:[
    {id:'in_waf',l:'WAF WebACLs',c:'wafv2 list-web-acls --scope REGIONAL'},
  ]},
  {t:'IAM',open:false,inputs:[
    {id:'in_iam',l:'IAM Auth Details',c:'iam get-account-authorization-details'},
  ]},
];

// build sidebar
const sb=document.getElementById('sidebarBody');
inputSections.forEach(sec=>{
  const h=document.createElement('div');h.className='sec-hdr'+(sec.open?'':' collapsed');
  h.innerHTML=`<span>${sec.t}</span><span class="arr">&#9660;</span>`;
  const b=document.createElement('div');b.className='sec-body'+(sec.open?'':' hidden');
  sec.inputs.forEach(inp=>{b.innerHTML+=`<div class="ig"><div class="ig-lbl"><span>${inp.l}</span><code>${inp.c}</code></div><textarea id="${inp.id}" class="ji" placeholder="Paste ${inp.c} JSON..."></textarea></div>`});
  h.addEventListener('click',()=>{h.classList.toggle('collapsed');b.classList.toggle('hidden')});
  sb.appendChild(h);sb.appendChild(b);
});
document.querySelectorAll('.ji').forEach(el=>{el.addEventListener('input',function(){if(!this.value.trim()){this.className='ji';return}try{JSON.parse(this.value);this.className='ji valid'}catch(e){this.className='ji invalid'}})});

function safeParse(t){if(!t||!t.trim())return null;try{return JSON.parse(t.trim())}catch(e){const b=[];let d=0,s=-1;for(let i=0;i<t.length;i++){if(t[i]==='{'){if(d===0)s=i;d++}if(t[i]==='}'){d--;if(d===0&&s>=0){b.push(t.substring(s,i+1));s=-1}}}return b.length?b.map(x=>JSON.parse(x)):null}}
function ext(r,keys){if(!r)return[];const a=Array.isArray(r)?r:[r];let res=[];for(const i of a)for(const k of keys)if(i[k])res=res.concat(i[k]);return res}
function gn(i,f){const t=(i.Tags||[]).find(x=>x.Key==='Name');return t?t.Value:f}
function sid(id){return id?id.replace(/^[a-z]+-/,'').substring(0,10):''}
function clsGw(id){const m={'igw-':'IGW','vgw-':'VGW','vpce-':'VPCE','pcx-':'PCX','eigw-':'EIGW','lgw-':'LGW'};for(const[p,t]of Object.entries(m))if(id.startsWith(p))return t;return'GW'}
function isShared(t){return t==='TGW'||t==='PCX'}
function gcv(t){return{IGW:'var(--igw-color)',NAT:'var(--nat-color)',TGW:'var(--tgw-color)',VGW:'var(--vgw-color)',VPCE:'var(--vpce-color)',PCX:'var(--pcx-color)',EIGW:'var(--igw-color)'}[t]||'var(--text-muted)'}
function gch(t){return{IGW:'#10b981',NAT:'#f59e0b',TGW:'#ec4899',VGW:'#ef4444',VPCE:'#a78bfa',PCX:'#fb923c',EIGW:'#10b981'}[t]||'#4a5e80'}
function gv(id){return(document.getElementById(id)||{}).value||''}

// === CIDR ENGINE ===
const ipToInt=(ip)=>{if(!ip||typeof ip!=='string')return null;const parts=ip.split('.');if(parts.length!==4)return null;let n=0;for(let i=0;i<4;i++){const o=parseInt(parts[i],10);if(isNaN(o)||o<0||o>255||parts[i]!==String(o))return null;n=(n*256)+o}return n>>>0};
const intToIp=(n)=>{n=n>>>0;return`${(n>>>24)&0xFF}.${(n>>>16)&0xFF}.${(n>>>8)&0xFF}.${n&0xFF}`};
const parseCIDR=(cidr)=>{if(!cidr||typeof cidr!=='string')return null;const parts=cidr.trim().split('/');if(parts.length!==2)return null;const network=ipToInt(parts[0]);const prefix=parseInt(parts[1],10);if(network===null||isNaN(prefix)||prefix<0||prefix>32||parts[1]!==String(prefix))return null;const mask=prefix===0?0:(0xFFFFFFFF<<(32-prefix))>>>0;if((network&mask)!==network)return null;const size=prefix===32?1:(1<<(32-prefix))>>>0;return{network,prefix,mask,size}};
const cidrToString=(network,prefix)=>`${intToIp(network)}/${prefix}`;
const splitCIDR=(cidr)=>{const p=parseCIDR(cidr);if(!p||p.prefix>=32)return null;const np=p.prefix+1;const half=p.size>>>1;return[cidrToString(p.network,np),cidrToString((p.network+half)>>>0,np)]};
const cidrContains=(parent,child)=>{const p=parseCIDR(parent);const c=parseCIDR(child);if(!p||!c||c.prefix<p.prefix)return false;return(c.network&p.mask)===p.network};
const cidrOverlap=(a,b)=>{const pa=parseCIDR(a);const pb=parseCIDR(b);if(!pa||!pb)return false;const bigger=pa.prefix<=pb.prefix?pa:pb;const smaller=pa.prefix<=pb.prefix?pb:pa;return(smaller.network&bigger.mask)===bigger.network};
const ipInCIDR=(ip,cidr)=>{const n=ipToInt(ip);const p=parseCIDR(cidr);if(n===null||!p)return false;return(n&p.mask)===p.network};

// large-scale demo generator -- enterprise AWS environment
function generateDemo(){
  const AZS=['us-east-1a','us-east-1b','us-east-1c'];
  const INST_TYPES=['t3.micro','t3.small','t3.medium','t3.large','m5.large','m5.xlarge','m5.2xlarge','r5.large','r5.xlarge','r5.2xlarge','c5.large','c5.xlarge'];
  const STATES=['running','running','running','running','running','stopped'];
  const LB_TYPES=['application','network'];
  const SVC_ENDPOINTS=['s3','dynamodb','ssm','ssmmessages','ec2messages','logs','monitoring','kms','secretsmanager','sts','ecr.api','ecr.dkr','execute-api','elasticloadbalancing','autoscaling','sqs','sns','events'];
  let iid=1;function nid(p){return p+'-'+String(iid++).padStart(5,'0')}

  // VPC definitions -- enterprise multi-account pattern
  const vpcDefs=[
    {name:'Production',cidr:'10.0.0.0/16',tiers:['public','private-web','private-app','private-api','private-data','private-cache','private-queue','private-mgmt'],azsUsed:3,instancesPer:[4,6,10,8,6,4,3,2],albCount:5},
    {name:'Staging',cidr:'10.1.0.0/16',tiers:['public','private-web','private-app','private-data','private-cache'],azsUsed:3,instancesPer:[2,4,6,4,2],albCount:3},
    {name:'Development',cidr:'10.2.0.0/16',tiers:['public','private-app','private-data','private-test'],azsUsed:2,instancesPer:[2,6,3,4],albCount:2},
    {name:'QA-Automation',cidr:'10.3.0.0/16',tiers:['public','private-runners','private-selenium','private-data'],azsUsed:2,instancesPer:[1,8,6,2],albCount:1},
    {name:'Shared-Services',cidr:'10.10.0.0/16',tiers:['public','private-tools','private-monitoring','private-cicd','private-artifact','private-vault'],azsUsed:3,instancesPer:[2,5,4,6,3,2],albCount:3},
    {name:'Data-Platform',cidr:'10.20.0.0/16',tiers:['private-ingest','private-streaming','private-processing','private-warehouse','private-analytics','private-ml'],azsUsed:3,instancesPer:[5,4,8,4,3,6],albCount:2},
    {name:'Security',cidr:'10.30.0.0/16',tiers:['public','private-siem','private-scanner','private-forensics','private-logging'],azsUsed:2,instancesPer:[1,4,3,2,4],albCount:1},
    {name:'DR-Recovery',cidr:'10.40.0.0/16',tiers:['public','private-web','private-app','private-data'],azsUsed:2,instancesPer:[2,3,5,3],albCount:2},
    {name:'Edge-Services',cidr:'10.50.0.0/16',tiers:['public','private-proxy','private-waf','private-cdn-origin'],azsUsed:3,instancesPer:[3,4,3,2],albCount:3},
    {name:'Management',cidr:'10.100.0.0/16',tiers:['public','private-bastion','private-logging','private-backup','private-config'],azsUsed:2,instancesPer:[1,3,4,3,2],albCount:1},
    {name:'Sandbox',cidr:'10.200.0.0/16',tiers:['public','private-dev1','private-dev2','private-experiment'],azsUsed:2,instancesPer:[1,5,5,3],albCount:1},
    {name:'PCI-Compliant',cidr:'10.60.0.0/16',tiers:['private-dmz','private-app','private-tokenize','private-vault','private-audit'],azsUsed:3,instancesPer:[3,6,4,2,2],albCount:2},
  ];

  const vpcs=[],subnets=[],rts=[],sgs=[],nacls=[],igwsList=[],natsList=[];
  const ec2Instances=[],albsList=[],vpceList=[];
  const volsList=[],enisList=[],snapsList=[],tgsList=[];
  let subOct=0;

  vpcDefs.forEach((vd,vi)=>{
    const vpcId='vpc-'+vd.name.toLowerCase().replace(/[^a-z0-9]/g,'');
    vpcs.push({VpcId:vpcId,CidrBlock:vd.cidr,State:'available',Tags:[{Key:'Name',Value:vd.name}]});

    // IGW for VPCs with public tiers
    const hasPublic=vd.tiers.some(t=>t.startsWith('public'));
    const igwId=nid('igw');
    if(hasPublic){igwsList.push({InternetGatewayId:igwId,Attachments:[{VpcId:vpcId,State:'available'}],Tags:[{Key:'Name',Value:vd.name+'-igw'}]})}

    // NAT per AZ for non-public tiers
    const natIds=[];
    if(hasPublic){
      for(let a=0;a<Math.min(vd.azsUsed,2);a++){
        const natId=nid('nat');
        natIds.push(natId);
        natsList.push({NatGatewayId:natId,VpcId:vpcId,SubnetId:null,State:'available',Tags:[{Key:'Name',Value:vd.name+'-nat-'+AZS[a].slice(-2)}]});
      }
    }

    // SGs per VPC -- realistic set per tier
    const sgDefs=['web-https','web-http','app-internal','api-gateway','db-mysql','db-postgres','db-redis',
      'monitoring-agents','ssh-bastion','alb-external','alb-internal','efs-mount','elasticsearch','memcached',
      'vpn-access','mgmt-rdp'];
    const sgCount=Math.min(sgDefs.length, vd.tiers.length*2+4);
    for(let si=0;si<sgCount;si++){
      const sgName=sgDefs[si];
      const ports={https:[443,443],http:[80,80],'app-internal':[8080,8099],'api-gateway':[8443,8443],
        'db-mysql':[3306,3306],'db-postgres':[5432,5432],'db-redis':[6379,6379],
        'monitoring-agents':[9090,9100],elasticsearch:[9200,9300],memcached:[11211,11211],
        'mgmt-rdp':[3389,3389],'ssh-bastion':[22,22]}[sgName]||[443,443];
      sgs.push({GroupId:nid('sg'),GroupName:vd.name.toLowerCase()+'-'+sgName,VpcId:vpcId,
        IpPermissions:[{IpProtocol:'tcp',FromPort:ports[0],ToPort:ports[1],IpRanges:[{CidrIp:sgName.includes('ssh')||sgName.includes('rdp')?'10.0.0.0/8':'0.0.0.0/0'}]},
          {IpProtocol:'tcp',FromPort:22,ToPort:22,IpRanges:[{CidrIp:'10.0.0.0/8'}]}],
        IpPermissionsEgress:[{IpProtocol:'-1',IpRanges:[{CidrIp:'0.0.0.0/0'}]}],
        Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+sgName}]
      });
    }

    // subnets and route tables per tier
    vd.tiers.forEach((tier,ti)=>{
      const isPub=tier.startsWith('public');
      const rtId=nid('rtb');
      const routes=[{DestinationCidrBlock:vd.cidr,GatewayId:'local'}];
      if(isPub)routes.push({DestinationCidrBlock:'0.0.0.0/0',GatewayId:igwId});
      // cross-VPC via TGW
      routes.push({DestinationCidrBlock:'10.0.0.0/8',TransitGatewayId:'tgw-enterprise01'});

      // NACL per tier
      const naclId=nid('acl');
      const naclAssocs=[];
      const naclEntries=[
        {RuleNumber:100,Protocol:'6',RuleAction:'allow',Egress:false,CidrBlock:'0.0.0.0/0',PortRange:{From:443,To:443}},
        {RuleNumber:110,Protocol:'6',RuleAction:'allow',Egress:false,CidrBlock:'10.0.0.0/8',PortRange:{From:0,To:65535}},
        {RuleNumber:120,Protocol:'6',RuleAction:'allow',Egress:false,CidrBlock:'0.0.0.0/0',PortRange:{From:1024,To:65535}},
      ];
      if(isPub)naclEntries.push({RuleNumber:130,Protocol:'6',RuleAction:'allow',Egress:false,CidrBlock:'0.0.0.0/0',PortRange:{From:80,To:80}});
      naclEntries.push({RuleNumber:32767,Protocol:'-1',RuleAction:'deny',Egress:false,CidrBlock:'0.0.0.0/0'});

      const assocs=[];
      for(let a=0;a<vd.azsUsed;a++){
        const subId=nid('subnet');
        const oct2=ti*10+subOct;
        subnets.push({SubnetId:subId,VpcId:vpcId,CidrBlock:vd.cidr.replace(/\.0\.0\//,'.'+oct2+'.'+a+'/').replace(/\/16/,'/24'),
          AvailabilityZone:AZS[a],MapPublicIpOnLaunch:isPub,
          Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+tier+'-'+AZS[a].slice(-2)}]});
        if(!isPub && natIds.length){
          const azRtId=nid('rtb');
          rts.push({RouteTableId:azRtId,VpcId:vpcId,
            Routes:[{DestinationCidrBlock:vd.cidr,GatewayId:'local'},
              {DestinationCidrBlock:'0.0.0.0/0',NatGatewayId:natIds[Math.min(a,natIds.length-1)]},
              {DestinationCidrBlock:'10.0.0.0/8',TransitGatewayId:'tgw-enterprise01'}],
            Associations:[{SubnetId:subId,RouteTableAssociationId:nid('rtbassoc')}],
            Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+tier+'-'+AZS[a].slice(-2)+'-rt'}]});
        }else{
          assocs.push({SubnetId:subId,RouteTableAssociationId:nid('rtbassoc')});
        }
        naclAssocs.push({SubnetId:subId});

        // assign NAT subnet
        if(isPub&&a<natIds.length&&natsList[natsList.length-vd.azsUsed+a+Math.min(a,natIds.length-1)])
          natsList.forEach(n=>{if(n.NatGatewayId===natIds[a]&&!n.SubnetId)n.SubnetId=subId});

        // EC2 instances
        const instCount=vd.instancesPer[ti]||0;
        for(let ii=0;ii<instCount;ii++){
          const instId=nid('i');
          const iType=INST_TYPES[Math.floor(Math.random()*INST_TYPES.length)];
          const st=STATES[Math.floor(Math.random()*STATES.length)];
          ec2Instances.push({InstanceId:instId,SubnetId:subId,InstanceType:iType,
            PrivateIpAddress:'10.'+Math.floor(Math.random()*255)+'.'+Math.floor(Math.random()*255)+'.'+Math.floor(Math.random()*254+1),
            Placement:{AvailabilityZone:AZS[a]},
            State:{Name:st,Code:st==='running'?16:80},
            Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+tier.replace('private-','')+'-'+String(ii+1).padStart(2,'0')}]});

          // volume per instance (root)
          const volSize=[50,100,200,500][Math.floor(Math.random()*4)];
          volsList.push({VolumeId:nid('vol'),Size:volSize,State:'in-use',VolumeType:'gp3',
            AvailabilityZone:AZS[a],Attachments:[{InstanceId:instId,Device:'/dev/sda1',State:'attached'}]});

          // data volume for data/cache/warehouse tiers
          if(tier.includes('data')||tier.includes('cache')||tier.includes('warehouse')||tier.includes('ml')){
            const dataSize=[200,500,1000,2000][Math.floor(Math.random()*4)];
            volsList.push({VolumeId:nid('vol'),Size:dataSize,State:'in-use',VolumeType:'io2',
              AvailabilityZone:AZS[a],Attachments:[{InstanceId:instId,Device:'/dev/sdf',State:'attached'}]});
          }

          // ENI per instance
          enisList.push({NetworkInterfaceId:nid('eni'),SubnetId:subId,VpcId:vpcId,
            InterfaceType:'interface',Status:'in-use',
            Attachment:{InstanceId:instId,Status:'attached'}});

          // secondary ENI for multi-homed instances
          if(tier.includes('app')||tier.includes('proxy')||tier.includes('web')){
            enisList.push({NetworkInterfaceId:nid('eni'),SubnetId:subId,VpcId:vpcId,
              InterfaceType:'interface',Status:'in-use',
              Attachment:{InstanceId:instId,Status:'attached'}});
          }

          // snapshot for ~40% of volumes
          if(Math.random()>0.6){snapsList.push({SnapshotId:nid('snap'),VolumeId:volsList[volsList.length-1].VolumeId,
            State:'completed',VolumeSize:volSize,StartTime:'2025-01-15T00:00:00Z'})}
        }
      }

      if(isPub || !natIds.length) rts.push({RouteTableId:rtId,VpcId:vpcId,Routes:routes,Associations:assocs,
        Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+tier+'-rt'}]});
      nacls.push({NetworkAclId:naclId,VpcId:vpcId,Associations:naclAssocs,Entries:naclEntries,
        Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+tier+'-nacl'}]});
      subOct++;
    });

    // ALBs
    for(let lb=0;lb<vd.albCount;lb++){
      const pubSubs=subnets.filter(s=>s.VpcId===vpcId&&(s.Tags[0]?.Value||'').includes('public'));
      const prvSubs=subnets.filter(s=>s.VpcId===vpcId&&!(s.Tags[0]?.Value||'').includes('public'));
      const lbSubs=pubSubs.length?pubSubs:prvSubs;
      const scheme=pubSubs.length&&lb===0?'internet-facing':'internal';
      const lbType=LB_TYPES[lb%2];
      albsList.push({
        LoadBalancerArn:'arn:aws:elasticloadbalancing:us-east-1:123456789:loadbalancer/'+lbType+'/'+vd.name.toLowerCase()+'-'+lbType.slice(0,3)+'-'+lb+'/abc'+lb,
        LoadBalancerName:vd.name.toLowerCase()+'-'+lbType.slice(0,3)+'-'+lb,
        Type:lbType,Scheme:scheme,VpcId:vpcId,
        AvailabilityZones:lbSubs.slice(0,vd.azsUsed).map(s=>({SubnetId:s.SubnetId,ZoneName:s.AvailabilityZone})),
        State:{Code:'active'},DNSName:vd.name.toLowerCase()+'-'+lb+'.us-east-1.elb.amazonaws.com'
      });
    }

    // VPC endpoints -- prod/shared/data get all 18, others scale down
    const epCount=Math.min(SVC_ENDPOINTS.length, vi<3?18:vi<6?12:6+vi);
    for(let e=0;e<epCount;e++){
      vpceList.push({VpcEndpointId:nid('vpce'),VpcId:vpcId,
        ServiceName:'com.amazonaws.us-east-1.'+SVC_ENDPOINTS[e],
        VpcEndpointType:e<2?'Gateway':'Interface',State:'available',
        SubnetIds:subnets.filter(s=>s.VpcId===vpcId).slice(0,2).map(s=>s.SubnetId),
        Tags:[{Key:'Name',Value:vd.name.toLowerCase()+'-'+SVC_ENDPOINTS[e]}]});
    }

    // Target Groups for each ALB
    albsList.filter(a=>a.VpcId===vpcId).forEach((alb,li)=>{
      const tgInsts=ec2Instances.filter(i=>i.SubnetId&&subnets.some(s=>s.SubnetId===i.SubnetId&&s.VpcId===vpcId)).slice(0,3+li);
      const tgType=alb.Type==='application'?'instance':'ip';
      tgsList.push({
        TargetGroupArn:'arn:aws:elasticloadbalancing:us-east-1:123456789:targetgroup/'+vd.name.toLowerCase()+'-tg-'+li+'/abc'+li,
        TargetGroupName:vd.name.toLowerCase()+'-tg-'+li,
        Protocol:li%2===0?'HTTPS':'HTTP',Port:li%2===0?443:80,
        VpcId:vpcId,TargetType:tgType,
        HealthCheckProtocol:'HTTP',HealthCheckPort:'traffic-port',HealthCheckPath:'/health',
        HealthCheckIntervalSeconds:30,HealthyThresholdCount:3,UnhealthyThresholdCount:3,
        LoadBalancerArns:[alb.LoadBalancerArn],
        Targets:tgInsts.map(i=>({Id:i.InstanceId,Port:li%2===0?443:80}))
      });
    });
  });

  // peering connections -- hub-spoke from shared-services + key pairs
  const peerings=[];
  const sharedIdx=4; // Shared-Services
  vpcs.forEach((v,i)=>{
    if(i===sharedIdx)return;
    peerings.push({VpcPeeringConnectionId:nid('pcx'),Status:{Code:'active'},
      RequesterVpcInfo:{VpcId:vpcs[sharedIdx].VpcId,CidrBlock:vpcs[sharedIdx].CidrBlock},
      AccepterVpcInfo:{VpcId:v.VpcId,CidrBlock:v.CidrBlock},
      Tags:[{Key:'Name',Value:'shared-to-'+v.Tags[0].Value.toLowerCase()}]});
  });
  // extra direct peerings
  [{r:0,a:1,n:'prod-to-staging'},{r:0,a:7,n:'prod-to-dr'},{r:5,a:11,n:'data-to-pci'},
   {r:6,a:9,n:'security-to-mgmt'},{r:0,a:8,n:'prod-to-edge'}].forEach(p=>{
    if(vpcs[p.r]&&vpcs[p.a])peerings.push({VpcPeeringConnectionId:nid('pcx'),Status:{Code:'active'},
      RequesterVpcInfo:{VpcId:vpcs[p.r].VpcId,CidrBlock:vpcs[p.r].CidrBlock},
      AccepterVpcInfo:{VpcId:vpcs[p.a].VpcId,CidrBlock:vpcs[p.a].CidrBlock},
      Tags:[{Key:'Name',Value:p.n}]});
  });

  // VPN connections
  const vpnConns=[
    {VpnConnectionId:nid('vpn'),State:'available',VpnGatewayId:'vgw-onprem01',CustomerGatewayId:'cgw-dc01',Tags:[{Key:'Name',Value:'datacenter-east-primary'}]},
    {VpnConnectionId:nid('vpn'),State:'available',VpnGatewayId:'vgw-onprem01',CustomerGatewayId:'cgw-dc02',Tags:[{Key:'Name',Value:'datacenter-east-backup'}]},
    {VpnConnectionId:nid('vpn'),State:'available',VpnGatewayId:'vgw-onprem02',CustomerGatewayId:'cgw-dc03',Tags:[{Key:'Name',Value:'datacenter-west-primary'}]},
    {VpnConnectionId:nid('vpn'),State:'available',VpnGatewayId:'vgw-onprem02',CustomerGatewayId:'cgw-dc04',Tags:[{Key:'Name',Value:'datacenter-west-backup'}]},
  ];

  // S3 buckets
  const s3Buckets=[];
  ['prod-assets','prod-logs','prod-backups','prod-media','prod-static','prod-config',
   'staging-deploy','staging-logs','staging-assets',
   'dev-artifacts','dev-sandbox','dev-test-data',
   'shared-terraform-state','shared-ami-store','shared-lambda-layers','shared-container-images',
   'data-lake-raw','data-lake-processed','data-lake-curated','data-lake-archive','data-lake-temp',
   'ml-training-data','ml-models','ml-experiments',
   'audit-logs','config-history','cloudtrail-logs','vpc-flow-logs','dns-query-logs',
   'dr-backup-primary','dr-backup-secondary','dr-config-mirror',
   'pci-audit-trail','pci-transaction-logs','pci-encryption-keys',
   'app-uploads','static-frontend','lambda-packages','cloudformation-templates','codepipeline-artifacts'
  ].forEach(n=>{
    s3Buckets.push({Name:n+'-'+Math.floor(Math.random()*99999),CreationDate:'2024-'+String(Math.floor(Math.random()*12)+1).padStart(2,'0')+'-15'});
  });

  // Route53
  const zones=[
    {Id:'/hostedzone/Z001',Name:'example.com.',Config:{PrivateZone:false},ResourceRecordSetCount:187},
    {Id:'/hostedzone/Z002',Name:'internal.example.com.',Config:{PrivateZone:true},ResourceRecordSetCount:342,VPCs:[{VPCId:'vpc-production'},{VPCId:'vpc-dataplatform'},{VPCId:'vpc-management'}]},
    {Id:'/hostedzone/Z003',Name:'staging.example.com.',Config:{PrivateZone:false},ResourceRecordSetCount:64},
    {Id:'/hostedzone/Z004',Name:'api.example.com.',Config:{PrivateZone:false},ResourceRecordSetCount:96},
    {Id:'/hostedzone/Z005',Name:'dev.example.com.',Config:{PrivateZone:false},ResourceRecordSetCount:78},
    {Id:'/hostedzone/Z006',Name:'data.internal.example.com.',Config:{PrivateZone:true},ResourceRecordSetCount:124,VPCs:[{VPCId:'vpc-dataplatform'}]},
    {Id:'/hostedzone/Z007',Name:'pci.example.com.',Config:{PrivateZone:true},ResourceRecordSetCount:45,VPCs:[{VPCId:'vpc-pcicompliant'},{VPCId:'vpc-security'}]},
    {Id:'/hostedzone/Z008',Name:'dr.example.com.',Config:{PrivateZone:false},ResourceRecordSetCount:52},
  ];

  // Route53 Record Sets (sample per zone)
  const r53records=[];
  zones.forEach(z=>{
    const zid=z.Id.replace('/hostedzone/','');
    const base=z.Name;
    r53records.push({HostedZoneId:zid,Name:base,Type:'NS',TTL:172800,ResourceRecords:[{Value:'ns-1.awsdns-01.org.'},{Value:'ns-2.awsdns-02.co.uk.'}]});
    r53records.push({HostedZoneId:zid,Name:base,Type:'SOA',TTL:900,ResourceRecords:[{Value:'ns-1.awsdns-01.org. awsdns-hostmaster.amazon.com. 1 7200 900 1209600 86400'}]});
    r53records.push({HostedZoneId:zid,Name:'www.'+base,Type:'A',AliasTarget:{DNSName:'dualstack.elb-prod-123456.us-east-1.elb.amazonaws.com.',HostedZoneId:'Z35SXDOTRQ7X7K',EvaluateTargetHealth:true}});
    r53records.push({HostedZoneId:zid,Name:'api.'+base,Type:'CNAME',TTL:300,ResourceRecords:[{Value:'api-gateway.execute-api.us-east-1.amazonaws.com'}]});
    r53records.push({HostedZoneId:zid,Name:'mail.'+base,Type:'MX',TTL:300,ResourceRecords:[{Value:'10 inbound-smtp.us-east-1.amazonaws.com'}]});
    r53records.push({HostedZoneId:zid,Name:'_dmarc.'+base,Type:'TXT',TTL:300,ResourceRecords:[{Value:'"v=DMARC1; p=quarantine; rua=mailto:dmarc@'+base+'"'}]});
  });

  // WAF WebACLs
  const wafAcls=[];
  const internetFacingAlbs=albsList.filter(a=>a.Scheme==='internet-facing');
  if(internetFacingAlbs.length>0){
    wafAcls.push({
      Name:'prod-web-acl',Id:'waf-001',
      ARN:'arn:aws:wafv2:us-east-1:123456789:regional/webacl/prod-web-acl/abc1',
      Description:'Production WAF - OWASP rules',
      DefaultAction:{Allow:{}},
      Rules:[{Name:'AWSManagedRulesCommonRuleSet',Priority:1},{Name:'AWSManagedRulesSQLiRuleSet',Priority:2},{Name:'RateLimit-1000',Priority:3}],
      ResourceArns:internetFacingAlbs.slice(0,2).map(a=>a.LoadBalancerArn)
    });
  }
  if(internetFacingAlbs.length>2){
    wafAcls.push({
      Name:'staging-web-acl',Id:'waf-002',
      ARN:'arn:aws:wafv2:us-east-1:123456789:regional/webacl/staging-web-acl/abc2',
      Description:'Staging WAF - basic protection',
      DefaultAction:{Allow:{}},
      Rules:[{Name:'AWSManagedRulesCommonRuleSet',Priority:1}],
      ResourceArns:internetFacingAlbs.slice(2,4).map(a=>a.LoadBalancerArn)
    });
  }
  wafAcls.push({
    Name:'pci-web-acl',Id:'waf-003',
    ARN:'arn:aws:wafv2:us-east-1:123456789:regional/webacl/pci-web-acl/abc3',
    Description:'PCI DSS compliant WAF',
    DefaultAction:{Block:{}},
    Rules:[{Name:'AWSManagedRulesCommonRuleSet',Priority:1},{Name:'AWSManagedRulesSQLiRuleSet',Priority:2},{Name:'AWSManagedRulesKnownBadInputsRuleSet',Priority:3},{Name:'AWSManagedRulesLinuxRuleSet',Priority:4}],
    ResourceArns:[]
  });

  // RDS instances - placed in private subnets
  const rdsInstances=[];
  const rdsConfigs=[
    {vpc:0,name:'prod-primary-db',engine:'aurora-mysql',cls:'db.r6g.xlarge',multi:true,storage:500},
    {vpc:0,name:'prod-replica-db',engine:'aurora-mysql',cls:'db.r6g.large',multi:false,storage:500},
    {vpc:1,name:'staging-db',engine:'postgres',cls:'db.t3.medium',multi:false,storage:100},
    {vpc:3,name:'data-warehouse-db',engine:'aurora-postgresql',cls:'db.r6g.2xlarge',multi:true,storage:2000},
    {vpc:6,name:'pci-db',engine:'mysql',cls:'db.r6g.large',multi:true,storage:200},
  ];
  rdsConfigs.forEach((rc,ri)=>{
    const vpcId=vpcs[rc.vpc]?.VpcId;if(!vpcId)return;
    const prvSubs=subnets.filter(s=>s.VpcId===vpcId&&!(s.Tags[0]?.Value||'').includes('public'));
    const sub=prvSubs[ri%Math.max(prvSubs.length,1)];
    rdsInstances.push({
      DBInstanceIdentifier:rc.name,DBInstanceClass:rc.cls,Engine:rc.engine,
      DBInstanceStatus:'available',MultiAZ:rc.multi,AllocatedStorage:rc.storage,
      Endpoint:{Address:rc.name+'.cluster-abc.us-east-1.rds.amazonaws.com',Port:rc.engine.includes('postgres')?5432:3306},
      DBSubnetGroup:{VpcId:vpcId,DBSubnetGroupName:rc.name+'-subnet-group',
        Subnets:prvSubs.slice(0,3).map(s=>({SubnetIdentifier:s.SubnetId,SubnetAvailabilityZone:{Name:s.AvailabilityZone}}))},
      VpcSecurityGroups:sgs.filter(sg=>sg.VpcId===vpcId).slice(0,1).map(sg=>({VpcSecurityGroupId:sg.GroupId,Status:'active'})),
      StorageEncrypted:true,AvailabilityZone:sub?.AvailabilityZone||'us-east-1a'
    });
  });

  // ECS services
  const ecsServices=[];
  const ecsConfigs=[
    {vpc:0,name:'prod-api',cluster:'prod-cluster',tasks:4,cpu:'512',mem:'1024'},
    {vpc:0,name:'prod-worker',cluster:'prod-cluster',tasks:2,cpu:'1024',mem:'2048'},
    {vpc:1,name:'staging-api',cluster:'staging-cluster',tasks:2,cpu:'256',mem:'512'},
    {vpc:3,name:'data-pipeline',cluster:'data-cluster',tasks:3,cpu:'2048',mem:'4096'},
  ];
  ecsConfigs.forEach(ec=>{
    const vpcId=vpcs[ec.vpc]?.VpcId;if(!vpcId)return;
    const prvSubs=subnets.filter(s=>s.VpcId===vpcId&&!(s.Tags[0]?.Value||'').includes('public'));
    ecsServices.push({
      serviceName:ec.name,clusterArn:'arn:aws:ecs:us-east-1:123456789:cluster/'+ec.cluster,
      status:'ACTIVE',desiredCount:ec.tasks,runningCount:ec.tasks,launchType:'FARGATE',
      networkConfiguration:{awsvpcConfiguration:{
        subnets:prvSubs.slice(0,2).map(s=>s.SubnetId),
        securityGroups:sgs.filter(sg=>sg.VpcId===vpcId).slice(0,1).map(sg=>sg.GroupId),
        assignPublicIp:'DISABLED'
      }},
      taskDefinition:'arn:aws:ecs:us-east-1:123456789:task-definition/'+ec.name+':12',
      cpu:ec.cpu,memory:ec.mem
    });
  });

  // Lambda VPC functions
  const lambdaFunctions=[];
  const lambdaConfigs=[
    {vpc:0,name:'prod-auth-handler',runtime:'nodejs20.x',mem:256,timeout:30},
    {vpc:0,name:'prod-image-processor',runtime:'python3.12',mem:1024,timeout:300},
    {vpc:3,name:'data-etl-trigger',runtime:'python3.12',mem:512,timeout:900},
    {vpc:4,name:'shared-log-shipper',runtime:'nodejs20.x',mem:128,timeout:60},
  ];
  lambdaConfigs.forEach(lc=>{
    const vpcId=vpcs[lc.vpc]?.VpcId;if(!vpcId)return;
    const prvSubs=subnets.filter(s=>s.VpcId===vpcId&&!(s.Tags[0]?.Value||'').includes('public'));
    lambdaFunctions.push({
      FunctionName:lc.name,Runtime:lc.runtime,MemorySize:lc.mem,Timeout:lc.timeout,
      FunctionArn:'arn:aws:lambda:us-east-1:123456789:function:'+lc.name,
      State:'Active',LastModified:'2025-01-20T00:00:00Z',
      VpcConfig:{
        VpcId:vpcId,
        SubnetIds:prvSubs.slice(0,2).map(s=>s.SubnetId),
        SecurityGroupIds:sgs.filter(sg=>sg.VpcId===vpcId).slice(0,1).map(sg=>sg.GroupId)
      }
    });
  });

  // ElastiCache
  const ecacheClusters=[];
  const ecConfigs=[
    {vpc:0,name:'prod-redis',engine:'redis',type:'cache.r6g.large',nodes:3},
    {vpc:1,name:'staging-redis',engine:'redis',type:'cache.t3.micro',nodes:1},
    {vpc:3,name:'data-redis',engine:'redis',type:'cache.r6g.xlarge',nodes:2},
  ];
  ecConfigs.forEach(ec=>{
    const vpcId=vpcs[ec.vpc]?.VpcId;if(!vpcId)return;
    ecacheClusters.push({
      CacheClusterId:ec.name,Engine:ec.engine,CacheNodeType:ec.type,
      CacheClusterStatus:'available',NumCacheNodes:ec.nodes,
      CacheSubnetGroupName:ec.name+'-subnet-group',
      VpcId:vpcId,
      CacheNodes:Array.from({length:ec.nodes},(_,i)=>({
        CacheNodeId:'000'+(i+1),CacheNodeStatus:'available',
        Endpoint:{Address:ec.name+'.abc.0001.use1.cache.amazonaws.com',Port:6379}
      })),
      SecurityGroups:sgs.filter(sg=>sg.VpcId===vpcId).slice(0,1).map(sg=>({SecurityGroupId:sg.GroupId,Status:'active'}))
    });
  });

  // Redshift
  const redshiftClusters=[];
  if(vpcs[3]){
    const vpcId=vpcs[3].VpcId;
    const prvSubs=subnets.filter(s=>s.VpcId===vpcId&&!(s.Tags[0]?.Value||'').includes('public'));
    redshiftClusters.push({
      ClusterIdentifier:'data-analytics-cluster',NodeType:'ra3.xlplus',
      ClusterStatus:'available',NumberOfNodes:4,DBName:'analytics',
      Endpoint:{Address:'data-analytics-cluster.abc.us-east-1.redshift.amazonaws.com',Port:5439},
      VpcId:vpcId,ClusterSubnetGroupName:'data-redshift-subnet-group',
      VpcSecurityGroups:sgs.filter(sg=>sg.VpcId===vpcId).slice(0,1).map(sg=>({VpcSecurityGroupId:sg.GroupId,Status:'active'})),
      Encrypted:true,
      ClusterNodes:Array.from({length:4},(_,i)=>({NodeRole:i===0?'LEADER':'COMPUTE'}))
    });
  }

  // Transit Gateway Attachments
  const tgwAttachments=[];
  vpcs.forEach(vpc=>{
    const hasRoute=rts.some(rt=>rt.VpcId===vpc.VpcId&&(rt.Routes||[]).some(r=>r.TransitGatewayId));
    if(hasRoute){
      tgwAttachments.push({
        TransitGatewayAttachmentId:nid('tgw-attach'),
        TransitGatewayId:'tgw-enterprise01',
        ResourceId:vpc.VpcId,ResourceType:'vpc',
        State:'available',
        Association:{TransitGatewayRouteTableId:'tgw-rtb-main',State:'associated'}
      });
    }
  });

  // CloudFront
  const cfDistributions=[];
  const cfAlbs=albsList.filter(a=>a.Scheme==='internet-facing').slice(0,2);
  cfAlbs.forEach((alb,ci)=>{
    cfDistributions.push({
      Id:'E'+String(ci+1).padStart(13,'0'),DomainName:'d'+String(ci+1).padStart(13,'0')+'.cloudfront.net',
      Status:'Deployed',Enabled:true,
      Origins:{Items:[{
        DomainName:alb.DNSName,Id:'ALB-'+alb.LoadBalancerName,
        CustomOriginConfig:{HTTPPort:80,HTTPSPort:443,OriginProtocolPolicy:'https-only'}
      }]},
      DefaultCacheBehavior:{ViewerProtocolPolicy:'redirect-to-https',Compress:true},
      ViewerCertificate:{ACMCertificateArn:'arn:aws:acm:us-east-1:123456789:certificate/abc-'+ci},
      Aliases:{Items:ci===0?['www.example.com','api.example.com']:['staging.example.com']},
      WebACLId:wafAcls.length>ci?wafAcls[ci].ARN:''
    });
  });
  if(s3Buckets.length>0){
    cfDistributions.push({
      Id:'E0000000000003',DomainName:'d0000000000003.cloudfront.net',
      Status:'Deployed',Enabled:true,
      Origins:{Items:[{
        DomainName:s3Buckets[4].Name+'.s3.amazonaws.com',Id:'S3-'+s3Buckets[4].Name,
        S3OriginConfig:{OriginAccessIdentity:'origin-access-identity/cloudfront/EOAI123'}
      }]},
      DefaultCacheBehavior:{ViewerProtocolPolicy:'redirect-to-https',Compress:true},
      Aliases:{Items:['static.example.com']}
    });
  }

  return {
    vpcs:{Vpcs:vpcs},subnets:{Subnets:subnets},rts:{RouteTables:rts},
    sgs:{SecurityGroups:sgs},nacls:{NetworkAcls:nacls},
    igws:{InternetGateways:igwsList},nats:{NatGateways:natsList},
    ec2:{Reservations:[{Instances:ec2Instances}]},
    albs:{LoadBalancers:albsList},vpces:{VpcEndpoints:vpceList},
    peer:{VpcPeeringConnections:peerings},vpn:{VpnConnections:vpnConns},
    vols:{Volumes:volsList},snaps:{Snapshots:snapsList},
    s3:{Buckets:s3Buckets},r53:{HostedZones:zones},r53records:{ResourceRecordSets:r53records},tgs:{TargetGroups:tgsList},
    enis:{NetworkInterfaces:enisList},waf:{WebACLs:wafAcls},
    rds:{DBInstances:rdsInstances},ecs:{services:ecsServices},
    lambda:{Functions:lambdaFunctions},elasticache:{CacheClusters:ecacheClusters},
    redshift:{Clusters:redshiftClusters},tgwatt:{TransitGatewayAttachments:tgwAttachments},
    cf:{DistributionList:{Items:cfDistributions}}
  };
}
const demo=generateDemo();

let gwNames={};

// Resource list panel - opened by clicking stats bar chips
let _rlCtx=null; // store context for stat chip clicks
let _mapSvg=null,_mapZoom=null,_mapG=null; // global map refs for navigation
let _showNested=false;
let _detailLevel=0; // 0=collapsed(VPC+subnet names), 1=normal(resources), 2=expanded(nested children)
let _dnsRecordsExpanded=false; // DNS zones always show; toggle for individual record rows

// === COMPLIANCE ENGINE ===
let _complianceFindings=[];
function _hasOpenCidr(perm){return(perm.IpRanges||[]).some(r=>r.CidrIp==='0.0.0.0/0')||(perm.Ipv6Ranges||[]).some(r=>r.CidrIpv6==='::/0')}
function _hasPort(perm,port){if(perm.IpProtocol==='-1')return true;const from=perm.FromPort||0,to=perm.ToPort||65535;return from<=port&&to>=port}
function _naclCoversPort(e,port){if(e.Protocol==='-1')return true;const p=parseInt(e.Protocol,10);if(p!==6&&p!==17)return false;const pr=e.PortRange||{};return(pr.From||0)<=port&&(pr.To||65535)>=port}
function runCISChecks(ctx){
  const f=[];
  // CIS 5.2: SG allows SSH from 0.0.0.0/0
  (ctx.sgs||[]).forEach(sg=>{(sg.IpPermissions||[]).forEach(p=>{
    if(_hasPort(p,22)&&_hasOpenCidr(p))f.push({severity:'HIGH',control:'CIS 5.2',framework:'CIS',resource:sg.GroupId,resourceName:sg.GroupName||'',message:'SG allows SSH (22) from 0.0.0.0/0',remediation:'Restrict SSH to specific CIDR ranges or bastion host SG'});
  })});
  // CIS 5.3: SG allows RDP from 0.0.0.0/0
  (ctx.sgs||[]).forEach(sg=>{(sg.IpPermissions||[]).forEach(p=>{
    if(_hasPort(p,3389)&&_hasOpenCidr(p))f.push({severity:'HIGH',control:'CIS 5.3',framework:'CIS',resource:sg.GroupId,resourceName:sg.GroupName||'',message:'SG allows RDP (3389) from 0.0.0.0/0',remediation:'Restrict RDP to specific CIDR ranges or VPN'});
  })});
  // CIS 5.4: Default SG restricts all traffic
  (ctx.sgs||[]).forEach(sg=>{if(sg.GroupName==='default'){
    const hasIngress=(sg.IpPermissions||[]).length>0;const hasEgress=(sg.IpPermissionsEgress||[]).length>0;
    if(hasIngress||hasEgress)f.push({severity:'MEDIUM',control:'CIS 5.4',framework:'CIS',resource:sg.GroupId,resourceName:'default',message:`Default SG in VPC ${sg.VpcId} has ${hasIngress?'ingress':''}${hasIngress&&hasEgress?' and ':''}${hasEgress?'egress':''} rules`,remediation:'Remove all rules from default SGs; use custom SGs instead'});
  }});
  // CIS 5.1: NACLs allow ingress from 0.0.0.0/0 to admin ports
  (ctx.nacls||[]).forEach(nacl=>{(nacl.Entries||[]).forEach(e=>{
    if(!e.Egress&&e.RuleAction==='allow'&&(e.CidrBlock==='0.0.0.0/0'||e.Ipv6CidrBlock==='::/0')){
      if(_naclCoversPort(e,22))f.push({severity:'HIGH',control:'CIS 5.1',framework:'CIS',resource:nacl.NetworkAclId,resourceName:gn(nacl,nacl.NetworkAclId),message:'NACL allows SSH (22) from 0.0.0.0/0',remediation:'Restrict NACL ingress to specific source CIDRs'});
      if(_naclCoversPort(e,3389))f.push({severity:'HIGH',control:'CIS 5.1',framework:'CIS',resource:nacl.NetworkAclId,resourceName:gn(nacl,nacl.NetworkAclId),message:'NACL allows RDP (3389) from 0.0.0.0/0',remediation:'Restrict NACL ingress to specific source CIDRs'});
    }
  })});
  // CIS 5.5: Peering route tables least-access
  (ctx.rts||[]).forEach(rt=>{(rt.Routes||[]).forEach(r=>{
    if(r.VpcPeeringConnectionId&&r.DestinationCidrBlock==='0.0.0.0/0')f.push({severity:'MEDIUM',control:'CIS 5.5',framework:'CIS',resource:rt.RouteTableId,resourceName:gn(rt,rt.RouteTableId),message:'Peering route has overly broad 0.0.0.0/0 destination',remediation:'Use specific CIDR ranges for peering routes'});
  })});
  // NET-1: Private subnets with IGW routes
  const pubSubIds=ctx.pubSubs||new Set();
  (ctx.subnets||[]).forEach(sub=>{
    if(pubSubIds.has&&pubSubIds.has(sub.SubnetId))return;
    const rt=ctx.subRT&&ctx.subRT[sub.SubnetId];if(!rt)return;
    const hasIgw=(rt.Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-')&&r.State==='active');
    if(hasIgw)f.push({severity:'MEDIUM',control:'NET-1',framework:'CIS',resource:sub.SubnetId,resourceName:gn(sub,sub.SubnetId),message:'Private subnet has direct IGW route',remediation:'Remove IGW route from private subnet route table'});
  });
  // NET-2: SG allows all protocols from 0.0.0.0/0
  (ctx.sgs||[]).forEach(sg=>{(sg.IpPermissions||[]).forEach(p=>{
    if(p.IpProtocol==='-1'&&_hasOpenCidr(p))f.push({severity:'CRITICAL',control:'NET-2',framework:'CIS',resource:sg.GroupId,resourceName:sg.GroupName||'',message:'SG allows ALL traffic from 0.0.0.0/0',remediation:'Restrict to specific ports and source CIDRs'});
  })});
  return f;
}
function runWAFChecks(ctx){
  const f=[];
  const acls=ctx.wafAcls||[];
  // WAF-1: Empty WebACL
  acls.forEach(acl=>{if(!(acl.Rules||[]).length)f.push({severity:'HIGH',control:'WAF-1',framework:'WAF',resource:acl.Id||acl.WebACLId||'',resourceName:acl.Name||'',message:'WebACL has zero rules',remediation:'Add rate-limiting and IP-filtering rules to WebACL'})});
  // WAF-2: No rate-limiting rule
  acls.forEach(acl=>{const hasRate=(acl.Rules||[]).some(r=>(r.Statement&&r.Statement.RateBasedStatement)||(r.Type==='RATE_BASED'));
    if(!hasRate&&(acl.Rules||[]).length>0)f.push({severity:'MEDIUM',control:'WAF-2',framework:'WAF',resource:acl.Id||acl.WebACLId||'',resourceName:acl.Name||'',message:'WebACL has no rate-limiting rule',remediation:'Add a rate-based rule to prevent DDoS/brute-force'})});
  // WAF-3: ALB not protected by WAF
  const protectedArns=new Set();acls.forEach(acl=>{(acl.ResourceArns||[]).forEach(a=>protectedArns.add(a))});
  (ctx.albs||[]).forEach(alb=>{if(alb.LoadBalancerArn&&!protectedArns.has(alb.LoadBalancerArn))f.push({severity:'MEDIUM',control:'WAF-3',framework:'WAF',resource:alb.LoadBalancerArn,resourceName:alb.LoadBalancerName||'',message:'ALB not associated with any WebACL',remediation:'Associate this ALB with a WAF WebACL'})});
  // WAF-4: Default action is ALLOW
  acls.forEach(acl=>{const da=acl.DefaultAction||{};if(da.Allow||da.Type==='ALLOW')f.push({severity:'MEDIUM',control:'WAF-4',framework:'WAF',resource:acl.Id||acl.WebACLId||'',resourceName:acl.Name||'',message:'WebACL default action is ALLOW (should be BLOCK)',remediation:'Set default action to BLOCK and add explicit ALLOW rules'})});
  return f;
}
function runComplianceChecks(ctx){
  _complianceFindings=[...runCISChecks(ctx),...runWAFChecks(ctx)];
  // Also run IAM checks if data loaded
  const iamRaw=safeParse(gv('in_iam'));
  if(iamRaw){const iamData=parseIAMData(iamRaw);_complianceFindings=_complianceFindings.concat(runIAMChecks(iamData))}
  return _complianceFindings;
}
function renderCompliancePanel(findings){
  const dp=document.getElementById('detailPanel');const dpTitle=document.getElementById('dpTitle');const dpSub=document.getElementById('dpSub');const dpBody=document.getElementById('dpBody');
  dpTitle.textContent='Compliance Report';
  const sevOrder={CRITICAL:0,HIGH:1,MEDIUM:2,LOW:3};
  const sorted=[...findings].sort((a,b)=>(sevOrder[a.severity]||9)-(sevOrder[b.severity]||9));
  const grouped={};sorted.forEach(f=>{(grouped[f.framework]=grouped[f.framework]||[]).push(f)});
  const crit=findings.filter(f=>f.severity==='CRITICAL').length;const high=findings.filter(f=>f.severity==='HIGH').length;
  const med=findings.filter(f=>f.severity==='MEDIUM').length;const low=findings.filter(f=>f.severity==='LOW').length;
  dpSub.textContent=`${findings.length} findings: ${crit} critical, ${high} high, ${med} medium, ${low} low`;
  let h='<div class="compliance-panel">';
  h+='<div class="compliance-filter"><button class="active" data-fw="all">All</button><button data-fw="CIS">CIS</button><button data-fw="WAF">WAF</button><button data-fw="IAM">IAM</button></div>';
  for(const[fw,items]of Object.entries(grouped)){
    h+=`<div class="compliance-group" data-framework="${fw}"><div class="compliance-group-header">${fw} (${items.length})</div>`;
    items.forEach((f,i)=>{
      h+=`<div class="finding-row" onclick="this.classList.toggle('expanded')"><div class="finding-summary"><span class="sev-badge sev-${f.severity}">${f.severity}</span><span style="color:var(--text-muted);flex-shrink:0">${f.control}</span><span style="flex:1;color:var(--text-secondary)">${f.message}</span></div>`;
      h+=`<div class="finding-detail"><span class="fd-label">Resource:</span> ${f.resourceName||f.resource}<br><span class="fd-label">Remediation:</span> ${f.remediation}</div></div>`;
    });
    h+='</div>';
  }
  h+='<div class="compliance-export-bar"><button onclick="exportPolicies(_complianceFindings,\'config\')">AWS Config</button><button onclick="exportPolicies(_complianceFindings,\'rego\')">OPA Rego</button><button onclick="exportPolicies(_complianceFindings,\'checkov\')">Checkov</button></div>';
  h+='</div>';
  dpBody.innerHTML=h;
  dp.classList.add('open');
  // Filter buttons
  dpBody.querySelectorAll('.compliance-filter button').forEach(btn=>{btn.addEventListener('click',function(){
    dpBody.querySelectorAll('.compliance-filter button').forEach(b=>b.classList.remove('active'));this.classList.add('active');
    const fw=this.dataset.fw;dpBody.querySelectorAll('.compliance-group').forEach(g=>{g.style.display=(fw==='all'||g.dataset.framework===fw)?'':'none'});
  })});
}
function addComplianceChip(sb2,findings){
  const c=document.createElement('div');
  const crit=findings.filter(f=>f.severity==='CRITICAL').length;const high=findings.filter(f=>f.severity==='HIGH').length;
  c.className='compliance-chip '+(crit>0?'critical':high>0?'warn':'clean');
  c.innerHTML=`<b>${findings.length}</b> Compliance`;
  c.addEventListener('click',()=>renderCompliancePanel(findings));
  sb2.appendChild(c);
}

// === DESIGN MODE ===
let _designMode=false;
let _designChanges=[];
let _designBaseline=null;
let _designDebounce=null;
function _snapshotTextareas(){const snap={};document.querySelectorAll('.ji').forEach(el=>{snap[el.id]=el.value});return snap}
function _restoreTextareas(snap){Object.entries(snap).forEach(([id,val])=>{const el=document.getElementById(id);if(el)el.value=val})}
function enterDesignMode(){
  _designMode=true;_designChanges=[];
  _designBaseline=_snapshotTextareas();
  document.getElementById('designToggle').classList.add('active');
  document.getElementById('designToggle').textContent='Exit Design';
  renderChangeLog();
}
function exitDesignMode(){
  _designMode=false;
  if(_designBaseline)_restoreTextareas(_designBaseline);
  _designBaseline=null;_designChanges=[];
  document.getElementById('designToggle').classList.remove('active');
  document.getElementById('designToggle').textContent='Design';
  document.getElementById('changeLog').style.display='none';
  if(_designDebounce)clearTimeout(_designDebounce);
  renderMap();
}
function addDesignChange(change){
  change.id='chg_'+Date.now()+'_'+Math.random().toString(36).substr(2,4);
  change.timestamp=new Date().toISOString();
  _designChanges.push(change);
  renderChangeLog();
  // Debounced live mutation (300ms)
  if(_designDebounce)clearTimeout(_designDebounce);
  _designDebounce=setTimeout(()=>applyDesignChanges(),300);
}
function undoLastChange(){
  if(!_designChanges.length)return;
  _designChanges.pop();
  renderChangeLog();
  if(_designDebounce)clearTimeout(_designDebounce);
  _designDebounce=setTimeout(()=>applyDesignChanges(),300);
}
function applyDesignChanges(){
  if(!_designBaseline)return;
  _restoreTextareas(_designBaseline);
  // Apply each change sequentially
  _designChanges.forEach(ch=>{
    const apply=_designApplyFns[ch.action];
    if(apply)apply(ch);
  });
  // Re-render
  renderMap();
  // Post-render: add design overlay classes (delayed for RAF)
  setTimeout(()=>{
    _designChanges.forEach(ch=>{
      if(ch._addedIds){ch._addedIds.forEach(id=>{
        const el=document.querySelector(`[data-id="${id}"]`);
        if(el)(el.closest('.subnet-group')||el).classList.add('design-added');
      })}
      if(ch._modifiedIds){ch._modifiedIds.forEach(id=>{
        const el=document.querySelector(`[data-id="${id}"]`);
        if(el)(el.closest('.subnet-group')||el).classList.add('design-modified');
      })}
      if(ch._removedIds){ch._removedIds.forEach(id=>{
        const el=document.querySelector(`[data-id="${id}"]`);
        if(el)(el.closest('.subnet-group')||el).classList.add('design-removed');
      })}
    });
  },200);
}

// Design change apply functions: mutate textarea JSON
const _designApplyFns={
  add_subnet(ch){
    const raw=safeParse(gv('in_subnets'));
    const subs=raw?ext(raw,['Subnets']):[];
    subs.push({SubnetId:ch.params.SubnetId||('subnet-design-'+Date.now()),VpcId:ch.params.VpcId,CidrBlock:ch.params.CidrBlock,AvailabilityZone:ch.params.AZ,MapPublicIpOnLaunch:ch.params.isPublic||false,Tags:[{Key:'Name',Value:ch.params.Name||'New Subnet'}]});
    document.getElementById('in_subnets').value=JSON.stringify({Subnets:subs});
    ch._addedIds=[ch.params.SubnetId||'subnet-design'];
  },
  split_subnet(ch){
    const raw=safeParse(gv('in_subnets'));
    const subs=raw?ext(raw,['Subnets']):[];
    const idx=subs.findIndex(s=>s.SubnetId===ch.target.SubnetId);
    if(idx<0)return;
    const orig=subs[idx];
    const halves=splitCIDR(orig.CidrBlock);
    if(!halves)return;
    const sub1={...orig,SubnetId:ch.params.newIds?.[0]||('subnet-split-a-'+Date.now()),CidrBlock:halves[0],Tags:[{Key:'Name',Value:(ch.params.names?.[0])||gn(orig,'')+'_a'}]};
    const sub2={...orig,SubnetId:ch.params.newIds?.[1]||('subnet-split-b-'+Date.now()),CidrBlock:halves[1],Tags:[{Key:'Name',Value:(ch.params.names?.[1])||gn(orig,'')+'_b'}]};
    subs.splice(idx,1,sub1,sub2);
    document.getElementById('in_subnets').value=JSON.stringify({Subnets:subs});
    ch._removedIds=[ch.target.SubnetId];ch._addedIds=[sub1.SubnetId,sub2.SubnetId];
    // Migrate instances by IP
    const instRaw=safeParse(gv('in_ec2'));
    if(instRaw){
      const reservations=ext(instRaw,['Reservations']);
      reservations.forEach(res=>{(res.Instances||[]).forEach(inst=>{
        if(inst.SubnetId===ch.target.SubnetId&&inst.PrivateIpAddress){
          inst.SubnetId=ipInCIDR(inst.PrivateIpAddress,halves[0])?sub1.SubnetId:sub2.SubnetId;
        }
      })});
      document.getElementById('in_ec2').value=JSON.stringify({Reservations:reservations});
    }
  },
  add_gateway(ch){
    const type=ch.params.GatewayType;
    if(type==='IGW'){
      const raw=safeParse(gv('in_igws'));const igws=raw?ext(raw,['InternetGateways']):[];
      const id=ch.params.GatewayId||('igw-design-'+Date.now());
      igws.push({InternetGatewayId:id,Attachments:[{VpcId:ch.params.VpcId,State:'available'}],Tags:[{Key:'Name',Value:ch.params.Name||'New IGW'}]});
      document.getElementById('in_igws').value=JSON.stringify({InternetGateways:igws});
      ch._addedIds=[id];
    } else if(type==='NAT'){
      const raw=safeParse(gv('in_nats'));const nats=raw?ext(raw,['NatGateways']):[];
      const id=ch.params.GatewayId||('nat-design-'+Date.now());
      nats.push({NatGatewayId:id,VpcId:ch.params.VpcId,SubnetId:ch.params.SubnetId,State:'available',Tags:[{Key:'Name',Value:ch.params.Name||'New NAT'}]});
      document.getElementById('in_nats').value=JSON.stringify({NatGateways:nats});
      ch._addedIds=[id];
    } else if(type==='VPCE'){
      const raw=safeParse(gv('in_vpces'));const vpces=raw?ext(raw,['VpcEndpoints']):[];
      const id=ch.params.GatewayId||('vpce-design-'+Date.now());
      vpces.push({VpcEndpointId:id,VpcId:ch.params.VpcId,ServiceName:ch.params.ServiceName||'com.amazonaws.region.s3',VpcEndpointType:ch.params.EndpointType||'Gateway',State:'available',Tags:[{Key:'Name',Value:ch.params.Name||'New VPCE'}]});
      document.getElementById('in_vpces').value=JSON.stringify({VpcEndpoints:vpces});
      ch._addedIds=[id];
    }
  },
  add_route(ch){
    const raw=safeParse(gv('in_rts'));const rts=raw?ext(raw,['RouteTables']):[];
    const rt=rts.find(r=>r.RouteTableId===ch.target.RouteTableId);
    if(!rt)return;
    rt.Routes=rt.Routes||[];
    rt.Routes.push({DestinationCidrBlock:ch.params.DestinationCidrBlock,GatewayId:ch.params.TargetId,State:'active'});
    document.getElementById('in_rts').value=JSON.stringify({RouteTables:rts});
    ch._modifiedIds=[ch.target.RouteTableId];
  },
  add_resource(ch){
    const type=ch.params.ResourceType;
    if(type==='EC2'){
      const raw=safeParse(gv('in_ec2'));
      const reservations=raw?ext(raw,['Reservations']):[];
      const id=ch.params.ResourceId||('i-design-'+Date.now());
      reservations.push({Instances:[{InstanceId:id,SubnetId:ch.params.SubnetId,VpcId:ch.params.VpcId,InstanceType:ch.params.InstanceType||'t3.micro',State:{Name:'running'},PrivateIpAddress:ch.params.PrivateIp||'',Tags:[{Key:'Name',Value:ch.params.Name||'New Instance'}]}]});
      document.getElementById('in_ec2').value=JSON.stringify({Reservations:reservations});
      ch._addedIds=[id];
    } else if(type==='RDS'){
      const raw=safeParse(gv('in_rds'));const rds=raw?ext(raw,['DBInstances']):[];
      const id=ch.params.ResourceId||('db-design-'+Date.now());
      rds.push({DBInstanceIdentifier:id,DBSubnetGroup:{VpcId:ch.params.VpcId,Subnets:[{SubnetIdentifier:ch.params.SubnetId}]},DBInstanceClass:ch.params.InstanceClass||'db.t3.micro',Engine:ch.params.Engine||'mysql',DBInstanceStatus:'available'});
      document.getElementById('in_rds').value=JSON.stringify({DBInstances:rds});
      ch._addedIds=[id];
    } else if(type==='ElastiCache'){
      const raw=safeParse(gv('in_elasticache'));const clusters=raw?ext(raw,['CacheClusters']):[];
      const id=ch.params.ResourceId||('cache-design-'+Date.now());
      clusters.push({CacheClusterId:id,CacheNodeType:ch.params.NodeType||'cache.t3.micro',Engine:ch.params.Engine||'redis',CacheClusterStatus:'available',CacheNodes:[{CacheNodeId:'0001',Endpoint:{Address:id+'.cache.amazonaws.com',Port:6379}}],ConfigurationEndpoint:{Address:id+'.cache.amazonaws.com',Port:6379}});
      document.getElementById('in_elasticache').value=JSON.stringify({CacheClusters:clusters});
      ch._addedIds=[id];
    } else if(type==='Lambda'){
      const raw=safeParse(gv('in_lambda'));const fns=raw?ext(raw,['Functions']):[];
      const id=ch.params.ResourceId||('lambda-design-'+Date.now());
      fns.push({FunctionName:ch.params.Name||'new-function',FunctionArn:'arn:aws:lambda:::function:'+(ch.params.Name||id),VpcConfig:{VpcId:ch.params.VpcId,SubnetIds:[ch.params.SubnetId],SecurityGroupIds:ch.params.SGIds||[]},Runtime:ch.params.Runtime||'nodejs18.x',MemorySize:128});
      document.getElementById('in_lambda').value=JSON.stringify({Functions:fns});
      ch._addedIds=[id];
    } else if(type==='ECS'){
      const raw=safeParse(gv('in_ecs'));const svcs=raw?ext(raw,['services']):[];
      const id=ch.params.ResourceId||('ecs-svc-design-'+Date.now());
      svcs.push({serviceName:ch.params.Name||'new-service',serviceArn:'arn:aws:ecs:::service/'+id,networkConfiguration:{awsvpcConfiguration:{subnets:[ch.params.SubnetId],securityGroups:ch.params.SGIds||[]}},runningCount:ch.params.DesiredCount||1,desiredCount:ch.params.DesiredCount||1,launchType:'FARGATE'});
      document.getElementById('in_ecs').value=JSON.stringify({services:svcs});
      ch._addedIds=[id];
    }
  },
  remove_resource(ch){
    ch._removedIds=[ch.target.ResourceId];
    const type=ch.target.ResourceType;
    if(type==='EC2'){
      const raw=safeParse(gv('in_ec2'));if(!raw)return;
      const reservations=ext(raw,['Reservations']);
      reservations.forEach(res=>{res.Instances=(res.Instances||[]).filter(i=>i.InstanceId!==ch.target.ResourceId)});
      document.getElementById('in_ec2').value=JSON.stringify({Reservations:reservations.filter(r=>(r.Instances||[]).length)});
    } else if(type==='RDS'){
      const raw=safeParse(gv('in_rds'));const rds=raw?ext(raw,['DBInstances']):[];
      document.getElementById('in_rds').value=JSON.stringify({DBInstances:rds.filter(d=>d.DBInstanceIdentifier!==ch.target.ResourceId)});
    } else if(type==='ElastiCache'){
      const raw=safeParse(gv('in_elasticache'));const c=raw?ext(raw,['CacheClusters']):[];
      document.getElementById('in_elasticache').value=JSON.stringify({CacheClusters:c.filter(d=>d.CacheClusterId!==ch.target.ResourceId)});
    } else if(type==='Lambda'){
      const raw=safeParse(gv('in_lambda'));const fns=raw?ext(raw,['Functions']):[];
      document.getElementById('in_lambda').value=JSON.stringify({Functions:fns.filter(f=>f.FunctionName!==ch.target.ResourceId&&f.FunctionArn!==ch.target.ResourceId)});
    } else if(type==='Subnet'){
      const raw=safeParse(gv('in_subnets'));const subs=raw?ext(raw,['Subnets']):[];
      document.getElementById('in_subnets').value=JSON.stringify({Subnets:subs.filter(s=>s.SubnetId!==ch.target.ResourceId)});
    }
  }
};

// Design Mode UI: forms shown in detail panel
function showDesignForm(formType,context){
  const dpBody=document.getElementById('dpBody');
  const dpTitle=document.getElementById('dpTitle');
  const dpSub=document.getElementById('dpSub');
  const dp=document.getElementById('detailPanel');
  let h='';
  if(formType==='add_subnet'){
    dpTitle.textContent='Add Subnet';dpSub.textContent='VPC: '+gn(context.vpc,context.vpc.VpcId);
    const vpcCidr=context.vpc.CidrBlock;
    h='<div class="design-form"><label>CIDR Block</label><input id="df_cidr" placeholder="e.g. 10.0.4.0/24"><div class="form-hint" id="df_hint">Must be within '+vpcCidr+'</div><div class="form-error" id="df_err" style="display:none"></div>';
    h+='<label>Name</label><input id="df_name" placeholder="e.g. app-tier-1a">';
    h+='<label>Availability Zone</label><select id="df_az"><option>us-east-1a</option><option>us-east-1b</option><option>us-east-1c</option></select>';
    h+='<label>Type</label><select id="df_type"><option value="false">Private</option><option value="true">Public</option></select>';
    h+='<div class="form-actions"><button class="btn-confirm" id="df_ok" disabled>Add Subnet</button><button class="btn-cancel" onclick="document.getElementById(\'detailPanel\').classList.remove(\'open\')">Cancel</button></div></div>';
    dpBody.innerHTML=h;dp.classList.add('open');
    const cidrInput=document.getElementById('df_cidr');const errEl=document.getElementById('df_err');const okBtn=document.getElementById('df_ok');
    cidrInput.addEventListener('input',()=>{
      const val=cidrInput.value.trim();const p=parseCIDR(val);
      if(!val){errEl.style.display='none';okBtn.disabled=true;cidrInput.classList.remove('invalid');return}
      if(!p){errEl.textContent='Invalid CIDR notation';errEl.style.display='block';okBtn.disabled=true;cidrInput.classList.add('invalid');return}
      if(!cidrContains(vpcCidr,val)){errEl.textContent='Not within VPC CIDR '+vpcCidr;errEl.style.display='block';okBtn.disabled=true;cidrInput.classList.add('invalid');return}
      // Check overlap with existing subnets
      const existSubs=_rlCtx?(_rlCtx.subnets||[]).filter(s=>s.VpcId===context.vpc.VpcId):[];
      const overlap=existSubs.find(s=>cidrOverlap(val,s.CidrBlock));
      if(overlap){errEl.textContent='Overlaps with '+gn(overlap,overlap.SubnetId)+' ('+overlap.CidrBlock+')';errEl.style.display='block';okBtn.disabled=true;cidrInput.classList.add('invalid');return}
      errEl.style.display='none';okBtn.disabled=false;cidrInput.classList.remove('invalid');
    });
    okBtn.addEventListener('click',()=>{
      addDesignChange({action:'add_subnet',target:{VpcId:context.vpc.VpcId},params:{VpcId:context.vpc.VpcId,SubnetId:'subnet-design-'+Date.now(),CidrBlock:cidrInput.value.trim(),AZ:document.getElementById('df_az').value,isPublic:document.getElementById('df_type').value==='true',Name:document.getElementById('df_name').value||'New Subnet'}});
      dp.classList.remove('open');
    });
  } else if(formType==='split_subnet'){
    dpTitle.textContent='Split Subnet';dpSub.textContent=gn(context.subnet,context.subnet.SubnetId)+' ('+context.subnet.CidrBlock+')';
    const halves=splitCIDR(context.subnet.CidrBlock);
    if(!halves){dpBody.innerHTML='<div class="design-form"><div class="form-error">Cannot split a /32 subnet</div></div>';dp.classList.add('open');return}
    h='<div class="design-form"><label>This will create two subnets:</label>';
    h+='<div class="form-hint" style="margin:6px 0">'+halves[0]+' and '+halves[1]+'</div>';
    h+='<label>Name A</label><input id="df_name_a" value="'+gn(context.subnet,'')+'_a">';
    h+='<label>Name B</label><input id="df_name_b" value="'+gn(context.subnet,'')+'_b">';
    h+='<div class="form-actions"><button class="btn-confirm" id="df_ok">Split</button><button class="btn-cancel" onclick="document.getElementById(\'detailPanel\').classList.remove(\'open\')">Cancel</button></div></div>';
    dpBody.innerHTML=h;dp.classList.add('open');
    document.getElementById('df_ok').addEventListener('click',()=>{
      addDesignChange({action:'split_subnet',target:{SubnetId:context.subnet.SubnetId,CidrBlock:context.subnet.CidrBlock},params:{names:[document.getElementById('df_name_a').value,document.getElementById('df_name_b').value]}});
      dp.classList.remove('open');
    });
  } else if(formType==='add_gateway'){
    dpTitle.textContent='Add Gateway';dpSub.textContent='VPC: '+gn(context.vpc,context.vpc.VpcId);
    h='<div class="design-form"><label>Gateway Type</label><select id="df_gwtype"><option value="IGW">Internet Gateway</option><option value="NAT">NAT Gateway</option><option value="VPCE">VPC Endpoint</option></select>';
    h+='<label>Name</label><input id="df_gwname" placeholder="e.g. prod-nat-1a">';
    h+='<div id="df_gw_extra"></div>';
    h+='<div class="form-actions"><button class="btn-confirm" id="df_ok">Add Gateway</button><button class="btn-cancel" onclick="document.getElementById(\'detailPanel\').classList.remove(\'open\')">Cancel</button></div></div>';
    dpBody.innerHTML=h;dp.classList.add('open');
    const gwType=document.getElementById('df_gwtype');const extra=document.getElementById('df_gw_extra');
    const updateExtra=()=>{
      if(gwType.value==='NAT'){
        const pubSubs=_rlCtx?(_rlCtx.subnets||[]).filter(s=>s.VpcId===context.vpc.VpcId&&_rlCtx.pubSubs.has(s.SubnetId)):[];
        extra.innerHTML='<label>Subnet (public)</label><select id="df_gwsub">'+pubSubs.map(s=>'<option value="'+s.SubnetId+'">'+gn(s,s.SubnetId)+'</option>').join('')+'</select>';
      } else if(gwType.value==='VPCE'){extra.innerHTML='<label>Service</label><input id="df_gwsvc" placeholder="com.amazonaws.region.s3">'} else {extra.innerHTML=''}
    };
    gwType.addEventListener('change',updateExtra);updateExtra();
    document.getElementById('df_ok').addEventListener('click',()=>{
      const params={VpcId:context.vpc.VpcId,GatewayType:gwType.value,Name:document.getElementById('df_gwname').value};
      if(gwType.value==='NAT'){const sel=document.getElementById('df_gwsub');if(sel)params.SubnetId=sel.value}
      if(gwType.value==='VPCE'){const svc=document.getElementById('df_gwsvc');if(svc)params.ServiceName=svc.value}
      addDesignChange({action:'add_gateway',target:{VpcId:context.vpc.VpcId},params});
      dp.classList.remove('open');
    });
  } else if(formType==='add_resource'){
    dpTitle.textContent='Add Resource';dpSub.textContent='Subnet: '+gn(context.subnet,context.subnet.SubnetId);
    h='<div class="design-form"><label>Resource Type</label><select id="df_restype"><option value="EC2">EC2 Instance</option><option value="RDS">RDS</option><option value="ElastiCache">ElastiCache</option><option value="Lambda">Lambda</option><option value="ECS">ECS Service</option></select>';
    h+='<label>Name</label><input id="df_resname" placeholder="e.g. web-server-01">';
    h+='<div class="form-actions"><button class="btn-confirm" id="df_ok">Add Resource</button><button class="btn-cancel" onclick="document.getElementById(\'detailPanel\').classList.remove(\'open\')">Cancel</button></div></div>';
    dpBody.innerHTML=h;dp.classList.add('open');
    document.getElementById('df_ok').addEventListener('click',()=>{
      addDesignChange({action:'add_resource',target:{SubnetId:context.subnet.SubnetId},params:{SubnetId:context.subnet.SubnetId,VpcId:context.subnet.VpcId,ResourceType:document.getElementById('df_restype').value,Name:document.getElementById('df_resname').value}});
      dp.classList.remove('open');
    });
  }
}

// Design toolbar injected into detail panel when in design mode
function injectDesignToolbar(container,context){
  if(!_designMode)return;
  const tb=document.createElement('div');tb.className='design-toolbar';
  if(context.type==='vpc'){
    tb.innerHTML='<button onclick="showDesignForm(\'add_subnet\',{vpc:_dtCtx})">+ Subnet</button><button onclick="showDesignForm(\'add_gateway\',{vpc:_dtCtx})">+ Gateway</button>';
    window._dtCtx=context.data;
  } else if(context.type==='subnet'){
    tb.innerHTML='<button onclick="showDesignForm(\'split_subnet\',{subnet:_dtCtx})">Split</button><button onclick="showDesignForm(\'add_resource\',{subnet:_dtCtx})">+ Resource</button><button onclick="addDesignChange({action:\'remove_resource\',target:{ResourceId:_dtCtx.SubnetId,ResourceType:\'Subnet\'}})">Remove</button>';
    window._dtCtx=context.data;
  }
  container.insertBefore(tb,container.firstChild);
}

// Change log panel
function renderChangeLog(){
  const cl=document.getElementById('changeLog');
  if(!_designChanges.length){cl.style.display='none';return}
  cl.style.display='block';
  let h='<div class="change-log-header"><span>Changes ('+_designChanges.length+')</span><div><button onclick="undoLastChange()">Undo</button> <button onclick="_designChanges=[];renderChangeLog();applyDesignChanges()">Clear All</button></div></div>';
  _designChanges.forEach((ch,i)=>{
    const desc=_changeDesc(ch);
    h+='<div class="change-log-item"><span class="cl-desc">'+desc+'</span><button class="cl-undo" onclick="_designChanges.splice('+i+',1);renderChangeLog();applyDesignChanges()">x</button></div>';
  });
  cl.innerHTML=h;
  // Update badge
  const btn=document.getElementById('designToggle');
  const existing=btn.querySelector('.change-badge');if(existing)existing.remove();
  if(_designChanges.length){const badge=document.createElement('span');badge.className='change-badge';badge.textContent=_designChanges.length;btn.appendChild(badge)}
}
function _changeDesc(ch){
  const a=ch.action.replace(/_/g,' ');
  if(ch.params&&ch.params.Name)return a+': '+ch.params.Name;
  if(ch.params&&ch.params.CidrBlock)return a+': '+ch.params.CidrBlock;
  if(ch.target&&ch.target.SubnetId)return a+': '+ch.target.SubnetId;
  if(ch.target&&ch.target.ResourceId)return a+': '+ch.target.ResourceId;
  return a;
}

// Export design plan as JSON
function exportDesignPlan(planName){
  const plan={version:'1.0',plan_name:planName||'Design Plan',created:new Date().toISOString(),changes:_designChanges.map(ch=>({id:ch.id,action:ch.action,target:ch.target,params:ch.params,timestamp:ch.timestamp})),
    aws_cli:_designChanges.map(ch=>_generateCLI(ch)).filter(Boolean).flat(),
    warnings:_generateWarnings()};
  const blob=new Blob([JSON.stringify(plan,null,2)],{type:'application/json'});
  downloadBlob(blob,(planName||'design-plan')+'.json');
}
function _generateCLI(ch){
  const cmds=[];
  if(ch.action==='add_subnet')cmds.push(`aws ec2 create-subnet --vpc-id ${ch.params.VpcId} --cidr-block ${ch.params.CidrBlock} --availability-zone ${ch.params.AZ}${ch.params.Name?' --tag-specifications \'ResourceType=subnet,Tags=[{Key=Name,Value='+ch.params.Name+'}]\'':''}`);
  if(ch.action==='split_subnet'){cmds.push('# Split subnet requires: delete old, create two new');cmds.push(`aws ec2 delete-subnet --subnet-id ${ch.target.SubnetId}`)}
  if(ch.action==='add_gateway'){
    if(ch.params.GatewayType==='IGW')cmds.push(`aws ec2 create-internet-gateway${ch.params.Name?' --tag-specifications \'ResourceType=internet-gateway,Tags=[{Key=Name,Value='+ch.params.Name+'}]\'':''}`);
    if(ch.params.GatewayType==='NAT')cmds.push(`aws ec2 create-nat-gateway --subnet-id ${ch.params.SubnetId||'SUBNET_ID'} --allocation-id ALLOCATION_ID`);
  }
  if(ch.action==='add_route')cmds.push(`aws ec2 create-route --route-table-id ${ch.target.RouteTableId} --destination-cidr-block ${ch.params.DestinationCidrBlock} --gateway-id ${ch.params.TargetId}`);
  return cmds;
}
function _generateWarnings(){
  const w=[];
  const splits=_designChanges.filter(c=>c.action==='split_subnet');
  if(splits.length)w.push(splits.length+' subnet split(s) require instance migration');
  const removes=_designChanges.filter(c=>c.action==='remove_resource');
  if(removes.length)w.push(removes.length+' resource removal(s)  verify dependencies first');
  return w;
}
function importDesignPlan(json){
  try{
    const plan=typeof json==='string'?JSON.parse(json):json;
    if(!plan.changes||!Array.isArray(plan.changes)){alert('Invalid plan format');return}
    if(!_designMode)enterDesignMode();
    plan.changes.forEach(ch=>addDesignChange(ch));
  }catch(e){alert('Failed to import plan: '+e.message)}
}

// === IAC POLICY EXPORT ===
function generateAWSConfigRules(findings){
  return findings.map(f=>{
    const rule={ConfigRuleName:('custom-'+f.control+'-'+f.resource).toLowerCase().replace(/[^a-z0-9-]/g,'-').substring(0,64),Description:f.message,Source:{Owner:'CUSTOM_LAMBDA',SourceIdentifier:'arn:aws:lambda:REGION:ACCOUNT:function:compliance-check'},InputParameters:JSON.stringify({control:f.control,severity:f.severity,resource:f.resource})};
    if(f.control.startsWith('CIS 5.')||f.control.startsWith('NET-'))rule.Scope={ComplianceResourceTypes:['AWS::EC2::SecurityGroup','AWS::EC2::NetworkAcl']};
    else if(f.control.startsWith('WAF'))rule.Scope={ComplianceResourceTypes:['AWS::WAFv2::WebACL']};
    else if(f.control.startsWith('IAM'))rule.Scope={ComplianceResourceTypes:['AWS::IAM::Role']};
    return rule;
  });
}
function generateOPARego(findings){
  const rules=new Map();
  findings.forEach(f=>{
    const key=f.control;if(rules.has(key))return;
    let rego='';
    if(f.control==='CIS 5.2')rego='deny[msg] {\n  sg := input.resource.aws_security_group[name]\n  rule := sg.ingress[_]\n  rule.from_port <= 22\n  rule.to_port >= 22\n  rule.cidr_blocks[_] == "0.0.0.0/0"\n  msg := sprintf("SG %s allows SSH from 0.0.0.0/0 (CIS 5.2)", [name])\n}';
    else if(f.control==='CIS 5.3')rego='deny[msg] {\n  sg := input.resource.aws_security_group[name]\n  rule := sg.ingress[_]\n  rule.from_port <= 3389\n  rule.to_port >= 3389\n  rule.cidr_blocks[_] == "0.0.0.0/0"\n  msg := sprintf("SG %s allows RDP from 0.0.0.0/0 (CIS 5.3)", [name])\n}';
    else if(f.control==='NET-2')rego='deny[msg] {\n  sg := input.resource.aws_security_group[name]\n  rule := sg.ingress[_]\n  rule.protocol == "-1"\n  rule.cidr_blocks[_] == "0.0.0.0/0"\n  msg := sprintf("SG %s allows ALL traffic from 0.0.0.0/0", [name])\n}';
    else rego='# '+f.control+': '+f.message+'\ndeny[msg] {\n  # TODO: Implement check for '+f.control+'\n  msg := "'+f.control+': '+f.message.replace(/"/g,'\\"')+'"\n}';
    rules.set(key,rego);
  });
  return'package aws_compliance\n\nimport input\n\n'+Array.from(rules.values()).join('\n\n')+'\n';
}
function generateCheckovCheck(findings){
  const checks=new Map();
  findings.forEach(f=>{
    const key=f.control;if(checks.has(key))return;
    checks.set(key,`# ${f.control}: ${f.message}\n# Severity: ${f.severity}\n# Remediation: ${f.remediation}\nfrom checkov.common.models.enums import CheckResult, CheckCategories\nfrom checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n\nclass ${f.control.replace(/[^a-zA-Z0-9]/g,'')}Check(BaseResourceCheck):\n    def __init__(self):\n        name = "${f.message}"\n        id = "CUSTOM_${f.control.replace(/[^a-zA-Z0-9]/g,'_')}"\n        supported_resources = ["aws_security_group"]\n        categories = [CheckCategories.NETWORKING]\n        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n\n    def scan_resource_conf(self, conf):\n        # TODO: Implement check logic\n        return CheckResult.PASSED\n`);
  });
  return Array.from(checks.values()).join('\n\n');
}
function exportPolicies(findings,format){
  let content,filename,mime;
  if(format==='config'){content=JSON.stringify(generateAWSConfigRules(findings),null,2);filename='aws-config-rules.json';mime='application/json'}
  else if(format==='rego'){content=generateOPARego(findings);filename='compliance.rego';mime='text/plain'}
  else if(format==='checkov'){content=generateCheckovCheck(findings);filename='custom_checks.py';mime='text/x-python'}
  else return;
  downloadBlob(new Blob([content],{type:mime}),filename);
}

// === IAM OVERLAY ===
let _iamData=null;
let _showIAM=false;
function parseIAMData(raw){
  if(!raw)return null;
  const data={roles:[],users:[],policies:[]};
  if(raw.RoleDetailList)data.roles=raw.RoleDetailList;
  else if(raw.Roles)data.roles=raw.Roles;
  if(raw.UserDetailList)data.users=raw.UserDetailList;
  if(raw.Policies)data.policies=raw.Policies;
  // Analyze each role for VPC-scoped conditions
  data.roles.forEach(role=>{
    role._vpcAccess=[];role._isAdmin=false;role._hasWildcard=false;
    const policies=[...(role.RolePolicyList||[]),...(role.AttachedManagedPolicies||[])];
    policies.forEach(p=>{
      const doc=p.PolicyDocument||(p.Document?JSON.parse(typeof p.Document==='string'?p.Document:'{}'):{});
      const stmts=doc.Statement||[];
      stmts.forEach(stmt=>{
        if(stmt.Effect!=='Allow')return;
        const actions=Array.isArray(stmt.Action)?stmt.Action:[stmt.Action||''];
        const resources=Array.isArray(stmt.Resource)?stmt.Resource:[stmt.Resource||''];
        if(actions.some(a=>a==='*'||a==='*:*'))role._isAdmin=true;
        if(resources.some(r=>r==='*'))role._hasWildcard=true;
        // Check for VPC conditions
        const cond=stmt.Condition||{};
        Object.values(cond).forEach(cv=>{
          if(cv['aws:SourceVpc'])role._vpcAccess.push(...(Array.isArray(cv['aws:SourceVpc'])?cv['aws:SourceVpc']:[cv['aws:SourceVpc']]));
          if(cv['ec2:Vpc'])role._vpcAccess.push(...(Array.isArray(cv['ec2:Vpc'])?cv['ec2:Vpc']:[cv['ec2:Vpc']]));
        });
        // Check for EC2/VPC actions
        if(actions.some(a=>a.startsWith('ec2:'))||actions.some(a=>a==='ec2:*')){
          resources.forEach(r=>{if(r.includes(':vpc/')||r.includes(':subnet/'))role._vpcAccess.push(r)});
        }
      });
    });
  });
  return data;
}
function getIAMAccessForVpc(iamData,vpcId){
  if(!iamData)return[];
  return iamData.roles.filter(r=>r._isAdmin||r._hasWildcard||r._vpcAccess.some(v=>v===vpcId||v.includes(vpcId)||v==='*'));
}
function runIAMChecks(iamData){
  const f=[];if(!iamData)return f;
  iamData.roles.forEach(role=>{
    if(role._isAdmin)f.push({severity:'CRITICAL',control:'IAM-1',framework:'IAM',resource:role.RoleName||role.Arn||'',resourceName:role.RoleName||'',message:'Role has admin (*:*) permissions',remediation:'Apply least-privilege: scope actions and resources'});
    if(role._hasWildcard&&!role._isAdmin)f.push({severity:'HIGH',control:'IAM-2',framework:'IAM',resource:role.RoleName||role.Arn||'',resourceName:role.RoleName||'',message:'Role has wildcard Resource: "*"',remediation:'Scope Resource ARNs to specific resources'});
    // Check for MFA condition
    const policies=[...(role.RolePolicyList||[]),...(role.AttachedManagedPolicies||[])];
    const hasMFA=policies.some(p=>{const doc=p.PolicyDocument||{};return JSON.stringify(doc).includes('aws:MultiFactorAuth')});
    if(!hasMFA&&role.AssumeRolePolicyDocument){
      const trust=typeof role.AssumeRolePolicyDocument==='string'?JSON.parse(role.AssumeRolePolicyDocument):role.AssumeRolePolicyDocument;
      const stmts=trust.Statement||[];
      const crossAccount=stmts.some(s=>{const p=s.Principal||{};const aws=p.AWS||'';return(Array.isArray(aws)?aws:[aws]).some(a=>a.includes(':root'))});
      if(crossAccount)f.push({severity:'MEDIUM',control:'IAM-3',framework:'IAM',resource:role.RoleName||'',resourceName:role.RoleName||'',message:'Cross-account role without MFA condition',remediation:'Add Condition with aws:MultiFactorAuthPresent'});
    }
  });
  return f;
}
function renderIAMPanel(vpcId){
  if(!_iamData){
    const raw=safeParse(gv('in_iam'));
    if(!raw){alert('No IAM data loaded. Paste IAM auth details in the IAM section first.');return}
    _iamData=parseIAMData(raw);
  }
  const roles=getIAMAccessForVpc(_iamData,vpcId);
  const dp=document.getElementById('detailPanel');const dpTitle=document.getElementById('dpTitle');const dpSub=document.getElementById('dpSub');const dpBody=document.getElementById('dpBody');
  dpTitle.textContent='IAM Access';dpSub.textContent='VPC: '+vpcId;
  let h='<div style="font-family:\'IBM Plex Mono\',monospace;font-size:calc(9px * var(--txt-scale,1) * var(--dp-txt-scale,1))">';
  if(!roles.length){h+='<div style="color:var(--text-muted);padding:12px">No roles with direct VPC access found</div>'}
  else{
    h+='<div style="color:var(--text-muted);margin-bottom:8px">'+roles.length+' role(s) with access:</div>';
    roles.forEach(r=>{
      const badges=[];
      if(r._isAdmin)badges.push('<span class="sev-badge sev-CRITICAL">ADMIN</span>');
      if(r._hasWildcard)badges.push('<span class="sev-badge sev-HIGH">WILDCARD</span>');
      h+='<div style="padding:4px 0;border-bottom:1px solid var(--border)">'+badges.join(' ')+' <span style="color:var(--accent-cyan)">'+r.RoleName+'</span></div>';
    });
  }
  h+='</div>';
  dpBody.innerHTML=h;dp.classList.add('open');
}

function zoomToNode(selector){
  if(!_mapSvg||!_mapZoom||!_mapG)return;
  const el=_mapG.select(selector).node();if(!el)return;
  const b=el.getBBox();if(!b.width)return;
  const W=document.querySelector('.main').clientWidth;
  const H=document.querySelector('.main').clientHeight;
  const s=Math.min(3,.85/Math.max(b.width/W,b.height/H));
  _mapSvg.transition().duration(600).call(_mapZoom.transform,
    d3.zoomIdentity.translate(W/2-s*(b.x+b.width/2),H/2-s*(b.y+b.height/2)).scale(s));
}

function flashNode(selector){
  if(!_mapG)return;
  let el=_mapG.select(selector+' rect');
  if(!el.node()) el=_mapG.select(selector+' circle');
  if(!el.node())return;
  const orig=el.attr('stroke');const origW=el.attr('stroke-width')||1.2;
  el.transition().duration(200).attr('stroke','#fff').attr('stroke-width',3)
    .transition().duration(200).attr('stroke','#facc15').attr('stroke-width',3)
    .transition().duration(200).attr('stroke','#fff').attr('stroke-width',3)
    .transition().duration(400).attr('stroke',orig).attr('stroke-width',origW);
}

function bindZoomButtons(){
  if(!_mapSvg||!_mapZoom||!_mapG) return;
  const svg=_mapSvg,zB=_mapZoom,g=_mapG;
  d3.select('#zoomIn').on('click',()=>svg.transition().duration(300).call(zB.scaleBy,1.4));
  d3.select('#zoomOut').on('click',()=>svg.transition().duration(300).call(zB.scaleBy,.7));
  d3.select('#zoomFit').on('click',()=>{
    const b=g.node().getBBox();if(!b.width)return;
    const W=document.querySelector('.main').clientWidth;
    const H=document.querySelector('.main').clientHeight;
    const s=.92/Math.max(b.width/W,b.height/H);
    svg.transition().duration(500).call(zB.transform,
      d3.zoomIdentity.translate(W/2-s*(b.x+b.width/2),H/2-s*(b.y+b.height/2)).scale(s));
  });
}

function positionTooltip(event,tt){
  const r=document.querySelector('.main').getBoundingClientRect();
  let tx=event.clientX-r.left+16,ty=event.clientY-r.top-10;
  const ttW=tt.offsetWidth||420,ttH=tt.offsetHeight||200;
  if(tx+ttW>r.width) tx=event.clientX-r.left-ttW-10;
  if(ty+ttH>r.height) ty=r.height-ttH-8;
  if(tx<4) tx=4;
  if(ty<4) ty=4;
  tt.style.left=tx+'px';tt.style.top=ty+'px';
}

function copyText(text){
  navigator.clipboard.writeText(text).then(()=>{
    const toast=document.getElementById('copyToast');
    toast.classList.add('show');
    setTimeout(()=>toast.classList.remove('show'),1200);
  }).catch(()=>{});
}

function openResourceList(type, pushNav){
  const ctx=_rlCtx;if(!ctx)return;
  if(pushNav===undefined) pushNav=true;
  if(pushNav) _navStack=[];
  _lastRlType=type;
  const dp=document.getElementById('detailPanel');
  const dpTitle=document.getElementById('dpTitle');
  const dpSub=document.getElementById('dpSub');
  const dpBody=document.getElementById('dpBody');

  function esc(s){return String(s||'').replace(/</g,'&lt;')}
  function vpcName(id){const v=(ctx.vpcs||[]).find(v=>v.VpcId===id);return v?gn(v,id):id||'--'}
  function subName(id){const s=(ctx.subnets||[]).find(s=>s.SubnetId===id);return s?gn(s,id):id||'--'}

  // row builder: action = {t:'vpc'|'sub', id:'...'} or null
  function row(main,details,color,action){
    const act=action?` data-act="${action.t}" data-id="${action.id}"`:'';
    const style=` style="border-left:3px solid ${color||'var(--border)'};padding-left:8px;margin:4px 0${action?';cursor:pointer':''}"`;
    const navBtn=action?'<span class="dp-nav-btn" data-nav="1" data-nav-t="'+action.t+'" data-nav-id="'+action.id+'" title="Navigate to resource on map">Go to</span>':'';
    const tog=details?'<span class="dp-tog">&#9660;</span>':'';
    const det=details?'<span class="dp-det"><br><span class="k">'+details+'</span></span>':'';
    return '<div class="dp-row"'+act+style+'>'
      +tog+'<span class="i" style="color:'+(color||'var(--text-primary)')+'">'+main+'</span>'+navBtn
      +det+'</div>';
  }

  // Find first subnet containing a resource
  function findSubForInst(iid){return (ctx.subnets||[]).find(s=>((ctx.instBySub||{})[s.SubnetId]||[]).some(i=>i.InstanceId===iid))?.SubnetId}
  function findSubForAlb(arn){return (ctx.subnets||[]).find(s=>((ctx.albBySub||{})[s.SubnetId]||[]).some(a=>a.LoadBalancerArn===arn))?.SubnetId}
  function findSubForEni(eid){return (ctx.subnets||[]).find(s=>((ctx.eniBySub||{})[s.SubnetId]||[]).some(e=>e.NetworkInterfaceId===eid))?.SubnetId}
  function findSubForRds(dbid){for(const[sid,dbs]of Object.entries(ctx.rdsBySub||{})){if(dbs.some(d=>d.DBInstanceIdentifier===dbid))return sid}return null}
  function findSubForEcs(name){for(const[sid,svcs]of Object.entries(ctx.ecsBySub||{})){if(svcs.some(s=>s.serviceName===name))return sid}return null}
  function findSubForLambda(fn){for(const[sid,fns]of Object.entries(ctx.lambdaBySub||{})){if(fns.some(f=>f.FunctionName===fn))return sid}return null}

  let title='',sub='',items=[];

  switch(type){
    case 'VPCs':{
      const d=ctx.vpcs||[];title='VPCs';sub=d.length+' total';
      d.forEach(v=>{
        const sc=(ctx.subnets||[]).filter(s=>s.VpcId===v.VpcId).length;
        items.push(row(gn(v,v.VpcId),'ID: '+v.VpcId+' | CIDR: '+(v.CidrBlock||'?')+' | '+sc+' subnets','#7C3AED',{t:'vpc',id:v.VpcId}));
      });break;
    }
    case 'Subnets':case 'Public':case 'Private':{
      let d=ctx.subnets||[];
      if(type==='Public')d=d.filter(s=>ctx.pubSubs.has(s.SubnetId));
      if(type==='Private')d=d.filter(s=>!ctx.pubSubs.has(s.SubnetId));
      title=type+' Subnets';sub=d.length+' total';
      d.forEach(s=>{
        const isPub=ctx.pubSubs.has(s.SubnetId);
        items.push(row(gn(s,s.SubnetId),'CIDR: '+s.CidrBlock+' | AZ: '+(s.AvailabilityZone||'?')+' | VPC: '+vpcName(s.VpcId)+' | '+(isPub?'Public':'Private'),isPub?'#10b981':'#3b82f6',{t:'sub',id:s.SubnetId}));
      });break;
    }
    case 'Gateways':{
      const d=[...(ctx.igws||[]).map(g=>({...g,_type:'IGW',_id:g.InternetGatewayId,_vpc:(g.Attachments||[])[0]?.VpcId})),
        ...(ctx.nats||[]).map(g=>({...g,_type:'NAT',_id:g.NatGatewayId,_vpc:g.VpcId})),
        ...(ctx.vpces||[]).map(g=>({...g,_type:'VPCE',_id:g.VpcEndpointId,_vpc:g.VpcId}))];
      title='Gateways';sub=d.length+' total';
      d.forEach(g=>{
        items.push(row(gn(g,g._id),'Type: '+g._type+' | ID: '+g._id,gch(g._type),g._vpc?{t:'vpc',id:g._vpc}:null));
      });break;
    }
    case 'RTs':{
      const d=ctx.rts||[];title='Route Tables';sub=d.length+' total';
      d.forEach(rt=>{
        const rc=(rt.Routes||[]).length;const ac=(rt.Associations||[]).length;
        items.push(row(gn(rt,rt.RouteTableId),'ID: '+rt.RouteTableId+' | VPC: '+vpcName(rt.VpcId)+' | '+rc+' routes | '+ac+' assoc','#6366f1',{t:'vpc',id:rt.VpcId}));
      });break;
    }
    case 'NACLs':{
      const d=ctx.nacls||[];title='Network ACLs';sub=d.length+' total';
      d.forEach(n=>{
        const rc=(n.Entries||[]).length;
        items.push(row(gn(n,n.NetworkAclId),'ID: '+n.NetworkAclId+' | VPC: '+vpcName(n.VpcId)+' | '+rc+' rules','#8b5cf6',{t:'vpc',id:n.VpcId}));
      });break;
    }
    case 'SGs':{
      const d=ctx.sgs||[];title='Security Groups';sub=d.length+' total';
      d.forEach(sg=>{
        const inR=(sg.IpPermissions||[]).length;const outR=(sg.IpPermissionsEgress||[]).length;
        items.push(row(esc(sg.GroupName||sg.GroupId),'ID: '+sg.GroupId+' | VPC: '+vpcName(sg.VpcId)+' | In: '+inR+' Out: '+outR,'#f59e0b',{t:'vpc',id:sg.VpcId}));
      });break;
    }
    case 'EC2':{
      const d=ctx.instances||[];title='EC2 Instances';sub=d.length+' total';
      d.forEach(i=>{
        const pip=(i.NetworkInterfaces||[]).flatMap(n=>[n.PrivateIpAddress]).filter(Boolean).join(', ');
        const sid=i.SubnetId||findSubForInst(i.InstanceId);
        items.push(row(gn(i,i.InstanceId),'Type: '+i.InstanceType+' | State: '+(i.State?.Name||'?')+' | IP: '+pip+' | Subnet: '+subName(i.SubnetId),'#10b981',sid?{t:'sub',id:sid}:null));
      });break;
    }
    case 'ENIs':{
      const d=ctx.enis||[];title='ENIs';sub=d.length+' total';
      d.forEach(e=>{
        items.push(row(gn(e,e.NetworkInterfaceId),'Type: '+(e.InterfaceType||'?')+' | Status: '+(e.Status||'?')+' | IP: '+(e.PrivateIpAddress||'?')+' | Subnet: '+subName(e.SubnetId),'#3b82f6',e.SubnetId?{t:'sub',id:e.SubnetId}:null));
      });break;
    }
    case 'ALBs':{
      const d=ctx.albs||[];title='Load Balancers';sub=d.length+' total';
      d.forEach(a=>{
        const tgc=((ctx.tgByAlb||{})[a.LoadBalancerArn]||[]).length;
        const wc=((ctx.wafByAlb||{})[a.LoadBalancerArn]||[]).length;
        const cfc=((ctx.cfByAlb||{})[a.LoadBalancerArn]||[]).length;
        let det='Type: '+(a.Type||'?')+' | Scheme: '+(a.Scheme||'?')+' | TGs: '+tgc;
        if(wc)det+=' | WAF: '+wc;
        if(cfc)det+=' | CF: '+cfc;
        det+='<br>DNS: '+(a.DNSName||'?');
        const sid=findSubForAlb(a.LoadBalancerArn);
        items.push(row(esc(a.LoadBalancerName)+'<span class="k" style="margin-left:6px">'+(a.Scheme||'')+'</span>',det,'#38bdf8',sid?{t:'sub',id:sid}:null));
      });break;
    }
    case 'TGs':{
      const d=ctx.tgs||[];title='Target Groups';sub=d.length+' total';
      d.forEach(tg=>{
        const tc=(tg.Targets||[]).length;
        const vid=tg.VpcId;
        items.push(row(esc(tg.TargetGroupName),'Protocol: '+(tg.Protocol||'?')+':'+(tg.Port||'?')+' | Type: '+(tg.TargetType||'?')+' | Targets: '+tc+(tg.HealthCheckPath?' | HC: '+tg.HealthCheckPath:''),'#06b6d4',vid?{t:'vpc',id:vid}:null));
      });break;
    }
    case 'RDS':{
      const d=ctx.rdsInstances||[];title='RDS Instances';sub=d.length+' total';
      d.forEach(db=>{
        let det='Engine: '+db.Engine+' | Class: '+db.DBInstanceClass+' | Status: '+db.DBInstanceStatus;
        if(db.MultiAZ)det+=' | Multi-AZ';
        det+=' | Storage: '+db.AllocatedStorage+'GB';
        if(db.Endpoint)det+='<br>Endpoint: '+db.Endpoint.Address+':'+db.Endpoint.Port;
        const sid=findSubForRds(db.DBInstanceIdentifier);
        items.push(row(esc(db.DBInstanceIdentifier),det,'#3b82f6',sid?{t:'sub',id:sid}:null));
      });break;
    }
    case 'ECS':{
      const d=ctx.ecsServices||[];title='ECS Services';sub=d.length+' total';
      d.forEach(svc=>{
        const cluster=(svc.clusterArn||'').split('/').pop();
        const sid=findSubForEcs(svc.serviceName);
        items.push(row(esc(svc.serviceName),'Cluster: '+cluster+' | Launch: '+(svc.launchType||'?')+' | Tasks: '+svc.runningCount+'/'+svc.desiredCount+(svc.cpu?' | CPU: '+svc.cpu:'')+(svc.memory?' | Mem: '+svc.memory+'MB':''),'#f97316',sid?{t:'sub',id:sid}:null));
      });break;
    }
    case 'Lambda':{
      const d=ctx.lambdaFns||[];title='Lambda Functions (VPC)';sub=d.length+' total';
      d.forEach(fn=>{
        const sid=findSubForLambda(fn.FunctionName);
        items.push(row(esc(fn.FunctionName),'Runtime: '+fn.Runtime+' | Mem: '+fn.MemorySize+'MB | Timeout: '+fn.Timeout+'s | VPC: '+vpcName(fn.VpcConfig?.VpcId),'#a855f7',sid?{t:'sub',id:sid}:{t:'vpc',id:fn.VpcConfig?.VpcId}));
      });break;
    }
    case 'Cache':{
      const d=ctx.ecacheClusters||[];title='ElastiCache Clusters';sub=d.length+' total';
      d.forEach(c=>{
        const ep=(c.CacheNodes||[]).length>0?c.CacheNodes[0].Endpoint?.Address:'--';
        items.push(row(esc(c.CacheClusterId),'Engine: '+c.Engine+' | Type: '+c.CacheNodeType+' | Nodes: '+c.NumCacheNodes+' | VPC: '+vpcName(c.VpcId)+(ep?'<br>Endpoint: '+ep:''),'#ef4444',c.VpcId?{t:'vpc',id:c.VpcId}:null));
      });break;
    }
    case 'Redshift':{
      const d=ctx.redshiftClusters||[];title='Redshift Clusters';sub=d.length+' total';
      d.forEach(c=>{
        items.push(row(esc(c.ClusterIdentifier),'Type: '+c.NodeType+' | Nodes: '+c.NumberOfNodes+' | Status: '+c.ClusterStatus+' | VPC: '+vpcName(c.VpcId)+(c.Endpoint?'<br>Endpoint: '+c.Endpoint.Address+':'+c.Endpoint.Port:''),'#dc2626',c.VpcId?{t:'vpc',id:c.VpcId}:null));
      });break;
    }
    case 'Peering':{
      const d=ctx.peerings||[];title='VPC Peering';sub=d.length+' total';
      d.forEach(p=>{
        const req=p.RequesterVpcInfo||{};const acc=p.AccepterVpcInfo||{};
        items.push(row(gn(p,p.VpcPeeringConnectionId),'Status: '+(p.Status?.Code||'?')+' | Requester: '+vpcName(req.VpcId)+' ('+((req.CidrBlock)||'?')+') | Accepter: '+vpcName(acc.VpcId)+' ('+(acc.CidrBlock||'?')+')','#fb923c',req.VpcId?{t:'vpc',id:req.VpcId}:null));
      });break;
    }
    case 'VPNs':{
      const d=ctx.vpns||[];title='VPN Connections';sub=d.length+' total';
      d.forEach(v=>{
        items.push(row(gn(v,v.VpnConnectionId),'Type: '+(v.Type||'?')+' | State: '+(v.State||'?')+' | VGW: '+(v.VpnGatewayId||'?')+' | CGW: '+(v.CustomerGatewayId||'?'),'#ef4444'));
      });break;
    }
    case 'Endpoints':{
      const d=ctx.vpces||[];title='VPC Endpoints';sub=d.length+' total';
      d.forEach(e=>{
        items.push(row(gn(e,e.VpcEndpointId),'Service: '+(e.ServiceName||'?').split('.').pop()+' | Type: '+(e.VpcEndpointType||'?')+' | VPC: '+vpcName(e.VpcId),'#a78bfa',e.VpcId?{t:'vpc',id:e.VpcId}:null));
      });break;
    }
    case 'Volumes':{
      const d=ctx.volumes||[];title='EBS Volumes';sub=d.length+' total';
      d.forEach(v=>{
        const att=(v.Attachments||[]).map(a=>a.InstanceId).filter(Boolean).join(', ')||'detached';
        items.push(row(gn(v,v.VolumeId),'Size: '+v.Size+'GB | Type: '+(v.VolumeType||'?')+' | State: '+(v.State||'?')+' | AZ: '+(v.AvailabilityZone||'?')+' | Attached: '+att,'#64748b'));
      });break;
    }
    case 'Snapshots':{
      const d=ctx.snapshots||[];title='EBS Snapshots';sub=d.length+' total';
      d.forEach(s=>{
        items.push(row(gn(s,s.SnapshotId),'Volume: '+(s.VolumeId||'?')+' | Size: '+(s.VolumeSize||'?')+'GB | State: '+(s.State||'?')+' | Started: '+((s.StartTime||'').split('T')[0]||'?'),'#94a3b8'));
      });break;
    }
    case 'S3':{
      const d=ctx.s3bk||[];title='S3 Buckets';sub=d.length+' total';
      d.forEach(b=>{
        items.push(row(esc(b.Name),'Created: '+((b.CreationDate||'').split('T')[0]||'?'),'#ea580c'));
      });break;
    }
    case 'R53':{
      const d=ctx.zones||[];const rbz=ctx.recsByZone||{};
      title='Route 53 Hosted Zones';sub=d.length+' total';
      d.forEach(z=>{
        const priv=z.Config?.PrivateZone;
        const zid=(z.Id||'').replace('/hostedzone/','');
        const vpcsStr=(z.VPCs||[]).map(v=>vpcName(v.VPCId||v.VpcId)).join(', ');
        const firstVpc=(z.VPCs||[])[0];const fvid=firstVpc?.VPCId||firstVpc?.VpcId;
        const zColor=priv?'#0ea5e9':'#10b981';
        const zRecs=rbz[zid]||[];
        let det='ID: '+zid+' | '+(priv?'Private':'Public')+' | Records: '+(z.ResourceRecordSetCount||'?');
        if(vpcsStr)det+=' | VPCs: '+vpcsStr;
        if(zRecs.length>0){
          det+='<div style="margin-top:6px;border-top:1px solid rgba(255,255,255,.08);padding-top:6px">';
          zRecs.forEach(rec=>{
            const rName=esc((rec.Name||'').replace(/\.$/,''));
            const rType=rec.Type||'';
            const rVal=rec.AliasTarget?'ALIAS  '+esc((rec.AliasTarget.DNSName||'').replace(/\.$/,'')):
              esc((rec.ResourceRecords||[]).map(rr=>rr.Value).join(', '));
            const ttl=rec.TTL?'TTL: '+rec.TTL:'';
            const tColor=rType==='A'||rType==='AAAA'?'#34d399':rType==='CNAME'?'#60a5fa':rType==='MX'?'#f59e0b':rType==='TXT'?'#a78bfa':rType==='NS'?'#94a3b8':rType==='SOA'?'#64748b':'#e2e8f0';
            det+='<div style="margin:3px 0;padding:3px 0;display:flex;gap:6px;align-items:baseline">';
            det+='<span style="background:'+tColor+';color:#0f172a;font-size:calc(7px * var(--txt-scale) * var(--dp-txt-scale));font-weight:700;padding:1px 4px;border-radius:2px;min-width:36px;text-align:center;flex-shrink:0">'+rType+'</span>';
            det+='<span style="color:var(--text-primary);font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale));min-width:120px">'+rName+'</span>';
            det+='<span style="color:var(--text-muted);font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));word-break:break-all">'+rVal+(ttl?' <span style="color:#475569;font-size:calc(7px * var(--txt-scale) * var(--dp-txt-scale))">['+ttl+']</span>':'')+'</span>';
            det+='</div>';
          });
          det+='</div>';
        }else{
          det+='<div style="margin-top:4px;color:#64748b;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));font-style:italic">No record sets loaded. Paste output of:<br><code style="color:#0ea5e9;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale))">aws route53 list-resource-record-sets --hosted-zone-id '+zid+'</code><br>into the "Record Sets" input field.</div>';
        }
        items.push(row(esc(z.Name),det,zColor,fvid?{t:'vpc',id:fvid}:null));
      });break;
    }
    case 'WAF':{
      const d=ctx.wafAcls||[];title='WAF WebACLs';sub=d.length+' total';
      d.forEach(w=>{
        const rc=(w.Rules||[]).length;const res=(w.ResourceArns||[]).length;
        let det='Rules: '+rc+' | Resources: '+res;
        if(w.Description)det+='<br>'+esc(w.Description);
        if(rc)det+='<br>Rules: '+(w.Rules||[]).map(r=>r.Name).join(', ');
        items.push(row(esc(w.Name),det,'#f59e0b'));
      });break;
    }
    case 'CF':{
      const d=ctx.cfDistributions||[];title='CloudFront Distributions';sub=d.length+' total';
      d.forEach(cf=>{
        const aliases=(cf.Aliases?.Items||[]).join(', ');
        const origins=(cf.Origins?.Items||[]).map(o=>o.DomainName).join(', ');
        let det='ID: '+cf.Id+' | Status: '+(cf.Status||'?');
        if(aliases)det+=' | Aliases: '+aliases;
        det+='<br>Origins: '+origins;
        items.push(row(esc(cf.DomainName||cf.Id),det,'#8b5cf6'));
      });break;
    }
    default: return;
  }

  const backHtml='<span id="dpBack" style="cursor:pointer;color:var(--accent-blue);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));font-family:IBM Plex Mono,monospace;margin-right:8px" title="Back">&lt; Back</span>';
  dpTitle.innerHTML=backHtml+title;
  dpSub.textContent=sub;

  // Build with search filter and expand/collapse toggle
  let h='<div style="margin-bottom:8px;display:flex;gap:6px;align-items:center"><input type="text" id="rlFilter" placeholder="Filter..." style="flex:1;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:IBM Plex Mono,monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));padding:5px 8px;box-sizing:border-box">';
  h+='<span id="rlToggleAll" style="font-family:IBM Plex Mono,monospace;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));color:var(--accent-blue);cursor:pointer;white-space:nowrap;padding:4px 8px;border:1px solid rgba(59,130,246,.3);border-radius:4px;background:rgba(59,130,246,.08)">Collapse All</span></div>';
  h+='<div id="rlItems">'+items.join('')+'</div>';
  dpBody.innerHTML=h;
  dp.classList.add('open');
  // Inject design toolbar for VPC resource list
  if(_designMode&&(type==='VPCs')&&ctx.vpcs&&ctx.vpcs.length){
    const tb=document.createElement('div');tb.className='design-toolbar';
    tb.innerHTML=ctx.vpcs.map(v=>'<button onclick="showDesignForm(\'add_subnet\',{vpc:_rlCtx.vpcs.find(x=>x.VpcId===\''+v.VpcId+'\')})">+ Subnet ('+gn(v,v.VpcId)+')</button><button onclick="showDesignForm(\'add_gateway\',{vpc:_rlCtx.vpcs.find(x=>x.VpcId===\''+v.VpcId+'\')})">+ GW ('+gn(v,v.VpcId)+')</button>').join('');
    dpBody.insertBefore(tb,dpBody.firstChild);
  }
  applyDpScale();

  // back nav from resource list
  const backEl=document.getElementById('dpBack');
  if(backEl){
    backEl.addEventListener('click',()=>{
      const prev=_navStack.pop();
      if(prev&&prev.fn) prev.fn();
      else { dp.classList.remove('open'); }
    });
  }

  // filter logic
  const filterEl=document.getElementById('rlFilter');
  const itemsEl=document.getElementById('rlItems');
  if(filterEl){
    filterEl.focus();
    filterEl.addEventListener('input',function(){
      const q=this.value.toLowerCase();
      const rows=itemsEl.querySelectorAll('.dp-row');
      rows.forEach(r=>{r.style.display=r.textContent.toLowerCase().includes(q)?'':'none'});
    });
  }
  // expand/collapse all toggle
  const toggleAllBtn=document.getElementById('rlToggleAll');
  if(toggleAllBtn&&itemsEl){
    let allCollapsed=false;
    toggleAllBtn.addEventListener('click',function(){
      allCollapsed=!allCollapsed;
      itemsEl.querySelectorAll('.dp-row').forEach(r=>{
        if(allCollapsed)r.classList.add('collapsed');
        else r.classList.remove('collapsed');
      });
      this.textContent=allCollapsed?'Expand All':'Collapse All';
    });
  }
  // click-to-navigate
  if(itemsEl){
    itemsEl.addEventListener('click',function(e){
      // toggle detail expand/collapse
      const tog=e.target.closest('.dp-tog');
      if(tog){
        e.stopPropagation();
        tog.closest('.dp-row').classList.toggle('collapsed');
        return;
      }
      // "Go to" nav button - switch layout and zoom
      const navBtn=e.target.closest('.dp-nav-btn[data-nav]');
      if(navBtn){
        e.stopPropagation();
        const t=navBtn.dataset.navT,nid=navBtn.dataset.navId;
        if(!t||!nid)return;
        const sel=t==='vpc'?'[data-vpc-id="'+nid+'"]':'[data-subnet-id="'+nid+'"]';
        const layoutSel=document.getElementById('layoutMode');
        const curLayout=layoutSel?.value||'grid';
        // switch to grid if on executive
        if(curLayout==='executive'){
          layoutSel.value='grid';
          layoutSel.dispatchEvent(new Event('change'));
          // wait for re-render then zoom
          setTimeout(()=>{
            zoomToNode(sel);
            setTimeout(()=>flashNode(sel),200);
          },400);
        } else {
          zoomToNode(sel);
          setTimeout(()=>flashNode(sel),200);
        }
        return;
      }
      // regular row click
      const r=e.target.closest('.dp-row[data-act]');if(!r)return;
      const act=r.dataset.act,id=r.dataset.id;if(!act||!id)return;
      const sel=act==='vpc'?'[data-vpc-id="'+id+'"]':'[data-subnet-id="'+id+'"]';
      zoomToNode(sel);
      setTimeout(()=>{
        flashNode(sel);
        if(act==='sub'){
          const sub=(ctx.subnets||[]).find(s=>s.SubnetId===id);
          if(sub){
            const vpcId=sub.VpcId;
            openSubnetPanel(sub,vpcId,{pubSubs:ctx.pubSubs,subRT:ctx.subRT,subNacl:ctx.subNacl,instBySub:ctx.instBySub,eniBySub:ctx.eniBySub,albBySub:ctx.albBySub,sgByVpc:ctx.sgByVpc,volByInst:ctx.volByInst,enis:ctx.enis,snapByVol:ctx.snapByVol,tgByAlb:ctx.tgByAlb,wafByAlb:ctx.wafByAlb,rdsBySub:ctx.rdsBySub,ecsBySub:ctx.ecsBySub,lambdaBySub:ctx.lambdaBySub,ecacheByVpc:ctx.ecacheByVpc,redshiftByVpc:ctx.redshiftByVpc,cfByAlb:ctx.cfByAlb});
          }
        }
      },300);
    });
  }
}

let _lastRlType=null;
let _navStack=[]; // navigation stack for detail panel back button

// Shared detail panel builder for both layouts
function routeTgtHtml(tgtId){
  if(!tgtId||tgtId==='local')return '<span class="p">local</span>';
  const nm=gwNames[tgtId];
  const label=nm?(nm+' ('+tgtId+')'):(tgtId);
  const gwType=clsGw(tgtId);
  if(tgtId.startsWith('nat-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="NAT" style="cursor:pointer;color:var(--nat-color)">'+label+'</span>';
  if(tgtId.startsWith('tgw-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="TGW" style="cursor:pointer;color:var(--tgw-color)">'+label+'</span>';
  if(tgtId.startsWith('igw-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="IGW" style="cursor:pointer;color:var(--igw-color)">'+label+'</span>';
  if(tgtId.startsWith('vgw-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="VGW" style="cursor:pointer;color:var(--vgw-color)">'+label+'</span>';
  if(tgtId.startsWith('vpce-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="VPCE" style="cursor:pointer;color:var(--vpce-color)">'+label+'</span>';
  if(tgtId.startsWith('pcx-'))return '<span class="p dp-link" data-gwid="'+tgtId+'" data-gwtype="PCX" style="cursor:pointer;color:var(--pcx-color)">'+label+'</span>';
  return '<span class="p">'+tgtId+'</span>';
}
function openSubnetPanel(sub,vpcId,lk){
  const dp=document.getElementById('detailPanel');
  const dpTitle=document.getElementById('dpTitle');
  const dpSub=document.getElementById('dpSub');
  const dpBody=document.getElementById('dpBody');
  const isPub=lk.pubSubs.has(sub.SubnetId);
  // push current resource list state if coming from one
  if(_lastRlType){
    const savedType=_lastRlType;
    _navStack.push({fn:()=>openResourceList(savedType,false)});
  }
  const backBtn=_navStack.length>0?'<span id="dpBack" style="cursor:pointer;color:var(--accent-blue);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));font-family:IBM Plex Mono,monospace;margin-right:8px" title="Back">&lt; Back</span>':'';
  dpTitle.innerHTML=backBtn+gn(sub,sub.SubnetId)+' <span class="dp-badge '+(isPub?'pub':'prv')+'">'+(isPub?'PUBLIC':'PRIVATE')+'</span>';
  dpSub.innerHTML='<span class="copyable" data-copy="'+sub.SubnetId+'">'+sub.SubnetId+'</span> | '+sub.CidrBlock+' | '+(sub.AvailabilityZone||'N/A');
  let h='';
  function sec(title,count,bodyHtml,startOpen){
    return '<div class="dp-section"><div class="dp-sec-hdr'+(startOpen?'':' collapsed')+'" onclick="this.classList.toggle(\'collapsed\');this.nextElementSibling.classList.toggle(\'hidden\')"><span class="dp-sec-title">'+title+'</span><span><span class="dp-sec-count">'+count+'</span><span class="dp-sec-arr">&#9660;</span></span></div><div class="dp-sec-body'+(startOpen?'':' hidden')+'">'+bodyHtml+'</div></div>';
  }
  const si=lk.instBySub[sub.SubnetId]||[];
  const se=lk.eniBySub[sub.SubnetId]||[];
  const sa=lk.albBySub[sub.SubnetId]||[];
  // Route Table
  const rt=lk.subRT[sub.SubnetId];
  if(rt){
    let rb='<div class="dp-kv"><span class="k">ID</span><span class="v">'+rt.RouteTableId+'</span></div>';
    rb+='<div class="dp-kv"><span class="k">Name</span><span class="v">'+gn(rt,rt.RouteTableId)+'</span></div>';
    (rt.Routes||[]).forEach(r=>{
      const dest=r.DestinationCidrBlock||r.DestinationPrefixListId||'?';
      const tgt=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId||'local';
      rb+='<div class="dp-row">'+dest+' <span class="p">-></span> '+routeTgtHtml(tgt)+'</div>';
    });
    h+=sec('Route Table',(rt.Routes||[]).length+' routes',rb,true);
  }
  // NACLs
  const nc=lk.subNacl[sub.SubnetId];
  if(nc){
    const inbound=(nc.Entries||[]).filter(e=>!e.Egress).sort((a,b)=>a.RuleNumber-b.RuleNumber);
    const outbound=(nc.Entries||[]).filter(e=>e.Egress).sort((a,b)=>a.RuleNumber-b.RuleNumber);
    let nb='<div class="dp-kv"><span class="k">ID</span><span class="v">'+nc.NetworkAclId+'</span></div>';
    nb+='<div style="margin-top:6px"><div class="dp-row"><span class="lbl">INBOUND RULES</span></div>';
    inbound.forEach(e=>{
      const act=e.RuleAction==='allow'?'<span class="a">ALLOW</span>':'<span class="d">DENY</span>';
      const port=e.PortRange?'<span class="p">'+e.PortRange.From+'-'+e.PortRange.To+'</span>':'<span class="p">ALL</span>';
      nb+='<div class="dp-row">#'+e.RuleNumber+' '+act+' '+port+' '+(e.CidrBlock||'')+'</div>';
    });
    nb+='</div><div style="margin-top:6px"><div class="dp-row"><span class="lbl">OUTBOUND RULES</span></div>';
    outbound.forEach(e=>{
      const act=e.RuleAction==='allow'?'<span class="a">ALLOW</span>':'<span class="d">DENY</span>';
      const port=e.PortRange?'<span class="p">'+e.PortRange.From+'-'+e.PortRange.To+'</span>':'<span class="p">ALL</span>';
      nb+='<div class="dp-row">#'+e.RuleNumber+' '+act+' '+port+' '+(e.CidrBlock||'')+'</div>';
    });
    nb+='</div>';
    h+=sec('NACLs',inbound.length+' in / '+outbound.length+' out',nb,true);
  }
  // EC2 Instances
  if(si.length){
    let eb='';
    si.forEach(inst=>{
      const vols=(lk.volByInst||{})[inst.InstanceId]||[];
      const totalGB=vols.reduce((a,v)=>a+v.Size,0);
      const state=inst.State?.Name||'?';
      const stCls=state==='running'?'running':'stopped';
      eb+='<div class="dp-row">';
      eb+='<span class="i">'+gn(inst,inst.InstanceId)+'</span> <span class="dp-badge '+stCls+'">'+state+'</span><br>';
      eb+='<span class="k">ID:</span> '+inst.InstanceId+'<br>';
      eb+='<span class="k">Type:</span> '+inst.InstanceType;
      if(inst.PrivateIpAddress)eb+=' &nbsp;<span class="k">IP:</span> '+inst.PrivateIpAddress;
      if(vols.length){
        eb+='<br><span class="k">Storage:</span> '+totalGB+'GB ('+vols.length+' vol'+(vols.length>1?'s':'')+')';
        vols.forEach(v=>{
          const vSnaps=(lk.snapByVol||{})[v.VolumeId]||[];
          eb+='<br>&nbsp;&nbsp;<span class="s">'+v.VolumeId+'</span> '+v.Size+'GB '+(v.VolumeType||'')+' '+(v.State||'');
          if(vSnaps.length){
            eb+=' <span class="k">['+vSnaps.length+' snap'+(vSnaps.length>1?'s':'')+']</span>';
            const latest=vSnaps.sort((a,b)=>(b.StartTime||'').localeCompare(a.StartTime||''))[0];
            if(latest)eb+='<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">Latest:</span> '+latest.SnapshotId+' '+(latest.StartTime||'').split('T')[0]+' '+(latest.State||'');
          }
        });
      }
      const instEnis=(lk.enis||[]).filter(e=>e.Attachment&&e.Attachment.InstanceId===inst.InstanceId);
      if(instEnis.length){
        eb+='<br><span class="k">ENIs:</span> '+instEnis.length;
        instEnis.forEach(e=>{
          eb+='<br>&nbsp;&nbsp;'+e.NetworkInterfaceId+' '+(e.PrivateIpAddress||'')+' '+(e.InterfaceType||'');
        });
      }
      eb+='</div>';
    });
    h+=sec('EC2 Instances',si.length,eb,true);
  }
  // ENIs
  if(se.length){
    let enb='';
    se.forEach(e=>{
      enb+='<div class="dp-row">';
      enb+='<span class="i">'+e.NetworkInterfaceId+'</span><br>';
      enb+='<span class="k">Type:</span> '+(e.InterfaceType||'N/A')+' &nbsp;<span class="k">Status:</span> '+(e.Status||'?');
      if(e.PrivateIpAddress)enb+='<br><span class="k">Private IP:</span> '+e.PrivateIpAddress;
      if(e.Description)enb+='<br><span class="k">Desc:</span> '+e.Description;
      if(e.Attachment&&e.Attachment.InstanceId)enb+='<br><span class="k">Attached to:</span> <span class="i">'+e.Attachment.InstanceId+'</span>';
      const eSgs=(e.Groups||[]);
      if(eSgs.length)enb+='<br><span class="k">SGs:</span> '+eSgs.map(g=>g.GroupName||g.GroupId).join(', ');
      enb+='</div>';
    });
    h+=sec('ENIs',se.length,enb,false);
  }
  // Load Balancers
  if(sa.length){
    let lb='';
    sa.forEach(a=>{
      lb+='<div class="dp-row">';
      lb+='<span class="i">'+a.LoadBalancerName+'</span><br>';
      lb+='<span class="k">Type:</span> '+a.Type+' &nbsp;<span class="k">Scheme:</span> '+a.Scheme;
      if(a.DNSName)lb+='<br><span class="k">DNS:</span> '+a.DNSName;
      if(a.LoadBalancerArn){
        lb+='<br><span class="k">ARN:</span> <span style="font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale))">'+a.LoadBalancerArn+'</span>';
        const albTgs=(lk.tgByAlb||{})[a.LoadBalancerArn]||[];
        if(albTgs.length){
          lb+='<br><span class="k">Target Groups:</span> '+albTgs.length;
          albTgs.forEach(tg=>{
            lb+='<br>&nbsp;&nbsp;<span class="i">'+(tg.TargetGroupName||tg.TargetGroupArn.split('/')[1]||'')+'</span>';
            lb+=' <span class="k">'+tg.Protocol+':'+tg.Port+'</span> ['+tg.TargetType+']';
            lb+=' HC:'+tg.HealthCheckPath;
            const tCount=(tg.Targets||[]).length;
            if(tCount)lb+=' <span class="p">'+tCount+' target'+(tCount>1?'s':'')+'</span>';
          });
        }
        const albWafs=(lk.wafByAlb||{})[a.LoadBalancerArn]||[];
        if(albWafs.length){
          lb+='<br><span class="k">WAF WebACLs:</span> '+albWafs.length;
          albWafs.forEach(w=>{
            lb+='<br>&nbsp;&nbsp;<span class="i" style="color:#f59e0b">'+w.Name+'</span>';
            if(w.Description)lb+=' <span class="k">'+w.Description+'</span>';
            const rCount=(w.Rules||[]).length;
            if(rCount)lb+='<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">Rules:</span> '+(w.Rules||[]).map(r=>r.Name).join(', ');
          });
        }
        const albCfs=(lk.cfByAlb||{})[a.LoadBalancerArn]||[];
        if(albCfs.length){
          lb+='<br><span class="k">CloudFront:</span> '+albCfs.length+' distribution(s)';
          albCfs.forEach(d=>{
            lb+='<br>&nbsp;&nbsp;<span class="i" style="color:#8b5cf6">'+d.DomainName+'</span>';
            const aliases=(d.Aliases?.Items||[]);
            if(aliases.length)lb+=' ['+aliases.join(', ')+']';
          });
        }
      }
      lb+='</div>';
    });
    h+=sec('Load Balancers',sa.length,lb,false);
  }
  // RDS Instances
  const sr=(lk.rdsBySub||{})[sub.SubnetId]||[];
  if(sr.length){
    let rb='';
    sr.forEach(db=>{
      rb+='<div class="dp-row">';
      rb+='<span class="i" style="color:#3b82f6">'+db.DBInstanceIdentifier+'</span><br>';
      rb+='<span class="k">Engine:</span> '+db.Engine+' &nbsp;<span class="k">Class:</span> '+db.DBInstanceClass;
      rb+='<br><span class="k">Status:</span> '+db.DBInstanceStatus;
      if(db.MultiAZ)rb+=' &nbsp;<span class="p">Multi-AZ</span>';
      if(db.Endpoint)rb+='<br><span class="k">Endpoint:</span> '+db.Endpoint.Address+':'+db.Endpoint.Port;
      rb+='<br><span class="k">Storage:</span> '+db.AllocatedStorage+'GB'+(db.StorageEncrypted?' (encrypted)':'');
      rb+='</div>';
    });
    h+=sec('RDS Instances',sr.length,rb,false);
  }
  // ECS Services
  const secs=(lk.ecsBySub||{})[sub.SubnetId]||[];
  if(secs.length){
    let eb='';
    secs.forEach(svc=>{
      eb+='<div class="dp-row">';
      eb+='<span class="i" style="color:#f97316">'+svc.serviceName+'</span><br>';
      const cluster=(svc.clusterArn||'').split('/').pop();
      eb+='<span class="k">Cluster:</span> '+cluster+' &nbsp;<span class="k">Launch:</span> '+(svc.launchType||'?');
      eb+='<br><span class="k">Tasks:</span> '+svc.runningCount+'/'+svc.desiredCount+' running';
      if(svc.cpu)eb+=' &nbsp;<span class="k">CPU:</span> '+svc.cpu;
      if(svc.memory)eb+=' &nbsp;<span class="k">Mem:</span> '+svc.memory+'MB';
      eb+='</div>';
    });
    h+=sec('ECS Services',secs.length,eb,false);
  }
  // Lambda Functions
  const slm=(lk.lambdaBySub||{})[sub.SubnetId]||[];
  if(slm.length){
    let lmb='';
    slm.forEach(fn=>{
      lmb+='<div class="dp-row">';
      lmb+='<span class="i" style="color:#a855f7">'+fn.FunctionName+'</span><br>';
      lmb+='<span class="k">Runtime:</span> '+fn.Runtime+' &nbsp;<span class="k">Mem:</span> '+fn.MemorySize+'MB &nbsp;<span class="k">Timeout:</span> '+fn.Timeout+'s';
      lmb+='</div>';
    });
    h+=sec('Lambda (VPC)',slm.length,lmb,false);
  }
  // Security Groups
  const vSgs=lk.sgByVpc[vpcId]||[];
  const subSgIds=new Set();
  se.forEach(e=>(e.Groups||[]).forEach(g=>subSgIds.add(g.GroupId)));
  const subSgs=vSgs.filter(sg=>subSgIds.has(sg.GroupId));
  const displaySgs=subSgs.length?subSgs:vSgs;
  if(displaySgs.length){
    let sgb='';
    sgb+='<div class="fw-legend"><span><span class="fw-dot" style="background:var(--accent-green)"></span> Inbound allowed</span><span><span class="fw-dot" style="background:var(--accent-orange)"></span> Port/Range</span><span><span class="fw-dot" style="background:var(--text-muted)"></span> Source</span></div>';
    displaySgs.forEach(sg=>{
      sgb+='<div class="dp-row">';
      sgb+='<span class="i">'+sg.GroupName+'</span> <span class="k">('+sg.GroupId+')</span>';
      if(sg.Description)sgb+='<br><span class="k">'+sg.Description+'</span>';
      const perms=sg.IpPermissions||[];
      if(perms.length){
        sgb+='<div class="fw-visual">';
        perms.forEach(p=>{
          const proto=p.IpProtocol==='-1'?'ALL':p.IpProtocol.toUpperCase();
          const port=p.IpProtocol==='-1'?'ALL':p.FromPort===p.ToPort?(p.FromPort||'ALL'):(p.FromPort||'*')+'-'+(p.ToPort||'*');
          const sources=(p.IpRanges||[]).map(r=>r.CidrIp).concat((p.UserIdGroupPairs||[]).map(g=>g.GroupId));
          sources.forEach(src=>{
            sgb+='<div class="fw-rule-bar"><div class="fw-arrow allow"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div><span class="fw-proto">'+proto+'</span><span class="fw-port allow">'+port+'</span><span class="fw-src">'+src+'</span></div>';
          });
          if(!sources.length){
            sgb+='<div class="fw-rule-bar"><div class="fw-arrow allow"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div><span class="fw-proto">'+proto+'</span><span class="fw-port allow">'+port+'</span><span class="fw-src">any</span></div>';
          }
        });
        sgb+='</div>';
      }
      sgb+='</div>';
    });
    if(subSgs.length&&vSgs.length>subSgs.length){
      sgb+='<div class="dp-row"><span class="k">+ '+(vSgs.length-subSgs.length)+' more SGs in VPC (not attached to this subnet)</span></div>';
    }
    h+=sec('Firewall Rules (Security Groups)',displaySgs.length,sgb,false);
  }
  // NACL visual
  const nc2=lk.subNacl[sub.SubnetId];
  if(nc2){
    const inbound=(nc2.Entries||[]).filter(e=>!e.Egress).sort((a,b)=>a.RuleNumber-b.RuleNumber);
    let nb2='';
    nb2+='<div class="fw-legend"><span><span class="fw-dot" style="background:var(--accent-green)"></span> Allow</span><span><span class="fw-dot" style="background:var(--accent-red)"></span> Deny</span><span><span class="fw-dot" style="background:var(--accent-orange)"></span> Port</span></div>';
    nb2+='<div class="fw-visual">';
    inbound.forEach(e=>{
      const cls=e.RuleAction==='allow'?'allow':'deny';
      const port=e.PortRange?e.PortRange.From+'-'+e.PortRange.To:'ALL';
      const proto=e.Protocol==='-1'?'ALL':e.Protocol;
      nb2+='<div class="fw-rule-bar"><div class="fw-arrow '+cls+'"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div><span class="fw-proto">'+proto+'</span><span class="fw-port '+cls+'">#'+e.RuleNumber+' '+port+'</span><span class="fw-src">'+(e.CidrBlock||'any')+'</span></div>';
    });
    nb2+='</div>';
    h+=sec('NACL Visual (Inbound)',inbound.length+' rules',nb2,false);
  }
  h='<div style="display:flex;gap:6px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid var(--border)"><span id="dpExpandAll" style="font-family:IBM Plex Mono,monospace;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));color:var(--accent-blue);cursor:pointer;padding:3px 8px;border:1px solid rgba(59,130,246,.3);border-radius:4px;background:rgba(59,130,246,.08)">Expand All</span><span id="dpCollapseAll" style="font-family:IBM Plex Mono,monospace;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));color:var(--accent-blue);cursor:pointer;padding:3px 8px;border:1px solid rgba(59,130,246,.3);border-radius:4px;background:rgba(59,130,246,.08)">Collapse All</span></div>'+h;
  dpBody.innerHTML=h;
  dp.classList.add('open');
  injectDesignToolbar(dpBody,{type:'subnet',data:sub});
  applyDpScale();
  document.getElementById('dpExpandAll')?.addEventListener('click',()=>{
    dpBody.querySelectorAll('.dp-sec-hdr.collapsed').forEach(el=>{el.classList.remove('collapsed');el.nextElementSibling.classList.remove('hidden')});
  });
  document.getElementById('dpCollapseAll')?.addEventListener('click',()=>{
    dpBody.querySelectorAll('.dp-sec-hdr:not(.collapsed)').forEach(el=>{el.classList.add('collapsed');el.nextElementSibling.classList.add('hidden')});
  });
  dpBody.querySelectorAll('.dp-link').forEach(el=>{
    el.addEventListener('click',(e)=>{
      e.stopPropagation();
      const gwId=el.dataset.gwid, gwType=el.dataset.gwtype;
      if(!gwId||!_rlCtx) return;
      _navStack.push({fn:()=>{ openSubnetPanel(sub,vpcId,lk); zoomToNode('[data-subnet-id="'+sub.SubnetId+'"]'); }});
      openGatewayPanel(gwId,gwType,{gwNames,igws:_rlCtx.igws,nats:_rlCtx.nats,vpns:_rlCtx.vpns,vpces:_rlCtx.vpces,peerings:_rlCtx.peerings,rts:_rlCtx.rts,subnets:_rlCtx.subnets,subRT:_rlCtx.subRT,pubSubs:_rlCtx.pubSubs,vpcs:_rlCtx.vpcs,tgwAttachments:_rlCtx.tgwAttachments||[]});
      const gwSel='.gw-node[data-gwid="'+gwId+'"]';
      zoomToNode(gwSel);
      if(window._hlGwGlobal) window._hlGwGlobal(gwId);
    });
  });
  const backEl=document.getElementById('dpBack');
  if(backEl){backEl.addEventListener('click',()=>{
    const prev=_navStack.pop();
    if(prev&&prev.fn) prev.fn();
    else { dp.classList.remove('open'); }
  })}
}

// Gateway detail panel - shows info for IGW, TGW, NAT, VGW, PCX, VPCE
function openGatewayPanel(gwId,gwType,lk){
  const dp=document.getElementById('detailPanel');
  const dpTitle=document.getElementById('dpTitle');
  const dpSub=document.getElementById('dpSub');
  const dpBody=document.getElementById('dpBody');
  function esc(s){return String(s||'').replace(/</g,'&lt;')}
  const nm=lk.gwNames[gwId]||gwId;
  const col=gcv(gwType);
  function sec(title,count,bodyHtml,startOpen){
    return '<div class="dp-section"><div class="dp-sec-hdr'+(startOpen?'':' collapsed')+'" onclick="this.classList.toggle(\'collapsed\');this.nextElementSibling.classList.toggle(\'hidden\')"><span class="dp-sec-title">'+title+'</span><span><span class="dp-sec-count">'+count+'</span><span class="dp-sec-arr">&#9660;</span></span></div><div class="dp-sec-body'+(startOpen?'':' hidden')+'">'+bodyHtml+'</div></div>';
  }
  dpTitle.innerHTML='<span id="dpBack" style="cursor:pointer;color:var(--accent-blue);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));font-family:IBM Plex Mono,monospace;margin-right:8px" title="Back">&lt; Back</span><span style="color:'+col+'">'+gwType+'</span>: '+esc(nm);
  dpSub.innerHTML='<span class="copyable" data-copy="'+gwId+'">'+gwId+'</span>';
  let h='';

  // General info
  let gi='<div class="dp-kv"><span class="k">Type</span><span class="v">'+gwType+'</span></div>';
  gi+='<div class="dp-kv"><span class="k">ID</span><span class="v">'+gwId+'</span></div>';
  if(nm&&nm!==gwId) gi+='<div class="dp-kv"><span class="k">Name</span><span class="v">'+esc(nm)+'</span></div>';

  // Type-specific info
  if(gwType==='IGW'){
    const igw=(lk.igws||[]).find(g=>g.InternetGatewayId===gwId);
    if(igw){
      const att=igw.Attachments||[];
      att.forEach(a=>{
        const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===a.VpcId):null;
        gi+='<div class="dp-kv"><span class="k">VPC</span><span class="v">'+(vn?gn(vn,a.VpcId):a.VpcId)+'</span></div>';
        gi+='<div class="dp-kv"><span class="k">State</span><span class="v"><span class="dp-badge pub">'+(a.State||'attached')+'</span></span></div>';
      });
      // Tags
      const tags=(igw.Tags||[]).filter(t=>t.Key!=='Name');
      if(tags.length){
        gi+='<div style="margin-top:6px;border-top:1px solid var(--border);padding-top:6px">';
        tags.forEach(t=>{gi+='<div class="dp-kv"><span class="k">'+esc(t.Key)+'</span><span class="v">'+esc(t.Value)+'</span></div>'});
        gi+='</div>';
      }
    }
  } else if(gwType==='NAT'){
    const nat=(lk.nats||[]).find(n=>n.NatGatewayId===gwId);
    if(nat){
      gi+='<div class="dp-kv"><span class="k">State</span><span class="v"><span class="dp-badge '+(nat.State==='available'?'pub':'prv')+'">'+(nat.State||'N/A')+'</span></span></div>';
      if(nat.SubnetId) gi+='<div class="dp-kv"><span class="k">Subnet</span><span class="v">'+nat.SubnetId+'</span></div>';
      if(nat.VpcId){
        const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===nat.VpcId):null;
        gi+='<div class="dp-kv"><span class="k">VPC</span><span class="v">'+(vn?gn(vn,nat.VpcId):nat.VpcId)+'</span></div>';
      }
      if(nat.ConnectivityType) gi+='<div class="dp-kv"><span class="k">Connectivity</span><span class="v">'+nat.ConnectivityType+'</span></div>';
      const eips=(nat.NatGatewayAddresses||[]);
      eips.forEach((a,i)=>{
        if(a.PublicIp) gi+='<div class="dp-kv"><span class="k">Public IP'+(eips.length>1?' '+(i+1):'')+'</span><span class="v">'+a.PublicIp+'</span></div>';
        if(a.PrivateIp) gi+='<div class="dp-kv"><span class="k">Private IP'+(eips.length>1?' '+(i+1):'')+'</span><span class="v">'+a.PrivateIp+'</span></div>';
        if(a.AllocationId) gi+='<div class="dp-kv"><span class="k">EIP Alloc</span><span class="v">'+a.AllocationId+'</span></div>';
      });
      const tags=(nat.Tags||[]).filter(t=>t.Key!=='Name');
      if(tags.length){
        gi+='<div style="margin-top:6px;border-top:1px solid var(--border);padding-top:6px">';
        tags.forEach(t=>{gi+='<div class="dp-kv"><span class="k">'+esc(t.Key)+'</span><span class="v">'+esc(t.Value)+'</span></div>'});
        gi+='</div>';
      }
    }
  } else if(gwType==='VGW'){
    // Show VPN connections for this VGW
    const gwVpns=(lk.vpns||[]).filter(v=>v.VpnGatewayId===gwId);
    if(gwVpns.length){
      gi+='<div class="dp-kv"><span class="k">VPN Connections</span><span class="v">'+gwVpns.length+'</span></div>';
    }
  } else if(gwType==='VPCE'){
    const vpce=(lk.vpces||[]).find(v=>v.VpcEndpointId===gwId);
    if(vpce){
      if(vpce.VpcEndpointType) gi+='<div class="dp-kv"><span class="k">Endpoint Type</span><span class="v">'+vpce.VpcEndpointType+'</span></div>';
      if(vpce.ServiceName) gi+='<div class="dp-kv"><span class="k">Service</span><span class="v">'+esc(vpce.ServiceName)+'</span></div>';
      if(vpce.State) gi+='<div class="dp-kv"><span class="k">State</span><span class="v"><span class="dp-badge pub">'+vpce.State+'</span></span></div>';
      if(vpce.VpcId){
        const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===vpce.VpcId):null;
        gi+='<div class="dp-kv"><span class="k">VPC</span><span class="v">'+(vn?gn(vn,vpce.VpcId):vpce.VpcId)+'</span></div>';
      }
    }
  } else if(gwType==='PCX'){
    const pcx=(lk.peerings||[]).find(p=>p.VpcPeeringConnectionId===gwId);
    if(pcx){
      if(pcx.Status) gi+='<div class="dp-kv"><span class="k">Status</span><span class="v"><span class="dp-badge pub">'+(pcx.Status.Code||pcx.Status)+'</span></span></div>';
      const req=pcx.RequesterVpcInfo;
      if(req){
        const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===req.VpcId):null;
        gi+='<div class="dp-kv"><span class="k">Requester VPC</span><span class="v">'+(vn?gn(vn,req.VpcId):req.VpcId||'N/A')+'</span></div>';
        if(req.CidrBlock) gi+='<div class="dp-kv"><span class="k">Requester CIDR</span><span class="v">'+req.CidrBlock+'</span></div>';
      }
      const acc=pcx.AccepterVpcInfo;
      if(acc){
        const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===acc.VpcId):null;
        gi+='<div class="dp-kv"><span class="k">Accepter VPC</span><span class="v">'+(vn?gn(vn,acc.VpcId):acc.VpcId||'N/A')+'</span></div>';
        if(acc.CidrBlock) gi+='<div class="dp-kv"><span class="k">Accepter CIDR</span><span class="v">'+acc.CidrBlock+'</span></div>';
      }
    }
  }
  h+=sec('Details','',gi,true);

  // TGW Attachments section (for TGW type)
  if(gwType==='TGW'){
    const atts=(lk.tgwAttachments||[]).filter(a=>a.TransitGatewayId===gwId);
    if(atts.length){
      let ab='';
      atts.forEach(a=>{
        const rid=a.ResourceId||'N/A';
        const vn=(a.ResourceType==='vpc'&&lk.vpcs)?lk.vpcs.find(v=>v.VpcId===rid):null;
        const rName=vn?gn(vn,rid):rid;
        ab+='<div class="dp-row"><span class="p" style="color:var(--accent-cyan)">'+esc(rName)+'</span>';
        ab+=' <span style="color:var(--text-muted);font-size:0.85em">'+a.ResourceType+'</span>';
        ab+=' <span class="dp-badge pub">'+(a.State||'available')+'</span>';
        if(a.Association?.TransitGatewayRouteTableId) ab+='<br><span style="color:var(--text-muted);font-size:0.85em">RT: '+a.Association.TransitGatewayRouteTableId+'</span>';
        ab+='</div>';
      });
      h+=sec('TGW Attachments',atts.length,ab,true);
    }
  }

  // Route tables referencing this gateway
  const refRts=(lk.rts||[]).filter(rt=>(rt.Routes||[]).some(r=>
    r.GatewayId===gwId||r.NatGatewayId===gwId||r.TransitGatewayId===gwId||r.VpcPeeringConnectionId===gwId
  ));
  if(refRts.length){
    let rb='';
    refRts.forEach(rt=>{
      const rtName=gn(rt,rt.RouteTableId);
      rb+='<div style="margin-bottom:8px;padding:6px;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:4px">';
      rb+='<div style="font-weight:bold;color:var(--accent-cyan);margin-bottom:4px">'+esc(rtName)+'</div>';
      rb+='<div style="color:var(--text-muted);font-size:0.85em;margin-bottom:4px">'+rt.RouteTableId+'</div>';
      (rt.Routes||[]).forEach(r=>{
        const dest=r.DestinationCidrBlock||r.DestinationPrefixListId||'?';
        const tgt=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId||'local';
        const isThis=(tgt===gwId);
        if(isThis)rb+='<div class="dp-row">'+dest+' <span class="p">-></span> <span class="p" style="color:var(--accent-cyan);font-weight:bold">'+gwType+' (this)</span></div>';
        else rb+='<div class="dp-row">'+dest+' <span class="p">-></span> '+routeTgtHtml(tgt)+'</div>';
      });
      rb+='</div>';
    });
    h+=sec('Route Tables',refRts.length+' tables',rb,false);
  }

  // VPN connections (for VGW)
  if(gwType==='VGW'){
    const gwVpns=(lk.vpns||[]).filter(v=>v.VpnGatewayId===gwId);
    if(gwVpns.length){
      let vb='';
      gwVpns.forEach(v=>{
        vb+='<div style="margin-bottom:8px;padding:6px;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:4px">';
        vb+='<div style="font-weight:bold;color:var(--accent-red)">'+gn(v,v.VpnConnectionId)+'</div>';
        vb+='<div class="dp-kv"><span class="k">ID</span><span class="v">'+v.VpnConnectionId+'</span></div>';
        vb+='<div class="dp-kv"><span class="k">State</span><span class="v"><span class="dp-badge '+(v.State==='available'?'pub':'prv')+'">'+v.State+'</span></span></div>';
        if(v.CustomerGatewayId) vb+='<div class="dp-kv"><span class="k">Customer GW</span><span class="v">'+v.CustomerGatewayId+'</span></div>';
        if(v.Type) vb+='<div class="dp-kv"><span class="k">Type</span><span class="v">'+v.Type+'</span></div>';
        vb+='</div>';
      });
      h+=sec('VPN Connections',gwVpns.length,vb,true);
    }
  }

  // Connected subnets (subnets whose route tables point to this gateway)
  const connSubs=[];
  (lk.subnets||[]).forEach(s=>{
    const rt=lk.subRT[s.SubnetId];
    if(!rt)return;
    const hasRoute=(rt.Routes||[]).some(r=>r.GatewayId===gwId||r.NatGatewayId===gwId||r.TransitGatewayId===gwId||r.VpcPeeringConnectionId===gwId);
    if(hasRoute) connSubs.push(s);
  });
  if(connSubs.length){
    let sb='';
    connSubs.forEach(s=>{
      const isPub=lk.pubSubs.has(s.SubnetId);
      const vn=lk.vpcs?lk.vpcs.find(v=>v.VpcId===s.VpcId):null;
      sb+='<div class="dp-row">'+gn(s,s.SubnetId)+' <span class="dp-badge '+(isPub?'pub':'prv')+'">'+(isPub?'PUB':'PRV')+'</span>';
      sb+=' <span style="color:var(--text-muted);font-size:0.85em">'+s.CidrBlock+'</span>';
      if(vn) sb+=' <span style="color:var(--text-muted);font-size:0.85em">| '+(gn(vn,vn.VpcId))+'</span>';
      sb+='</div>';
    });
    h+=sec('Connected Subnets',connSubs.length,sb,false);
  }

  h='<div style="display:flex;gap:6px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid var(--border)"><span id="dpExpandAll" style="font-family:IBM Plex Mono,monospace;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));color:var(--accent-blue);cursor:pointer;padding:3px 8px;border:1px solid rgba(59,130,246,.3);border-radius:4px;background:rgba(59,130,246,.08)">Expand All</span><span id="dpCollapseAll" style="font-family:IBM Plex Mono,monospace;font-size:calc(8px * var(--txt-scale) * var(--dp-txt-scale));color:var(--accent-blue);cursor:pointer;padding:3px 8px;border:1px solid rgba(59,130,246,.3);border-radius:4px;background:rgba(59,130,246,.08)">Collapse All</span></div>'+h;
  dpBody.innerHTML=h;
  dp.classList.add('open');
  applyDpScale();
  document.getElementById('dpExpandAll')?.addEventListener('click',()=>{
    dpBody.querySelectorAll('.dp-sec-hdr.collapsed').forEach(el=>{el.classList.remove('collapsed');el.nextElementSibling.classList.remove('hidden')});
  });
  document.getElementById('dpCollapseAll')?.addEventListener('click',()=>{
    dpBody.querySelectorAll('.dp-sec-hdr:not(.collapsed)').forEach(el=>{el.classList.add('collapsed');el.nextElementSibling.classList.add('hidden')});
  });
  dpBody.querySelectorAll('.dp-link').forEach(el=>{
    el.addEventListener('click',(e)=>{
      e.stopPropagation();
      const nGwId=el.dataset.gwid, nGwType=el.dataset.gwtype;
      if(!nGwId||!_rlCtx) return;
      _navStack.push({fn:()=>{ openGatewayPanel(gwId,gwType,lk); const gs='.gw-node[data-gwid="'+gwId+'"]';zoomToNode(gs);if(window._hlGwGlobal)window._hlGwGlobal(gwId); }});
      openGatewayPanel(nGwId,nGwType,{gwNames,igws:_rlCtx.igws,nats:_rlCtx.nats,vpns:_rlCtx.vpns,vpces:_rlCtx.vpces,peerings:_rlCtx.peerings,rts:_rlCtx.rts,subnets:_rlCtx.subnets,subRT:_rlCtx.subRT,pubSubs:_rlCtx.pubSubs,vpcs:_rlCtx.vpcs,tgwAttachments:_rlCtx.tgwAttachments||[]});
      const gwSel='.gw-node[data-gwid="'+nGwId+'"]';
      zoomToNode(gwSel);
      if(window._hlGwGlobal) window._hlGwGlobal(nGwId);
    });
  });
  document.getElementById('dpBack')?.addEventListener('click',(e)=>{
    e.stopPropagation();
    const prev=_navStack.pop();
    if(prev&&prev.fn) prev.fn();
    else dp.classList.remove('open');
  });
}

// Shared resource tree builder - creates hierarchical resource list with children
function resTooltipHtml(res,subId,subRT){
  let h='<div class="tt-title" style="color:'+res.col+'">'+res.type+': '+res.name+'</div>';
  if(res.rid) h+='<div class="tt-sub">'+res.rid+'</div>';
  h+='<div class="tt-sec">';
  if(res.ip) h+='<div class="tt-r">IP: <span class="i">'+res.ip+'</span></div>';
  if(res.state) h+='<div class="tt-r">State: <span class="'+(res.state==='running'?'a':'d')+'">'+res.state+'</span></div>';
  if(res.itype) h+='<div class="tt-r">Type: <span class="i">'+res.itype+'</span></div>';
  if(res.lbType) h+='<div class="tt-r">LB Type: <span class="i">'+res.lbType+'</span></div>';
  if(res.sgIds) h+='<div class="tt-r">SGs: <span class="s">'+res.sgIds+'</span></div>';
  if(res.extra) h+='<div class="tt-r"><span class="i">'+res.extra+'</span></div>';
  h+='</div>';
  if((res.children||[]).length){
    h+='<div class="tt-sec"><div class="tt-sh">Nested ('+res.children.length+')</div>';
    res.children.forEach(ch=>{
      h+='<div class="tt-r"><span style="color:'+ch.col+'">'+ch.type+'</span> '+ch.name+(ch.detail?' <span class="i">'+ch.detail+'</span>':'')+'</div>';
    });
    h+='</div>';
  }
  const rt=subRT?subRT[subId]:null;
  if(rt){
    h+='<div class="tt-sec"><div class="tt-sh">Route Table</div>';
    (rt.Routes||[]).slice(0,6).forEach(r=>{
      const dest=r.DestinationCidrBlock||r.DestinationPrefixListId||'?';
      const tgt=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId||'local';
      h+='<div class="tt-r">'+dest+' <span class="p">-></span> <span class="p">'+tgt+'</span></div>';
    });
    if((rt.Routes||[]).length>6) h+='<div class="tt-r">+'+(rt.Routes.length-6)+' more</div>';
    h+='</div>';
  }
  return h;
}
function buildResTree(subId, ctx){
  const res=[];
  const {instBySub,albBySub,rdsBySub,ecsBySub,lambdaBySub,volByInst,volBySub,enis,tgByAlb,wafByAlb,cfByAlb,snapByVol,eniBySub}=ctx;
  const attachedEnis=new Set();
  // EC2 with ENIs + Volumes
  (instBySub[subId]||[]).forEach(inst=>{
    const ch=[];
    if(_showNested){
      const ie=(enis||[]).filter(e=>e.Attachment&&e.Attachment.InstanceId===inst.InstanceId);
      ie.forEach(e=>{attachedEnis.add(e.NetworkInterfaceId);ch.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),detail:e.PrivateIpAddress||'',col:'#3b82f6',bg:'rgba(59,130,246,.08)'})});
      (volByInst[inst.InstanceId]||[]).forEach(v=>{
        const sc=(snapByVol[v.VolumeId]||[]).length;
        ch.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),detail:sc?sc+' snap':'',col:'#f59e0b',bg:'rgba(245,158,11,.08)'})
      });
    } else {
      // still track attached ENIs even in flat mode
      const ie=(enis||[]).filter(e=>e.Attachment&&e.Attachment.InstanceId===inst.InstanceId);
      ie.forEach(e=>attachedEnis.add(e.NetworkInterfaceId));
    }
    res.push({type:'EC2',name:inst.Tags?.find(t=>t.Key==='Name')?.Value||inst.InstanceId?.slice(-8),state:inst.State?.Name,ip:inst.PrivateIpAddress||'',col:'#10b981',bg:'rgba(16,185,129,.12)',children:ch,
      rid:inst.InstanceId,itype:inst.InstanceType||'',sgIds:(inst.SecurityGroups||[]).map(s=>s.GroupName||s.GroupId).join(', ')});
  });
  // ALB with TGs + WAF + CF
  (albBySub[subId]||[]).forEach(lb=>{
    const ch=[];
    if(_showNested){
      ((tgByAlb||{})[lb.LoadBalancerArn]||[]).forEach(tg=>ch.push({type:'TG',name:tg.TargetGroupName||'TG',detail:(tg.Targets||[]).length+' tgt',col:'#06b6d4',bg:'rgba(6,182,212,.08)'}));
      ((wafByAlb||{})[lb.LoadBalancerArn]||[]).forEach(w=>ch.push({type:'WAF',name:w.Name||'WAF',detail:(w.Rules||[]).length+' rules',col:'#eab308',bg:'rgba(234,179,8,.08)'}));
      (((cfByAlb||{})[lb.LoadBalancerArn])||[]).forEach(cf=>ch.push({type:'CF',name:cf.DomainName||'CF',detail:'',col:'#8b5cf6',bg:'rgba(139,92,246,.08)'}));
    }
    res.push({type:'ALB',name:lb.LoadBalancerName||'ALB',ip:lb.Scheme||'',col:'#38bdf8',bg:'rgba(56,189,248,.12)',children:ch,
      rid:lb.LoadBalancerArn?.split('/').pop()||'',lbType:lb.Type||'application',sgIds:(lb.SecurityGroups||[]).join(', ')});
  });
  // RDS
  (rdsBySub[subId]||[]).forEach(db=>res.push({type:'RDS',name:db.DBInstanceIdentifier||'RDS',ip:db.Engine||'',col:'#3b82f6',bg:'rgba(59,130,246,.12)',children:[],
    rid:db.DBInstanceIdentifier,itype:db.DBInstanceClass||'',extra:db.EngineVersion||''}));
  // ECS
  (ecsBySub[subId]||[]).forEach(svc=>res.push({type:'ECS',name:svc.serviceName||'ECS',ip:svc.launchType||'',col:'#f97316',bg:'rgba(249,115,22,.12)',children:[],
    rid:svc.serviceName,extra:'Tasks: '+(svc.runningCount||0)+'/'+(svc.desiredCount||0)}));
  // Lambda
  (lambdaBySub[subId]||[]).forEach(fn=>res.push({type:'FN',name:fn.FunctionName||'Lambda',ip:fn.Runtime||'',col:'#a855f7',bg:'rgba(168,85,247,.12)',children:[],
    rid:fn.FunctionName,extra:fn.MemorySize?fn.MemorySize+'MB':''}));
  // Unattached ENIs
  (eniBySub[subId]||[]).forEach(e=>{
    if(attachedEnis.has(e.NetworkInterfaceId))return;
    res.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),ip:e.PrivateIpAddress||'',col:'#3b82f6',bg:'rgba(59,130,246,.12)',children:[],
      rid:e.NetworkInterfaceId,extra:e.Description||'',sgIds:(e.Groups||[]).map(g=>g.GroupName||g.GroupId).join(', ')});
  });
  // Standalone EBS volumes (instance not in EC2 data, placed via ENI subnet)
  ((volBySub||{})[subId]||[]).forEach(v=>{
    const sc=((snapByVol||{})[v.VolumeId]||[]).length;
    const att=(v.Attachments||[])[0];
    res.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),ip:att?att.InstanceId?.slice(-8)||'':'detached',
      col:'#f59e0b',bg:'rgba(245,158,11,.12)',children:[],
      rid:v.VolumeId,extra:v.State||''+(sc?'  '+sc+' snap':'')});
  });
  return res;
}

// Compute max children count for any resource in a subnet
function subMaxChildren(subId,ctx){
  const tree=buildResTree(subId,ctx);
  return tree.length?Math.max(0,...tree.map(r=>(r.children||[]).length)):0;
}

// Landing Zone Hub-Spoke D3 Layout
function renderLandingZoneMap(ctx){
  const {vpcs,subnets,rts,sgs,nacls,enis,igws,nats,vpces,instances,albs,tgs,peerings,vpns,volumes,snapshots,s3bk,zones,
    subByVpc,pubSubs,subRT,gwSet,subNacl,sgByVpc,instBySub,eniBySub,albBySub,volByInst,volBySub,pvGws,shGws,vpceByVpc,vpceIds,gwNames,
    snapByVol,tgByAlb,wafAcls,wafByAlb,
    rdsInstances,ecsServices,lambdaFns,ecacheClusters,redshiftClusters,tgwAttachments,cfDistributions,
    rdsBySub,ecsBySub,lambdaBySub,ecacheByVpc,redshiftByVpc,cfByAlb}=ctx;

  // Parse record sets for DNS expanded view
  const lzAllRecSets=ext(safeParse(gv('in_r53records')),['ResourceRecordSets']);
  const lzRecsByZone={};
  lzAllRecSets.forEach(r=>{if(r.HostedZoneId)(lzRecsByZone[r.HostedZoneId]=lzRecsByZone[r.HostedZoneId]||[]).push(r)});

  const svg=d3.select('#mapSvg');
  const W=document.querySelector('.main').clientWidth,H=document.querySelector('.main').clientHeight;
  
  // Layout constants - increased padding for proper containment
  const SH_BASE=46,SG=8,VP=28,VH=40,GR=18,CW=6.2;
  const LZ_RES_ICON=22,LZ_CHILD_H=10,LZ_RES_GAP=3,LZ_RES_COLS=2,LZ_RES_TOP=34,LZ_RES_BOT=10;
  const HUB_X=160,HUB_Y=100;
  const SPOKE_START_X=600,SPOKE_START_Y=60;
  const SPOKE_COL_GAP=200,SPOKE_ROW_GAP=40; // Tighter gaps for flatter layout
  
  // Tree context for buildResTree
  const lzTreeCtx={instBySub,albBySub,rdsBySub,ecsBySub,lambdaBySub,volByInst,volBySub,enis,tgByAlb,wafByAlb,cfByAlb,snapByVol,eniBySub};
  const lzSubTrees={};
  subnets.forEach(s=>{lzSubTrees[s.SubnetId]=buildResTree(s.SubnetId,lzTreeCtx)});
  
  function lzSubH(sid){
    if(_detailLevel===0) return SH_BASE;
    const tree=lzSubTrees[sid]||[];
    if(!tree.length)return SH_BASE;
    const maxCh=Math.max(0,...tree.map(r=>(r.children||[]).length));
    const rowH=LZ_RES_ICON+maxCh*LZ_CHILD_H+5;
    const rows=Math.ceil(tree.length/LZ_RES_COLS);
    return Math.max(SH_BASE, LZ_RES_TOP+rows*rowH+LZ_RES_BOT);
  }
  
  // Identify hub VPC
  const hubKeywords=['shared','connectivity','hub','transit','network','core','central','management'];
  const userHubName=(document.getElementById('hubVpcName')?.value||'').toLowerCase().trim();
  
  let hubVpc=null;
  if(userHubName){
    hubVpc=vpcs.find(v=>gn(v,v.VpcId).toLowerCase().includes(userHubName));
  }
  if(!hubVpc){
    hubVpc=vpcs.find(v=>{
      const vn=gn(v,v.VpcId).toLowerCase();
      return hubKeywords.some(k=>vn.includes(k));
    });
  }
  // Fallback: VPC with most TGW/peering connections
  if(!hubVpc){
    let maxConn=0;
    vpcs.forEach(v=>{
      let conn=0;
      rts.filter(rt=>rt.VpcId===v.VpcId).forEach(rt=>{
        (rt.Routes||[]).forEach(r=>{
          if(r.TransitGatewayId||r.VpcPeeringConnectionId)conn++;
        });
      });
      peerings.forEach(p=>{
        if(p.RequesterVpcInfo?.VpcId===v.VpcId||p.AccepterVpcInfo?.VpcId===v.VpcId)conn++;
      });
      if(conn>maxConn){maxConn=conn;hubVpc=v;}
    });
  }
  if(!hubVpc)hubVpc=vpcs[0];
  
  const spokeVpcs=vpcs.filter(v=>v.VpcId!==hubVpc?.VpcId);
  
  // Calculate VPC dimensions with proper padding
  function calcVpcSize(vpc,maxW){
    const ss=subByVpc[vpc.VpcId]||[];
    let sw=240;
    const vpcNameLen=gn(vpc,vpc.VpcId).length*CW+60;
    sw=Math.max(sw,vpcNameLen);
    ss.forEach(s=>{sw=Math.max(sw,gn(s,s.SubnetId).length*CW+100)});
    sw=Math.min(sw,maxW||350);
    let subnetHeight=0;
    ss.forEach((s,i)=>{subnetHeight+=lzSubH(s.SubnetId)+(i<ss.length-1?SG:0)});
    const totalHeight=VH+VP+subnetHeight+VP+40;
    return {w:sw+VP*2,h:Math.max(totalHeight,140),sw};
  }
  
  // Layout hub VPC (larger, on left)
  const hubSize=calcVpcSize(hubVpc,450);
  const hubSubs=subByVpc[hubVpc.VpcId]||[];
  const hubLayout={
    vpc:hubVpc,x:HUB_X,y:HUB_Y,w:hubSize.w,h:hubSize.h,sw:hubSize.sw,isHub:true,
    subs:(()=>{let cy=HUB_Y+VH+VP;return hubSubs.map((s,i)=>{const sh=lzSubH(s.SubnetId);const r={sub:s,x:HUB_X+VP,y:cy,w:hubSize.sw,h:sh,pub:pubSubs.has(s.SubnetId)};cy+=sh+SG;return r})})()
  };
  
  // Dynamic spoke start X - leave room for hub + TGW area
  const actualSpokeStartX=Math.max(SPOKE_START_X,HUB_X+hubSize.w+180);
  
  // Calculate spoke VPC sizes first
  const spokeSizes=spokeVpcs.map(vpc=>({vpc,...calcVpcSize(vpc,320)}));
  
  // Determine optimal column count - prefer wide/flat layout over tall columns
  const totalSpokeHeight=spokeSizes.reduce((sum,s)=>sum+s.h,0);
  const avgHeight=totalSpokeHeight/spokeSizes.length||200;
  // Target 2-3 VPCs per column max for flatter layout
  const targetColHeight=Math.min(hubLayout.h,avgHeight*2.5);
  
  // Distribute VPCs into columns based on height
  const columns=[];
  let currentCol=[];
  let currentColHeight=0;
  
  spokeSizes.forEach(spoke=>{
    if(currentColHeight>0&&currentColHeight+spoke.h>targetColHeight){
      columns.push(currentCol);
      currentCol=[];
      currentColHeight=0;
    }
    currentCol.push(spoke);
    currentColHeight+=spoke.h+SPOKE_ROW_GAP;
  });
  if(currentCol.length>0)columns.push(currentCol);
  
  // Layout spoke VPCs by column with proper Y spacing
  // First calculate max width per column
  const colMaxWidths=columns.map(col=>Math.max(...col.map(s=>s.w)));
  
  const spokeLayouts=[];
  let colX=actualSpokeStartX;
  columns.forEach((colVpcs,colIdx)=>{
    let y=SPOKE_START_Y;
    const colW=colMaxWidths[colIdx];
    colVpcs.forEach(spoke=>{
      const ss=subByVpc[spoke.vpc.VpcId]||[];
      spokeLayouts.push({
        vpc:spoke.vpc,x:colX,y,w:spoke.w,h:spoke.h,sw:spoke.sw,isHub:false,
        subs:(()=>{let cy2=y+VH+VP;return ss.map((s,j)=>{const sh=lzSubH(s.SubnetId);const r={sub:s,x:colX+VP,y:cy2,w:spoke.sw,h:sh,pub:pubSubs.has(s.SubnetId)};cy2+=sh+SG;return r})})()
      });
      y+=spoke.h+SPOKE_ROW_GAP;
    });
    colX+=colW+SPOKE_COL_GAP;
  });
  
  const vL=[hubLayout,...spokeLayouts];
  
  // Find TGW for hub-spoke connections
  let tgwId=null;
  shGws.forEach(gw=>{if(gw.type==='TGW')tgwId=gw.id});
  
  // Calculate diagram bounds
  const maxX=Math.max(...vL.map(v=>v.x+v.w))+200;
  const maxY=Math.max(...vL.map(v=>v.y+v.h))+100;
  const minSpokeX=spokeLayouts.length?Math.min(...spokeLayouts.map(s=>s.x)):actualSpokeStartX;
  
  // SVG setup
  const g=svg.append('g').attr('class','map-root');
  const zB=d3.zoom().scaleExtent([.08,5]).on('zoom',e=>{g.attr('transform',e.transform);document.getElementById('zoomLevel').textContent=Math.round(e.transform.k*100)+'%'});svg.call(zB);
  _mapSvg=svg;_mapZoom=zB;_mapG=g;
  bindZoomButtons();
  
  const ndL=g.append('g').attr('class','nodes-layer');
  const lnL=g.append('g').attr('class','lines-layer');
  const lzRouteG=lnL.append('g').attr('class','route-group');
  const lzStructG=lnL.append('g').attr('class','route-structural'); // structural lines at full opacity
  const tt=document.getElementById('tooltip');
  
  // Calculate vertical center of all VPCs for TGW positioning
  const allVpcMinY=Math.min(...vL.map(v=>v.y));
  const allVpcMaxY=Math.max(...vL.map(v=>v.y+v.h));
  const diagramCenterY=(allVpcMinY+allVpcMaxY)/2;
  
  // TGW position (centered between hub and first spoke column)
  const tgwX=(hubLayout.x+hubLayout.w+minSpokeX)/2;
  const tgwY=diagramCenterY;
  
  // Internet node position (top left, well above all routing) - defined early for routing calculations
  const iX=HUB_X-180;
  const iY=Math.min(HUB_Y-60, tgwY-80);
  
  // Draw connections from hub to TGW
  const lzAllPaths=[]; // {path, vids:[]} for highlight system
  const lzVpcRoutes=new Map(); // vid -> [{d, stroke}] per-VPC clipped routes
  if(tgwId){
    const connY=hubLayout.y+hubLayout.h/2;
    const path=Math.abs(connY-tgwY)<2
      ?`M${hubLayout.x+hubLayout.w},${connY} L${tgwX-28},${tgwY}`
      :`M${hubLayout.x+hubLayout.w},${connY} L${tgwX-28},${connY} L${tgwX-28},${tgwY}`;
    const p=lzRouteG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',path)
      .attr('stroke','var(--tgw-color)');
    lzAllPaths.push({p,vids:[hubVpc.VpcId],shared:true});
    // hub gets its own route entry
    if(!lzVpcRoutes.has(hubVpc.VpcId))lzVpcRoutes.set(hubVpc.VpcId,[]);
    lzVpcRoutes.get(hubVpc.VpcId).push({d:path,stroke:'var(--tgw-color)'});
  }
  
  // Draw connections from TGW to spokes - route ABOVE all VPCs but below NET routing
  if(spokeLayouts.length&&tgwId){
    const colMap=new Map();
    spokeLayouts.forEach(s=>{
      const colKey=Math.round(s.x/100)*100;
      if(!colMap.has(colKey))colMap.set(colKey,[]);
      colMap.get(colKey).push(s);
    });
    
    const sortedCols=[...colMap.entries()].sort((a,b)=>a[0]-b[0]);
    const firstColX=sortedCols[0]?sortedCols[0][1][0].x:tgwX+100;
    
    // Route Y for TGW: 30px above VPCs (leaving room for NET routing above)
    const allVpcTops=[hubLayout.y,...spokeLayouts.map(s=>s.y)];
    const minVpcTop=Math.min(...allVpcTops);
    const routeY=minVpcTop-30;
    
    // Main trunk from TGW UP to route level
    const allSpokeVids=spokeLayouts.map(s=>s.vpc.VpcId);
    const trunkD=`M${tgwX+28},${tgwY} L${tgwX+28},${routeY}`;
    const p0=lzRouteG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',trunkD)
      .attr('stroke','var(--tgw-color)');
    lzAllPaths.push({p:p0,vids:allSpokeVids,shared:true});
    
    let prevBusX=tgwX+28;
    const horizSegs=[]; // accumulate horizontal segments across columns
    sortedCols.forEach(([colKey,colSpokes],colIdx)=>{
      const colX=Math.min(...colSpokes.map(s=>s.x));
      const localBusX=colX-60; // More clearance from VPC (was 30)
      const sortedSpokes=[...colSpokes].sort((a,b)=>a.y-b.y);
      const colVids=colSpokes.map(s=>s.vpc.VpcId);
      
      // Horizontal segment to column bus
      const horizD=`M${prevBusX},${routeY} L${localBusX},${routeY}`;
      horizSegs.push({d:horizD,stroke:'var(--tgw-color)'});
      const p1=lzRouteG.append('path')
        .attr('class','route-trunk animated')
        .attr('d',horizD)
        .attr('stroke','var(--tgw-color)');
      const laterVids=sortedCols.slice(colIdx).flatMap(([,cs])=>cs.map(s=>s.vpc.VpcId));
      lzAllPaths.push({p:p1,vids:laterVids,shared:true});
      prevBusX=localBusX;
      
      // Vertical segments from route level down through all spokes
      // Calculate all connection Y positions first
      const spokeConnYs=sortedSpokes.map(spoke=>{
        const spokeGws=pvGws[spoke.vpc.VpcId]||[];
        return spoke.y+Math.max(60,spokeGws.length*50+20);
      });
      const maxConnY=Math.max(...spokeConnYs);
      
      // Single vertical from routeY to max connection
      const vertFullD=`M${localBusX},${routeY} L${localBusX},${maxConnY}`;
      const p2=lzRouteG.append('path')
        .attr('class','route-trunk animated')
        .attr('d',vertFullD)
        .attr('stroke','var(--tgw-color)');
      lzAllPaths.push({p:p2,vids:colVids,shared:true});
      
      // Snapshot current horizontal segments for this column
      const horizForThisCol=[...horizSegs];
      
      // Horizontal branches + build per-VPC clipped routes
      sortedSpokes.forEach((spoke,spokeIdx)=>{
        // Connect at VPC center, below any gateways
        const spokeGws=pvGws[spoke.vpc.VpcId]||[];
        const gwCount=spokeGws.length;
        const connY=spoke.y+Math.max(60,gwCount*50+20);
        const branchD=`M${localBusX},${connY} L${spoke.x},${connY}`;
        const p4=lzRouteG.append('path')
          .attr('class','route-trunk animated')
          .attr('d',branchD)
          .attr('stroke','var(--tgw-color)');
        lzAllPaths.push({p:p4,vids:[spoke.vpc.VpcId]});
        
        // Per-VPC clipped route: trunk + all horiz segs to this col + clipped vertical + branch
        const vid=spoke.vpc.VpcId;
        if(!lzVpcRoutes.has(vid))lzVpcRoutes.set(vid,[]);
        const routes=lzVpcRoutes.get(vid);
        const cl='var(--tgw-color)';
        routes.push({d:trunkD,stroke:cl});
        horizForThisCol.forEach(h=>routes.push(h));
        routes.push({d:`M${localBusX},${routeY} L${localBusX},${connY}`,stroke:cl});
        routes.push({d:branchD,stroke:cl});
      });
    });
  }
  
  // Draw TGW node with tooltip
  if(tgwId){
    const tgwG=ndL.append('g').attr('class','lz-tgw-node').style('cursor','pointer');
    tgwG.append('circle').attr('cx',tgwX).attr('cy',tgwY).attr('r',28)
      .attr('fill','rgba(236,72,153,.1)').attr('stroke','var(--tgw-color)').attr('stroke-width',2);
    tgwG.append('text').attr('x',tgwX).attr('y',tgwY-4).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','var(--tgw-color)').text('TGW');
    tgwG.append('text').attr('x',tgwX).attr('y',tgwY+10).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text('Transit');
    
    // TGW tooltip
    const tgwName=gwNames[tgwId]||'Transit Gateway';
    tgwG.on('mouseenter',function(){
      if(_lzLocked) return;
      lzHlResetNodes();
      lzOlL.selectAll('*').remove();
      lzRouteG.style('opacity','0.06');
      g.classed('hl-active',true);
      // show all nodes
      ndL.selectAll('.lz-tgw-node,.lz-gw-node,.internet-node').classed('lz-hl',true);ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');});
      const olStyle={fill:'none','stroke-width':'4px',opacity:'1','stroke-dasharray':'8 5','pointer-events':'none'};
      lzAllPaths.forEach(e=>{try{
        const d=e.p.attr('d'),stroke=e.p.attr('stroke');
        if(d){const p=lzOlL.append('path').attr('d',d).style('stroke',stroke);
        Object.entries(olStyle).forEach(([k,v])=>p.style(k,v));}
      }catch(ex){}});
      let h='<div class="tt-title">'+tgwName+'</div>';
      h+='<div class="tt-sub">Transit Gateway</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Details</div>';
      h+='<div class="tt-r">ID: <span class="i">'+tgwId+'</span></div>';
      h+='<div class="tt-r">Connected VPCs: <span class="i">'+vL.length+'</span></div>';
      h+='</div>';
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){
      positionTooltip(event,tt);
    }).on('mouseleave',()=>{tt.style.display='none';lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      if(_lzLocked&&_lzKey==='tgw'){lzForceClr();return}
      lzForceClr();
      lzOlL.selectAll('*').remove();lzRouteG.style('opacity','0.06');g.classed('hl-active',true);
      ndL.selectAll('.lz-tgw-node,.lz-gw-node,.internet-node').classed('lz-hl',true);ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');});
      const olS={fill:'none','stroke-width':'4px',opacity:'1','stroke-dasharray':'8 5','pointer-events':'none'};
      lzAllPaths.forEach(e=>{try{const d=e.p.attr('d'),s=e.p.attr('stroke');if(d){const p=lzOlL.append('path').attr('d',d).style('stroke',s);Object.entries(olS).forEach(([k,v])=>p.style(k,v))}}catch(ex){}});
      _lzLocked=true;_lzKey='tgw';lzShowLock(true);
      _lastRlType=null;_navStack=[];
      openGatewayPanel(tgwId,'TGW',{gwNames,igws,nats,vpns,vpces,peerings,rts,subnets,subRT,pubSubs,vpcs,tgwAttachments});
    });
  }
  
  // Draw VPC boxes with tooltips
  vL.forEach(vl=>{
    const vG=ndL.append('g').attr('class','vpc-group').attr('data-vpc-id',vl.vpc.VpcId).style('cursor','pointer');
    // Hub gets special styling
    const strokeColor=vl.isHub?'#7C3AED':'var(--vpc-stroke)';
    const strokeWidth=vl.isHub?2.5:1.5;
    const fillColor=vl.isHub?'rgba(124,58,237,.04)':'rgba(59,130,246,.03)';
    
    vG.append('rect').attr('x',vl.x).attr('y',vl.y).attr('width',vl.w).attr('height',vl.h)
      .attr('fill',fillColor).attr('stroke',strokeColor).attr('stroke-width',strokeWidth).attr('rx',vl.isHub?8:0);
    
    // Hub label
    if(vl.isHub){
      vG.append('rect').attr('x',vl.x).attr('y',vl.y-20).attr('width',50).attr('height',18).attr('rx',3)
        .attr('fill','#7C3AED');
      vG.append('text').attr('x',vl.x+25).attr('y',vl.y-7).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','#fff').text('HUB');
    }
    
    // VPC name on first line
    const _lzVpcName=gn(vl.vpc,vl.vpc.VpcId);
    vG.append('text').attr('class','vpc-label').attr('x',vl.x+12).attr('y',vl.y+16)
      .attr('textLength',Math.min(_lzVpcName.length*8,vl.w*0.55)).attr('lengthAdjust','spacing').text(_lzVpcName);
    
    // CIDR and region on second line
    const ss=subByVpc[vl.vpc.VpcId]||[];
    const az=ss.find(s=>s.AvailabilityZone)?.AvailabilityZone||'';
    const region=az.replace(/[a-z]$/,'')||'';
    vG.append('text').attr('class','vpc-cidr').attr('x',vl.x+12).attr('y',vl.y+28)
      .text(vl.vpc.CidrBlock+(region?' '+region:''));
    
    // VPCE badge - positioned at bottom left of VPC
    const vpcVpces=vpceByVpc[vl.vpc.VpcId]||[];
    if(vpcVpces.length){
      const bw=65,bh=16;
      vG.append('rect').attr('x',vl.x+8).attr('y',vl.y+vl.h-bh-6).attr('width',bw).attr('height',bh).attr('rx',3)
        .attr('fill','rgba(167,139,250,.2)').attr('stroke','var(--vpce-color)').attr('stroke-width',.5);
      vG.append('text').attr('x',vl.x+8+bw/2).attr('y',vl.y+vl.h-bh/2-2).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--vpce-color)').text(vpcVpces.length+' VPCE');
    }
    
    // VPC tooltip (on header area only)
    const headerRect=vG.append('rect').attr('x',vl.x).attr('y',vl.y).attr('width',vl.w).attr('height',VH)
      .attr('fill','transparent').style('cursor','pointer');
    headerRect.on('mouseenter',function(){
      if(!_lzLocked) lzHlVpc(vl.vpc.VpcId);
      const vpcGws=pvGws[vl.vpc.VpcId]||[];
      let h='<div class="tt-title">'+gn(vl.vpc,vl.vpc.VpcId)+'</div>';
      h+='<div class="tt-sub">'+(vl.isHub?'Hub VPC':'Spoke VPC')+'</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Details</div>';
      h+='<div class="tt-r">CIDR: <span class="i">'+vl.vpc.CidrBlock+'</span></div>';
      h+='<div class="tt-r">Region: <span class="i">'+(region||'N/A')+'</span></div>';
      h+='<div class="tt-r">ID: <span class="i">'+vl.vpc.VpcId+'</span></div>';
      h+='<div class="tt-r">Subnets: <span class="i">'+ss.length+'</span></div>';
      h+='</div>';
      if(vpcGws.length){
        h+='<div class="tt-sec"><div class="tt-sh">Gateways ('+vpcGws.length+')</div>';
        vpcGws.forEach(gw=>{
          const nm=gwNames[gw.id]||sid(gw.id);
          h+='<div class="tt-r"><span class="i">'+nm+'</span> '+gw.type+'</div>';
        });
        h+='</div>';
      }
      if(vpcVpces.length){
        h+='<div class="tt-sec"><div class="tt-sh">VPC Endpoints ('+vpcVpces.length+')</div>';
        vpcVpces.slice(0,5).forEach(v=>{
          const vi=vpces.find(x=>x.VpcEndpointId===v.id);
          h+='<div class="tt-r"><span class="i">'+(vi?.ServiceName?.split('.').pop()||'?')+'</span></div>';
        });
        if(vpcVpces.length>5)h+='<div class="tt-r">... and '+(vpcVpces.length-5)+' more</div>';
        h+='</div>';
      }
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){
      positionTooltip(event,tt);
    }).on('mouseleave',()=>{tt.style.display='none';lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      const vid=vl.vpc.VpcId;
      if(_lzLocked&&_lzKey===vid){lzForceClr();return}
      lzForceClr();lzHlVpc(vid);_lzLocked=true;_lzKey=vid;lzShowLock(true);
    });
  });
  
  // LZ highlight overlay layer and functions
  const lzOlL=g.append('g').attr('class','lz-overlay');
  let _lzLocked=false, _lzKey=null;
  const lzLockInd=document.getElementById('hlLockInd');
  function lzShowLock(v){lzLockInd.style.display=v?'block':'none'}
  function lzHlResetNodes(){
    ndL.selectAll('.lz-gw-node').classed('lz-hl',false);
    ndL.selectAll('.lz-tgw-node').classed('lz-hl',false);
    ndL.selectAll('.internet-node').classed('lz-hl',false);
    ndL.selectAll('.vpc-group').each(function(){
      d3.select(this).select('rect').style('stroke-width',null).style('filter',null);
    });
  }
  function lzHlVpc(vid){
    lzOlL.selectAll('*').remove();
    lzRouteG.style('opacity','0.06');
    g.classed('hl-active',true);
    lzHlResetNodes();
    // Show TGW (connects all VPCs)
    ndL.selectAll('.lz-tgw-node').classed('lz-hl',true);
    // Glow this VPC box
    ndL.selectAll('.vpc-group[data-vpc-id="'+vid+'"]').each(function(){
      d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');
    });
    // Show this VPC's gateways
    ndL.selectAll('.lz-gw-node[data-vpc="'+vid+'"]').classed('lz-hl',true);
    // Show NET if VPC has IGW or NAT
    const hasInet=ndL.selectAll('.lz-gw-node[data-vpc="'+vid+'"]').nodes()
      .some(n=>{ const t=n.getAttribute('data-gwtype'); return t==='IGW'||t==='NAT'; });
    if(hasInet) ndL.selectAll('.internet-node').classed('lz-hl',true);
    
    const olStyle={fill:'none','stroke-width':'4px',opacity:'1','stroke-dasharray':'8 5','pointer-events':'none'};
    const vpcRoutes=lzVpcRoutes.get(vid);
    if(vpcRoutes&&vpcRoutes.length){
      vpcRoutes.forEach(r=>{
        const p=lzOlL.append('path').attr('d',r.d).style('stroke',r.stroke);
        Object.entries(olStyle).forEach(([k,v])=>p.style(k,v));
      });
    } else {
      lzAllPaths.forEach(e=>{
        if(e.vids.includes(vid)){
          const d=e.p.attr('d'), stroke=e.p.attr('stroke');
          const p=lzOlL.append('path').attr('d',d).style('stroke',stroke);
          Object.entries(olStyle).forEach(([k,v])=>p.style(k,v));
        }
      });
    }
  }
  function lzClr(){
    if(_lzLocked) return;
    lzOlL.selectAll('*').remove();
    lzRouteG.style('opacity',null);
    g.classed('hl-active',false);
    lzHlResetNodes();
  }
  function lzForceClr(){
    _lzLocked=false;_lzKey=null;lzShowLock(false);
    lzOlL.selectAll('*').remove();
    lzRouteG.style('opacity',null);
    g.classed('hl-active',false);
    lzHlResetNodes();
  }
  document.addEventListener('hl-unlock',lzForceClr);
  svg.on('click',function(event){
    if(!event.target.closest('.lz-gw-node')&&!event.target.closest('.lz-tgw-node')&&!event.target.closest('.subnet-node')&&!event.target.closest('.internet-node')&&!event.target.closest('.route-hitarea')){
      lzForceClr();
    }
  });
  
  // Add clickable hitareas on all LZ route paths
  const lzHitL=g.insert('g','.lz-overlay').attr('class','lz-hitareas');
  lzAllPaths.forEach(e=>{
    const d=e.p.attr('d');
    if(!d) return;
    // Determine target: single VPC -> that VPC, shared -> 'tgw', gwId -> owning VPC
    const tgtVid=e.vids.length===1?e.vids[0]:null;
    const hitKey=tgtVid||'tgw';
    
    const ha=lzHitL.append('path').attr('class','route-hitarea').attr('d',d);
    ha.on('mouseenter',function(){
      if(_lzLocked) return;
      if(hitKey==='tgw'){
        lzHlResetNodes();
        lzOlL.selectAll('*').remove();
        lzRouteG.style('opacity','0.06');
        g.classed('hl-active',true);
        ndL.selectAll('.lz-tgw-node,.lz-gw-node,.internet-node').classed('lz-hl',true);ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');});
        const olS={fill:'none','stroke-width':'4px',opacity:'1','stroke-dasharray':'8 5','pointer-events':'none'};
        lzAllPaths.forEach(x=>{
          const pd=x.p.attr('d'),ps=x.p.attr('stroke');
          const pp=lzOlL.append('path').attr('d',pd).style('stroke',ps);
          Object.entries(olS).forEach(([k,v])=>pp.style(k,v));
        });
      } else {
        lzHlVpc(hitKey);
      }
    }).on('mouseleave',()=>{lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      if(_lzLocked&&_lzKey===hitKey){lzForceClr();return}
      lzForceClr();
      if(hitKey==='tgw'){
        lzOlL.selectAll('*').remove();lzRouteG.style('opacity','0.06');g.classed('hl-active',true);
        ndL.selectAll('.lz-tgw-node,.lz-gw-node,.internet-node').classed('lz-hl',true);ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');});
        const olS={fill:'none','stroke-width':'4px',opacity:'1','stroke-dasharray':'8 5','pointer-events':'none'};
        lzAllPaths.forEach(x=>{const pd=x.p.attr('d'),ps=x.p.attr('stroke');const pp=lzOlL.append('path').attr('d',pd).style('stroke',ps);Object.entries(olS).forEach(([k,v])=>pp.style(k,v))});
      } else {
        lzHlVpc(hitKey);
      }
      _lzLocked=true;_lzKey=hitKey;lzShowLock(true);
    });
  });
  // build subRT lookup for LZ tooltips (with Main route table fallback)
  const lzMainRT={};
  rts.forEach(rt=>{if((rt.Associations||[]).some(a=>a.Main))lzMainRT[rt.VpcId]=rt});
  const lzSubRT={};
  rts.forEach(rt=>{(rt.Associations||[]).forEach(as=>{if(as.SubnetId)lzSubRT[as.SubnetId]=rt})});
  subnets.forEach(s=>{if(!lzSubRT[s.SubnetId]&&lzMainRT[s.VpcId])lzSubRT[s.SubnetId]=lzMainRT[s.VpcId]});

  // Draw subnets with tooltips
  vL.forEach(vl=>{vl.subs.forEach(sl=>{
    const sG=ndL.append('g').attr('class','subnet-node').attr('data-subnet-id',sl.sub.SubnetId).style('cursor','pointer');
    const col=sl.pub?'var(--subnet-public)':'var(--subnet-private)';
    sG.append('rect').attr('x',sl.x).attr('y',sl.y).attr('width',sl.w).attr('height',sl.h)
      .attr('fill',sl.pub?'rgba(6,182,212,.15)':'rgba(139,92,246,.15)').attr('stroke',col).attr('stroke-width',1.2);
    sG.append('text').attr('class','subnet-label').attr('x',sl.x+8).attr('y',sl.y+16).text(gn(sl.sub,sl.sub.SubnetId));
    sG.append('text').attr('class','subnet-cidr').attr('x',sl.x+8).attr('y',sl.y+28).text(sl.sub.CidrBlock+(sl.sub.AvailabilityZone?' '+sl.sub.AvailabilityZone.slice(-2):''));
    sG.append('text').attr('x',sl.x+sl.w-6).attr('y',sl.y+12).attr('text-anchor','end')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',col).text(sl.pub?'PUB':'PRV');
    
    // Resource icons inside subnet (tree-based with nesting)
    const lzTree=lzSubTrees[sl.sub.SubnetId]||[];
    
    if(_detailLevel===0&&lzTree.length>0){
      const counts={};
      lzTree.forEach(r=>{counts[r.type]=(counts[r.type]||0)+1});
      const summary=Object.entries(counts).map(([t,c])=>c+' '+t).join(', ');
      sG.append('text').attr('x',sl.x+6).attr('y',sl.y+sl.h-5)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(5px * var(--txt-scale,1))').attr('fill','var(--text-muted)').attr('opacity',.5).text(summary);
    } else if(lzTree.length>0){
      const iconW=Math.max(60,Math.floor((sl.w-12)/LZ_RES_COLS)-LZ_RES_GAP);
      const maxCh=Math.max(0,...lzTree.map(r=>(r.children||[]).length));
      const rowH=LZ_RES_ICON+maxCh*LZ_CHILD_H+5;
      let rx=sl.x+5,ry=sl.y+LZ_RES_TOP,rci=0;
      lzTree.forEach((res,ri)=>{
        if(rci>=LZ_RES_COLS){rci=0;rx=sl.x+5;ry+=rowH;}
        const nCh=(res.children||[]).length;
        const iconH=LZ_RES_ICON+nCh*LZ_CHILD_H;
        const rG=sG.append('g').attr('class','res-node');
        rG.on('mouseenter',function(event){
          event.stopPropagation();
          if(!_lzLocked) lzHlVpc(vl.vpc.VpcId);
          tt.innerHTML=resTooltipHtml(res,sl.sub.SubnetId,lzSubRT);
          tt.style.display='block';
        }).on('mousemove',function(event){
          positionTooltip(event,tt);
        }).on('mouseleave',function(){
          tt.style.display='none';
        });
        rG.append('rect').attr('x',rx).attr('y',ry).attr('width',iconW).attr('height',iconH)
          .attr('rx',2).attr('fill',res.bg).attr('stroke',res.col).attr('stroke-width',.5);
        rG.append('rect').attr('x',rx).attr('y',ry).attr('width',20).attr('height',iconH)
          .attr('rx',2).attr('fill',res.col).attr('fill-opacity',.25);
        rG.append('text').attr('x',rx+10).attr('y',ry+11).attr('text-anchor','middle')
          .attr('font-family','IBM Plex Mono').style('font-size','calc(5px * var(--txt-scale,1))').attr('font-weight','700')
          .attr('fill',res.col).text(res.type);
        const nameClip='lzrc-'+sl.sub.SubnetId.replace(/[^a-zA-Z0-9]/g,'')+'-'+ri;
        rG.append('clipPath').attr('id',nameClip).append('rect')
          .attr('x',rx+22).attr('y',ry).attr('width',iconW-24).attr('height',iconH);
        rG.append('text').attr('x',rx+24).attr('y',ry+9).attr('clip-path',`url(#${nameClip})`)
          .attr('font-family','IBM Plex Mono').style('font-size','calc(5.5px * var(--txt-scale,1))').attr('font-weight','600')
          .attr('fill','var(--text-primary)').text(res.name);
        if(res.ip){
          rG.append('text').attr('x',rx+24).attr('y',ry+17).attr('clip-path',`url(#${nameClip})`)
            .attr('font-family','IBM Plex Mono').style('font-size','calc(4.5px * var(--txt-scale,1))')
            .attr('fill','var(--text-muted)').text(res.ip);
        }
        if(res.state){
          const sc=res.state==='running'?'#10b981':'#ef4444';
          rG.append('circle').attr('cx',rx+iconW-4).attr('cy',ry+5).attr('r',2).attr('fill',sc);
        }
        if(nCh>0){
          (res.children||[]).forEach((ch,ci)=>{
            const cy2=ry+LZ_RES_ICON-2+ci*LZ_CHILD_H;
            const cx2=rx+22,cw=iconW-26,ch2=LZ_CHILD_H-2;
            rG.append('rect').attr('x',cx2).attr('y',cy2).attr('width',cw).attr('height',ch2)
              .attr('rx',2).attr('fill',ch.bg).attr('stroke',ch.col).attr('stroke-width',.4);
            rG.append('text').attr('x',cx2+2).attr('y',cy2+ch2/2+2)
              .attr('font-family','IBM Plex Mono').style('font-size','calc(4px * var(--txt-scale,1))').attr('font-weight','600')
              .attr('fill',ch.col).text(ch.type);
            rG.append('text').attr('x',cx2+17).attr('y',cy2+ch2/2+2).attr('clip-path',`url(#${nameClip})`)
              .attr('font-family','IBM Plex Mono').style('font-size','calc(4px * var(--txt-scale,1))')
              .attr('fill','rgba(255,255,255,.5)').text(ch.name+(ch.detail?' '+ch.detail:''));
          });
        }
        rx+=iconW+LZ_RES_GAP;
        rci++;
      });
    } else {
      sG.append('text').attr('x',sl.x+sl.w/2).attr('y',sl.y+sl.h/2+4).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--text-muted)').attr('opacity',.4).text('No resources');
    }
    
    // Subnet tooltip, highlight, and click
    const subSi=instBySub[sl.sub.SubnetId]||[];
    const subSa=albBySub[sl.sub.SubnetId]||[];
    sG.on('mouseenter',function(){
      if(!_lzLocked) lzHlVpc(vl.vpc.VpcId);
      let h='<div class="tt-title">'+gn(sl.sub,sl.sub.SubnetId)+'</div>';
      h+='<div class="tt-sub">'+(sl.pub?'Public':'Private')+' Subnet</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Details</div>';
      h+='<div class="tt-r">CIDR: <span class="i">'+sl.sub.CidrBlock+'</span></div>';
      h+='<div class="tt-r">AZ: <span class="i">'+(sl.sub.AvailabilityZone||'N/A')+'</span></div>';
      h+='<div class="tt-r">ID: <span class="i">'+sl.sub.SubnetId+'</span></div>';
      h+='</div>';
      if(subSi.length){
        h+='<div class="tt-sec"><div class="tt-sh">EC2 Instances ('+subSi.length+')</div>';
        subSi.slice(0,5).forEach(inst=>{
          const nm=inst.Tags?.find(t=>t.Key==='Name')?.Value||inst.InstanceId;
          h+='<div class="tt-r"><span class="i">'+nm+'</span> '+inst.InstanceType+' ['+inst.State?.Name+']</div>';
        });
        if(subSi.length>5)h+='<div class="tt-r">... and '+(subSi.length-5)+' more</div>';
        h+='</div>';
      }
      if(subSa.length){
        h+='<div class="tt-sec"><div class="tt-sh">Load Balancers ('+subSa.length+')</div>';
        subSa.forEach(lb=>{h+='<div class="tt-r"><span class="i">'+(lb.LoadBalancerName||'ALB')+'</span> '+lb.Type+'</div>'});
        h+='</div>';
      }
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){
      positionTooltip(event,tt);
    }).on('mouseleave',()=>{tt.style.display='none';lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      tt.style.display='none';
      const vid=vl.vpc.VpcId;
      if(!(_lzLocked&&_lzKey===vid)){
        lzForceClr();lzHlVpc(vid);
        _lzLocked=true;_lzKey=vid;lzShowLock(true);
      }
      _lastRlType=null;_navStack=[];
      openSubnetPanel(sl.sub,vl.vpc.VpcId,{pubSubs,subRT,subNacl,instBySub,eniBySub,albBySub,sgByVpc,volByInst,enis,snapByVol,tgByAlb,wafByAlb,rdsBySub,ecsBySub,lambdaBySub,ecacheByVpc,redshiftByVpc,cfByAlb});
    });
  })});
  
  // Draw gateways for hub VPC (IGW/NAT on left side)
  const hubGws=pvGws[hubVpc.VpcId]||[];
  const igwGws=hubGws.filter(g=>g.type==='IGW'||g.type==='NAT');
  
  // Draw NET node first (so lines go behind it)
  if(igwGws.length){
    const iG=ndL.append('g').attr('class','internet-node');
    // Outer glow
    iG.append('circle').attr('cx',iX).attr('cy',iY).attr('r',38)
      .attr('fill','none').attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.2);
    // Main circle
    iG.append('circle').attr('cx',iX).attr('cy',iY).attr('r',32)
      .attr('fill','rgba(16,185,129,.08)').attr('stroke','var(--igw-color)').attr('stroke-width',2);
    // Globe icon effect
    iG.append('ellipse').attr('cx',iX).attr('cy',iY).attr('rx',20).attr('ry',32)
      .attr('fill','none').attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.3);
    iG.append('line').attr('x1',iX-32).attr('y1',iY).attr('x2',iX+32).attr('y2',iY)
      .attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.3);
    // Text
    iG.append('text').attr('x',iX).attr('y',iY+4).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(11px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','var(--igw-color)').text('NET');
    iG.append('text').attr('x',iX).attr('y',iY+48).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text('Internet');
    iG.style('cursor','pointer');
    iG.on('mouseenter',function(){
      if(_lzLocked) return;
      lzHlVpc(hubVpc.VpcId);
    }).on('mouseleave',()=>{lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      const vid=hubVpc.VpcId;
      if(_lzLocked&&_lzKey===vid){lzForceClr();return}
      lzForceClr();lzHlVpc(vid);_lzLocked=true;_lzKey=vid;lzShowLock(true);
    });
  }
  
  // Draw gateways and animated connection lines
  // Use trunk-based routing: single vertical trunk from NET, horizontal branches to gateways
  const igwNatGws=hubGws.filter(g=>g.type==='IGW'||g.type==='NAT');
  const trunkX=iX+50; // Vertical trunk X position

  let gwY=hubLayout.y+50;
  hubGws.forEach((gw,i)=>{
    const gx=hubLayout.x-70;
    const gG=ndL.append('g').attr('class','lz-gw-node').attr('data-vpc',hubVpc.VpcId).attr('data-gwtype',gw.type).style('cursor','pointer');
    const col=gw.type==='IGW'?'var(--igw-color)':'var(--nat-color)';
    
    // Gateway circle
    gG.append('circle').attr('cx',gx).attr('cy',gwY).attr('r',GR)
      .attr('fill',gw.type==='IGW'?'rgba(16,185,129,.15)':'rgba(251,146,60,.15)')
      .attr('stroke',col).attr('stroke-width',2);
    gG.append('text').attr('x',gx).attr('y',gwY+4).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(9px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',col).text(gw.type);
    const gwNm=gwNames[gw.id]||'';
    if(gwNm)gG.append('text').attr('x',gx).attr('y',gwY-GR-6).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(gwNm);
    gG.append('text').attr('x',gx).attr('y',gwY+GR+14).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(sid(gw.id));
    
    // Gateway tooltip
    const gwName=gwNames[gw.id]||sid(gw.id);
    gG.on('mouseenter',function(){
      if(!_lzLocked) lzHlVpc(hubVpc.VpcId);
      let h='<div class="tt-title">'+gwName+'</div>';
      h+='<div class="tt-sub">'+gw.type+' Gateway</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Details</div>';
      h+='<div class="tt-r">ID: <span class="i">'+gw.id+'</span></div>';
      h+='<div class="tt-r">Type: <span class="i">'+gw.type+'</span></div>';
      h+='<div class="tt-r">VPC: <span class="i">'+gn(hubVpc,hubVpc.VpcId)+'</span></div>';
      h+='</div>';
      if(gw.type==='NAT'){
        const natInfo=nats.find(n=>n.NatGatewayId===gw.id);
        if(natInfo){
          h+='<div class="tt-sec"><div class="tt-sh">NAT Info</div>';
          h+='<div class="tt-r">Subnet: <span class="i">'+(natInfo.SubnetId||'N/A')+'</span></div>';
          h+='<div class="tt-r">State: <span class="i">'+(natInfo.State||'N/A')+'</span></div>';
          h+='</div>';
        }
      }
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){
      positionTooltip(event,tt);
    }).on('mouseleave',()=>{tt.style.display='none';lzClr()})
    .on('click',function(event){
      event.stopPropagation();
      const vid=hubVpc.VpcId;
      if(_lzLocked&&_lzKey===vid){lzForceClr();return}
      lzForceClr();lzHlVpc(vid);_lzLocked=true;_lzKey=vid;lzShowLock(true);
      _lastRlType=null;_navStack=[];
      openGatewayPanel(gw.id,gw.type,{gwNames,igws,nats,vpns,vpces,peerings,rts,subnets,subRT,pubSubs,vpcs,tgwAttachments});
    });

    // Connection line from gateway to hub (offset per gateway)
    const hubConnY=gwY;
    const pg=lzStructG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',`M${gx+GR},${hubConnY} L${hubLayout.x},${hubConnY}`)
      .attr('stroke',col);
    lzAllPaths.push({p:pg,vids:[hubVpc.VpcId],gwId:gw.id});
    if(!lzVpcRoutes.has(hubVpc.VpcId))lzVpcRoutes.set(hubVpc.VpcId,[]);
    lzVpcRoutes.get(hubVpc.VpcId).push({d:`M${gx+GR},${hubConnY} L${hubLayout.x},${hubConnY}`,stroke:col});
    
    gwY+=55;
  });
  
  // Draw NET-to-hub-gateways trunk (single vertical + horizontal branches)
  // These go in lzStructG for full visibility (not faded route-group)
  if(igwNatGws.length){
    const firstGwY=hubLayout.y+50;
    const lastGwY=firstGwY+(igwNatGws.length-1)*55;
    const hubGx=hubLayout.x-70;
    
    // Route from NET bottom edge: down then right to trunk
    const netBottomY=iY+34; // Just below NET circle edge
    const trunkTopY=firstGwY-20; // Start trunk above first gateway
    
    // Path from NET bottom: down, then right to trunk X
    const netDownPath=`M${iX},${netBottomY} L${iX},${trunkTopY} L${trunkX},${trunkTopY}`;
    lzStructG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',netDownPath)
      .attr('stroke','var(--igw-color)');
    
    // Vertical trunk from top down to last gateway level
    const trunkPath=`M${trunkX},${trunkTopY} L${trunkX},${lastGwY}`;
    lzStructG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',trunkPath)
      .attr('stroke','var(--igw-color)');
    
    // Horizontal branches to each gateway
    igwNatGws.forEach((gw,i)=>{
      const col=gw.type==='IGW'?'var(--igw-color)':'var(--nat-color)';
      const branchY=firstGwY+i*55;
      const branchPath=`M${trunkX},${branchY} L${hubGx-GR},${branchY}`;
      lzStructG.append('path')
        .attr('class','route-trunk animated')
        .attr('d',branchPath)
        .attr('stroke',col);
      // Still track for highlight system
      lzAllPaths.push({p:null,vids:[hubVpc.VpcId],gwId:gw.id});
      lzVpcRoutes.get(hubVpc.VpcId).push({d:branchPath,stroke:col});
    });
    // Add NET-to-trunk paths to hub VPC routes so they light up on highlight
    lzVpcRoutes.get(hubVpc.VpcId).push({d:netDownPath,stroke:'var(--igw-color)'});
    lzVpcRoutes.get(hubVpc.VpcId).push({d:trunkPath,stroke:'var(--igw-color)'});
  }
  
  // Draw gateways for spoke VPCs (on right side of each spoke)
  spokeLayouts.forEach(spoke=>{
    const spokeGws=pvGws[spoke.vpc.VpcId]||[];
    if(!spokeGws.length)return;
    
    let sgY=spoke.y+30;
    const sgX=spoke.x+spoke.w+80; // Center in gap (was 25)
    
    // Draw subtle flow indicator from VPC to gateway area
    const flowY=spoke.y+Math.max(60,spokeGws.length*50+20);
    lzRouteG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',`M${spoke.x+spoke.w},${flowY} L${spoke.x+spoke.w+20},${flowY} L${spoke.x+spoke.w+20},${spoke.y+30} L${sgX-16},${spoke.y+30}`)
      .attr('stroke','rgba(100,120,150,0.3)')
      .attr('stroke-dasharray','4 4');
    
    spokeGws.forEach((gw,i)=>{
      const gG=ndL.append('g').attr('class','lz-gw-node').attr('data-vpc',spoke.vpc.VpcId).attr('data-gwtype',gw.type).style('cursor','pointer');
      const col=gw.type==='IGW'?'var(--igw-color)':gw.type==='NAT'?'var(--nat-color)':gw.type==='VGW'?'var(--vgw-color)':'var(--text-muted)';
      const fillCol=gw.type==='IGW'?'rgba(16,185,129,.25)':gw.type==='NAT'?'rgba(251,146,60,.25)':gw.type==='VGW'?'rgba(239,68,68,.25)':'rgba(100,100,100,.25)';
      
      // Gateway circle - increased size and visibility
      gG.append('circle').attr('cx',sgX).attr('cy',sgY).attr('r',16)
        .attr('fill',fillCol).attr('stroke',col).attr('stroke-width',2);
      gG.append('text').attr('x',sgX).attr('y',sgY+4).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',col).text(gw.type);
      const sgNm=gwNames[gw.id]||'';
      if(sgNm)gG.append('text').attr('x',sgX).attr('y',sgY-20).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-secondary)').text(sgNm);
      gG.append('text').attr('x',sgX).attr('y',sgY+22).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(sid(gw.id));
      
      // Connection line from spoke to gateway
      const psg=lzRouteG.append('path')
        .attr('class','route-trunk animated')
        .attr('d',`M${spoke.x+spoke.w},${sgY} L${sgX-16},${sgY}`)
        .attr('stroke',col);
      lzAllPaths.push({p:psg,vids:[spoke.vpc.VpcId],gwId:gw.id});
      if(!lzVpcRoutes.has(spoke.vpc.VpcId))lzVpcRoutes.set(spoke.vpc.VpcId,[]);
      lzVpcRoutes.get(spoke.vpc.VpcId).push({d:`M${spoke.x+spoke.w},${sgY} L${sgX-16},${sgY}`,stroke:col});
      
      // Gateway tooltip
      const gwName=gwNames[gw.id]||sid(gw.id);
      gG.on('mouseenter',function(){
        if(!_lzLocked) lzHlVpc(spoke.vpc.VpcId);
        let h='<div class="tt-title">'+gwName+'</div>';
        h+='<div class="tt-sub">'+gw.type+' Gateway</div>';
        h+='<div class="tt-sec"><div class="tt-sh">Details</div>';
        h+='<div class="tt-r">ID: <span class="i">'+gw.id+'</span></div>';
        h+='<div class="tt-r">VPC: <span class="i">'+gn(spoke.vpc,spoke.vpc.VpcId)+'</span></div>';
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){
        positionTooltip(event,tt);
      }).on('mouseleave',()=>{tt.style.display='none';lzClr()})
      .on('click',function(event){
        event.stopPropagation();
        const vid=spoke.vpc.VpcId;
        if(_lzLocked&&_lzKey===vid){lzForceClr();return}
        lzForceClr();lzHlVpc(vid);_lzLocked=true;_lzKey=vid;lzShowLock(true);
        _lastRlType=null;_navStack=[];
        openGatewayPanel(gw.id,gw.type,{gwNames,igws,nats,vpns,vpces,peerings,rts,subnets,subRT,pubSubs,vpcs,tgwAttachments});
      });

      sgY+=50;
    });
  });
  
  // Draw spoke gateway to NET connections using a shared right-side trunk
  // Collect all spoke IGW/NAT gateways with their positions
  const spokeInetGws=[];
  spokeLayouts.forEach(spoke=>{
    const spokeGws=pvGws[spoke.vpc.VpcId]||[];
    let sgY=spoke.y+30;
    const sgX=spoke.x+spoke.w+80; // Match actual drawing position
    spokeGws.forEach((gw,i)=>{
      if(gw.type==='IGW'||gw.type==='NAT'){
        spokeInetGws.push({gw,sgX,sgY,vid:spoke.vpc.VpcId,col:gw.type==='IGW'?'var(--igw-color)':'var(--nat-color)'});
      }
      sgY+=50;
    });
  });
  
  if(spokeInetGws.length&&igwGws.length){
    // Route level above all VPCs - offset each gateway to avoid overlap
    const allVpcTops=[hubLayout.y,...spokeLayouts.map(s=>s.y)];
    const baseRouteLevel=Math.min(...allVpcTops)-40;

    // Shared trunk approach: vertical trunk to right of NET, horizontal bus to NET circle
    const spokeTrunkX=iX+34; // Right edge of NET circle (radius 32) + 2px gap

    // Track gateway index per VPC for horizontal offset
    const vpcGwIndex={};

    // Draw per-gateway paths: gateway -> exit -> routeLevel -> trunk
    spokeInetGws.forEach((g,i)=>{
      const vpcIdx=vpcGwIndex[g.vid]=(vpcGwIndex[g.vid]||0)+1;
      const routeLevel=baseRouteLevel-i*8;
      const exitX=g.sgX+25+vpcIdx*10;
      // Path stops at the shared trunk X  no more flagpole
      const netPath=`M${g.sgX+16},${g.sgY} L${exitX},${g.sgY} L${exitX},${routeLevel} L${spokeTrunkX},${routeLevel}`;
      const pb=lzStructG.append('path')
        .attr('class','route-trunk animated')
        .attr('d',netPath)
        .attr('stroke',g.col);
      lzAllPaths.push({p:pb,vids:[g.vid],gwId:g.gw.id});
      if(!lzVpcRoutes.has(g.vid))lzVpcRoutes.set(g.vid,[]);
      lzVpcRoutes.get(g.vid).push({d:netPath,stroke:g.col});
    });

    // Shared vertical trunk from top route level down to NET center Y
    const topRouteLevel=baseRouteLevel-(spokeInetGws.length-1)*8;
    const trunkVert=`M${spokeTrunkX},${topRouteLevel} L${spokeTrunkX},${iY}`;
    lzStructG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',trunkVert)
      .attr('stroke','var(--igw-color)');

    // Horizontal connector from trunk to NET circle right edge
    const netConn=`M${spokeTrunkX},${iY} L${iX+32},${iY}`;
    lzStructG.append('path')
      .attr('class','route-trunk animated')
      .attr('d',netConn)
      .attr('stroke','var(--igw-color)');

    // Add shared trunk + connector to lzVpcRoutes for each VPC with IGW/NAT
    // so they light up during highlights. Trim trunk to each VPC's route level range.
    const inetVids=new Set(spokeInetGws.map(g=>g.vid));
    inetVids.forEach(vid=>{
      // Find this VPC's route levels (its gateways' route levels)
      const vpcGws=spokeInetGws.filter(g=>g.vid===vid);
      const vpcRouteLevels=vpcGws.map((g,i)=>baseRouteLevel-spokeInetGws.indexOf(g)*8);
      const vpcTopRL=Math.min(...vpcRouteLevels);
      // Trunk from this VPC's top route level down to NET Y
      const vpcTrunk=`M${spokeTrunkX},${vpcTopRL} L${spokeTrunkX},${iY}`;
      if(!lzVpcRoutes.has(vid))lzVpcRoutes.set(vid,[]);
      lzVpcRoutes.get(vid).push({d:vpcTrunk,stroke:'var(--igw-color)'});
      lzVpcRoutes.get(vid).push({d:netConn,stroke:'var(--igw-color)'});
    });
  }
  
  // VPCE summary badges per VPC
  vL.forEach(vl=>{
    const vpcVpces=vpceByVpc[vl.vpc.VpcId]||[];
    if(!vpcVpces.length)return;
    const nw=70,nh=16;
    const gx=vl.x+nw/2+8;
    const ny=vl.y+vl.h-nh-8;
    const eG=ndL.append('g').attr('class','vpce-summary').style('cursor','pointer');
    eG.append('rect').attr('x',gx-nw/2).attr('y',ny).attr('width',nw).attr('height',nh).attr('rx',3)
      .attr('fill','rgba(167,139,250,.2)').attr('stroke','var(--vpce-color)').attr('stroke-width',1);
    eG.append('text').attr('x',gx).attr('y',ny+12).attr('text-anchor','middle').attr('font-family','IBM Plex Mono')
      .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','var(--vpce-color)').text(vpcVpces.length+' VPCE');
    eG.on('mouseenter',function(){
      let h='<div class="tt-title">VPC Endpoints ('+vpcVpces.length+')</div>';
      h+='<div class="tt-sub">'+gn(vl.vpc,vl.vpc.VpcId)+'</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Endpoints</div>';
      vpcVpces.forEach(v=>{
        const vi=vpces.find(x=>x.VpcEndpointId===v.id);
        const svc=vi?.ServiceName||'?';
        const nm=gwNames[v.id];
        h+='<div class="tt-r"><span class="i">'+(nm||v.id.slice(-8))+'</span> '+svc.split('.').pop()+' ['+vi?.VpcEndpointType+']</div>';
      });
      h+='</div>';
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
    .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('Endpoints')});
  });

  // Private zone VPC badges
  if(zones.length>0){
    const privZonesByVpc={};
    zones.forEach(z=>{
      if(z.Config?.PrivateZone&&z.VPCs){
        z.VPCs.forEach(v=>{
          const vid=v.VPCId||v.VpcId;
          if(vid)(privZonesByVpc[vid]=privZonesByVpc[vid]||[]).push(z);
        });
      }
    });
    vL.forEach(vl=>{
      const pz=privZonesByVpc[vl.vpc.VpcId];
      if(!pz||!pz.length)return;
      if(!vl.w||vl.w<50||!vl.h||vl.h<50) return;
      const nw=70,nh=16;
      const gx=vl.x+vl.w-nw/2-8;
      const ny=vl.y+vl.h-nh-8;
      const dG=ndL.append('g').attr('class','dns-summary').style('cursor','pointer');
      dG.append('rect').attr('x',gx-nw/2).attr('y',ny).attr('width',nw).attr('height',nh).attr('rx',3)
        .attr('fill','rgba(14,165,233,.15)').attr('stroke','#0ea5e9').attr('stroke-width',1);
      dG.append('text').attr('x',gx).attr('y',ny+12).attr('text-anchor','middle').attr('font-family','IBM Plex Mono')
        .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','#0ea5e9').text(pz.length+' DNS');
      dG.on('mouseenter',function(){
        let h='<div class="tt-title">Private Hosted Zones ('+pz.length+')</div>';
        h+='<div class="tt-sub">'+gn(vl.vpc,vl.vpc.VpcId)+'</div>';
        h+='<div class="tt-sec"><div class="tt-sh">Zones</div>';
        pz.forEach(z=>{
          const zid=z.Id.replace('/hostedzone/','');
          h+='<div class="tt-r"><span class="i">'+z.Name+'</span> '+z.ResourceRecordSetCount+' records ['+zid+']</div>';
        });
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('R53')});
    });
  }

  // DNS Zone section below VPCs
  let lzSectionY=maxY+40;
  const lzAllVpcRight=Math.max(...vL.map(v=>v.x+v.w));
  if(zones.length>0){
    const dnsY=lzSectionY;
    const pubZones=zones.filter(z=>!z.Config?.PrivateZone);
    const privZones=zones.filter(z=>z.Config?.PrivateZone);
    const dnsBoxW=Math.max(320,lzAllVpcRight-40);
    const lzDnsRecExp=_dnsRecordsExpanded;
    const recRowH=14;

    // Pre-calculate zone layouts
    const lzZoneLayouts=[];
    if(lzDnsRecExp){
      const fullW=dnsBoxW-40;
      let cy=0;
      zones.forEach(z=>{
        const zid=z.Id.replace('/hostedzone/','');
        const isPub=!z.Config?.PrivateZone;
        const zRecs=lzRecsByZone[zid]||[];
        const assocVpcs=(!isPub&&z.VPCs)?z.VPCs.map(v=>{const vid=v.VPCId||v.VpcId;const vpc=vpcs.find(vp=>vp.VpcId===vid);return gn(vpc||{},vid)}).join(', '):'';
        let metaLines=2;
        if(assocVpcs)metaLines++;
        const headerH=18+metaLines*14+4;
        const recsH=zRecs.length>0?(4+zRecs.length*recRowH):16;
        const zh=headerH+recsH+6;
        lzZoneLayouts.push({x:50,y:cy,w:fullW,h:zh,recs:zRecs,assocVpcs});
        cy+=zh+6;
      });
    }else{
      const dnsColW=(dnsBoxW-60)/2;
      zones.forEach((z,zi)=>{
        const col=zi%2;
        const row=Math.floor(zi/2);
        lzZoneLayouts.push({x:50+col*(dnsColW+10),y:row*32,w:dnsColW-10,h:26,recs:[]});
      });
    }
    const totalContentH=lzDnsRecExp?
      (lzZoneLayouts.length>0?lzZoneLayouts[lzZoneLayouts.length-1].y+lzZoneLayouts[lzZoneLayouts.length-1].h:0):
      (Math.ceil(zones.length/2)*32);
    let dnsBoxH=60+totalContentH+20;

    const dnsG=ndL.append('g').attr('class','dns-section');
    dnsG.append('rect').attr('x',40).attr('y',dnsY).attr('width',dnsBoxW).attr('height',dnsBoxH).attr('rx',8)
      .attr('fill','rgba(14,165,233,.06)').attr('stroke','#0ea5e9').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');
    dnsG.append('text').attr('x',60).attr('y',dnsY+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#0ea5e9').text('Route 53 Hosted Zones');
    dnsG.append('text').attr('x',60).attr('y',dnsY+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(pubZones.length+' public, '+privZones.length+' private');

    // Records expand/collapse toggle button
    const lzTogX=40+dnsBoxW-80;
    const lzTogY=dnsY+8;
    const lzTogG=dnsG.append('g').style('cursor','pointer');
    lzTogG.append('rect').attr('x',lzTogX).attr('y',lzTogY).attr('width',70).attr('height',20).attr('rx',4)
      .attr('fill','rgba(14,165,233,.15)').attr('stroke','#0ea5e9').attr('stroke-width',0.8);
    lzTogG.append('text').attr('x',lzTogX+35).attr('y',lzTogY+14).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600')
      .attr('fill','#0ea5e9').text(lzDnsRecExp?'\u25B2 Collapse':'\u25BC Expand');
    lzTogG.on('click',function(event){
      event.stopPropagation();
      _dnsRecordsExpanded=!_dnsRecordsExpanded;
      renderMap();
    });

    zones.forEach((z,zi)=>{
      const isPub=!z.Config?.PrivateZone;
      const zid=z.Id.replace('/hostedzone/','');
      const lay=lzZoneLayouts[zi];
      const zx=lay.x;
      const zy=dnsY+52+lay.y;
      const zw=lay.w;
      const zh=lay.h;

      const zG=dnsG.append('g').style('cursor','pointer');
      zG.append('rect').attr('x',zx).attr('y',zy).attr('width',zw).attr('height',zh).attr('rx',4)
        .attr('fill',isPub?'rgba(16,185,129,.18)':'rgba(14,165,233,.18)')
        .attr('stroke',isPub?'#10b981':'#0ea5e9').attr('stroke-width',1.5);

      // Icon
      zG.append('circle').attr('cx',zx+12).attr('cy',zy+13).attr('r',6)
        .attr('fill',isPub?'#10b981':'#0ea5e9');
      zG.append('text').attr('x',zx+12).attr('y',zy+16.5).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','700')
        .attr('fill','#fff').text(isPub?'P':'R');

      // Zone name (full in records-expanded, truncated in compact)
      const dispName=lzDnsRecExp?z.Name:(z.Name.length>35?z.Name.substring(0,33)+'..':z.Name);
      zG.append('text').attr('x',zx+24).attr('y',zy+15).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',isPub?'#10b981':'#0ea5e9')
        .text(dispName);

      // Compact: record count only
      if(!lzDnsRecExp){
        zG.append('text').attr('x',zx+zw).attr('y',zy+15).attr('text-anchor','end')
          .attr('font-family','IBM Plex Mono').style('font-size','calc(9px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
          .text(z.ResourceRecordSetCount+' rec');
      }

      // Records expanded: metadata + records
      if(lzDnsRecExp){
        let my=zy+18;
        zG.append('text').attr('x',zx+24).attr('y',my+14).attr('font-family','IBM Plex Mono')
          .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
          .text('Zone ID: '+zid+'  |  '+z.ResourceRecordSetCount+' records  |  '+(isPub?'Public':'Private'));
        my+=14;
        if(lay.assocVpcs){
          zG.append('text').attr('x',zx+24).attr('y',my+14).attr('font-family','IBM Plex Mono')
            .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
            .text('VPCs: '+lay.assocVpcs);
          my+=14;
        }
        if(lay.recs.length>0){
          my+=4;
          zG.append('line').attr('x1',zx+8).attr('y1',my).attr('x2',zx+zw-8).attr('y2',my)
            .attr('stroke',isPub?'#10b981':'#0ea5e9').attr('stroke-width',0.5).attr('stroke-opacity',0.4);
          my+=4;
          lay.recs.forEach(rec=>{
            const rName=(rec.Name||'').replace(/\.$/,'');
            const rType=rec.Type||'';
            const rVal=rec.AliasTarget?'ALIAS \u2192 '+(rec.AliasTarget.DNSName||'').replace(/\.$/,''):
              (rec.ResourceRecords||[]).map(rr=>rr.Value).join(', ');
            zG.append('text').attr('x',zx+10).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',isPub?'#059669':'#0284c7')
              .text(rType);
            zG.append('text').attr('x',zx+50).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-primary)')
              .text(rName.length>50?rName.substring(0,48)+'..':rName);
            zG.append('text').attr('x',zx+350).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
              .text(rVal.length>80?rVal.substring(0,78)+'..':rVal);
            my+=recRowH;
          });
        }else{
          my+=6;
          zG.append('text').attr('x',zx+24).attr('y',my+10).attr('font-family','IBM Plex Mono')
            .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-style','italic').attr('fill','var(--text-muted)')
            .text('Click zone for details \u2022 Load record sets via "Record Sets" input');
        }
      }

      // Tooltip
      zG.on('mouseenter',function(){
        let h='<div class="tt-title">'+(isPub?'Public':'Private')+' Hosted Zone</div>';
        h+='<div class="tt-sub">'+z.Name+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">Zone ID</span> '+zid+'</div>';
        h+='<div class="tt-r"><span class="i">Records</span> '+z.ResourceRecordSetCount+'</div>';
        if(!isPub&&z.VPCs){
          h+='<div class="tt-sh" style="margin-top:4px">Associated VPCs</div>';
          z.VPCs.forEach(v=>{
            const vid=v.VPCId||v.VpcId;
            const vpcObj=vpcs.find(x=>x.VpcId===vid);
            h+='<div class="tt-r"><span class="i">'+(vpcObj?gn(vpcObj,vid):vid)+'</span></div>';
          });
        }
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('R53')});
    });
    lzSectionY=dnsY+dnsBoxH+30;
  }

  // S3 Buckets section
  if(s3bk.length>0){
    const s3Y=lzSectionY;
    const s3BoxW=Math.max(320,lzAllVpcRight-40);
    const s3Cols=3;
    const s3ColW=Math.min(320,(s3BoxW-40)/s3Cols);
    const s3RowH=24;
    const s3Rows=Math.ceil(s3bk.length/s3Cols);
    const s3BoxH=50+s3Rows*(s3RowH+4)+20;

    const s3G=ndL.append('g').attr('class','s3-section');
    s3G.append('rect').attr('x',40).attr('y',s3Y).attr('width',s3BoxW).attr('height',s3BoxH).attr('rx',8)
      .attr('fill','rgba(234,88,12,.06)').attr('stroke','#ea580c').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');
    s3G.append('text').attr('x',60).attr('y',s3Y+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#ea580c').text('S3 Buckets');
    s3G.append('text').attr('x',60).attr('y',s3Y+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(s3bk.length+' buckets');

    s3bk.forEach((bk,bi)=>{
      const col=bi%s3Cols;
      const row=Math.floor(bi/s3Cols);
      const bx=50+col*(s3ColW+5);
      const by=s3Y+48+row*(s3RowH+4);

      const bG=s3G.append('g').style('cursor','pointer');
      bG.append('rect').attr('x',bx).attr('y',by).attr('width',s3ColW-10).attr('height',s3RowH).attr('rx',3)
        .attr('fill','rgba(234,88,12,.1)').attr('stroke','#ea580c').attr('stroke-width',0.8);
      const maxChars=Math.floor((s3ColW-20)/6);
      const dispName=bk.Name.length>maxChars?bk.Name.substring(0,maxChars-2)+'..':bk.Name;
      bG.append('text').attr('x',bx+6).attr('y',by+16).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','500').attr('fill','#ea580c').text(dispName);

      bG.on('mouseenter',function(){
        let h='<div class="tt-title">S3 Bucket</div>';
        h+='<div class="tt-sub">'+bk.Name+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">Created</span> '+(bk.CreationDate||'N/A').split('T')[0]+'</div>';
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('S3')});
    });
    lzSectionY=s3Y+s3BoxH+30;
  }

  // CloudFront distributions section
  if(cfDistributions.length>0){
    const cfY=lzSectionY;
    const cfBoxW=Math.max(320,lzAllVpcRight-40);
    const cfCols=2;
    const cfColW=Math.min(480,(cfBoxW-40)/cfCols);
    const cfRowH=28;
    const cfRows=Math.ceil(cfDistributions.length/cfCols);
    const cfBoxH=50+cfRows*(cfRowH+4)+20;

    const cfG=ndL.append('g').attr('class','cf-section');
    cfG.append('rect').attr('x',40).attr('y',cfY).attr('width',cfBoxW).attr('height',cfBoxH).attr('rx',8)
      .attr('fill','rgba(139,92,246,.06)').attr('stroke','#8b5cf6').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');
    cfG.append('text').attr('x',60).attr('y',cfY+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#8b5cf6').text('CloudFront Distributions');
    cfG.append('text').attr('x',60).attr('y',cfY+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(cfDistributions.length+' distributions');

    cfDistributions.forEach((d,di)=>{
      const col=di%cfCols;
      const row=Math.floor(di/cfCols);
      const cx=50+col*(cfColW+5);
      const cy=cfY+48+row*(cfRowH+4);
      const aliases=(d.Aliases?.Items||[]);

      const cG=cfG.append('g').style('cursor','pointer');
      cG.append('rect').attr('x',cx).attr('y',cy).attr('width',cfColW-10).attr('height',cfRowH).attr('rx',3)
        .attr('fill','rgba(139,92,246,.12)').attr('stroke','#8b5cf6').attr('stroke-width',0.8);
      cG.append('text').attr('x',cx+6).attr('y',cy+12).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(9px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','#8b5cf6').text(d.DomainName||d.Id);
      if(aliases.length){
        cG.append('text').attr('x',cx+6).attr('y',cy+23).attr('font-family','IBM Plex Mono')
          .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(aliases.join(', '));
      }

      cG.on('mouseenter',function(){
        let h='<div class="tt-title">CloudFront Distribution</div>';
        h+='<div class="tt-sub">'+(d.DomainName||d.Id)+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">ID</span> '+d.Id+'</div>';
        h+='<div class="tt-r"><span class="i">Status</span> '+(d.Status||'?')+'</div>';
        if(aliases.length)h+='<div class="tt-r"><span class="i">Aliases</span> '+aliases.join(', ')+'</div>';
        const origins=(d.Origins?.Items||[]);
        if(origins.length){
          h+='<div class="tt-sh" style="margin-top:4px">Origins</div>';
          origins.forEach(o=>{h+='<div class="tt-r"><span class="i">'+(o.Id||'')+'</span> '+o.DomainName+'</div>'});
        }
        if(d.WebACLId)h+='<div class="tt-r"><span class="i">WAF</span> '+d.WebACLId.split('/').pop()+'</div>';
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('CF')});
    });
    lzSectionY=cfY+cfBoxH+30;
  }

  // Legend
  const legX=20,legY=lzSectionY;
  const legG=ndL.append('g').attr('class','legend');
  legG.append('text').attr('x',legX).attr('y',legY).attr('font-family','IBM Plex Mono').style('font-size','calc(9px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','var(--text-secondary)').text('LANDING ZONE LAYOUT');
  const items=[
    {c:'#7C3AED',t:'Hub VPC'},{c:'var(--vpc-stroke)',t:'Spoke VPC'},
    {c:'var(--tgw-color)',t:'Transit GW'},{c:'var(--igw-color)',t:'Internet GW'},
    {c:'var(--nat-color)',t:'NAT GW'},{c:'var(--subnet-public)',t:'Public'},{c:'var(--subnet-private)',t:'Private'}
  ];
  items.forEach((it,i)=>{
    const ix=legX+i*100;
    legG.append('rect').attr('x',ix).attr('y',legY+10).attr('width',12).attr('height',12).attr('rx',2).attr('fill',it.c).attr('opacity',.8);
    legG.append('text').attr('x',ix+16).attr('y',legY+20).attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(it.t);
  });
  
  // Stats bar
  _rlCtx={vpcs,subnets,pubSubs,rts,sgs,nacls,enis,igws,nats,vpces,instances,albs,tgs,peerings,vpns,volumes,snapshots,s3bk,zones,wafAcls,wafByAlb,tgByAlb,cfByAlb:cfByAlb||{},rdsInstances,ecsServices,lambdaFns,ecacheClusters,redshiftClusters,cfDistributions,instBySub,albBySub,eniBySub,rdsBySub,ecsBySub,lambdaBySub,subRT,subNacl,sgByVpc,volByInst,snapByVol,ecacheByVpc,redshiftByVpc,tgwAttachments,recsByZone:lzRecsByZone};
  const sb2=document.getElementById('statsBar');sb2.innerHTML='';sb2.style.display='flex';
  [{l:'VPCs',v:vpcs.length},{l:'Subnets',v:subnets.length},{l:'Public',v:pubSubs.size},{l:'Private',v:subnets.length-pubSubs.size},{l:'Gateways',v:gwSet.size},{l:'RTs',v:rts.length},{l:'NACLs',v:nacls.length},{l:'SGs',v:sgs.length},{l:'EC2',v:instances.length},{l:'ENIs',v:enis.length},{l:'ALBs',v:albs.length},{l:'TGs',v:tgs.length},{l:'RDS',v:rdsInstances.length},{l:'ECS',v:ecsServices.length},{l:'Lambda',v:lambdaFns.length},{l:'Cache',v:ecacheClusters.length},{l:'Redshift',v:redshiftClusters.length},{l:'Peering',v:peerings.length},{l:'VPNs',v:vpns.length},{l:'Endpoints',v:vpces.length},{l:'Volumes',v:volumes.length},{l:'Snapshots',v:snapshots.length},{l:'S3',v:s3bk.length},{l:'R53',v:zones.length},{l:'WAF',v:wafAcls.length},{l:'CF',v:cfDistributions.length}].forEach(s=>{
    if(s.v>0){const c=document.createElement('div');c.className='stat-chip';c.dataset.type=s.l;c.innerHTML=`<b>${s.v}</b>${s.l}`;c.addEventListener('click',()=>openResourceList(s.l));sb2.appendChild(c)}
  });
  // Compliance chip (landing zone)
  try{const findings=runComplianceChecks(_rlCtx);if(findings.length)addComplianceChip(sb2,findings)}catch(ce){console.warn('Compliance check error:',ce)}
  document.getElementById('legend').style.display='flex';
  document.getElementById('exportBar').style.display='flex';
  setTimeout(()=>d3.select('#zoomFit').dispatch('click'),100);
}

// EXECUTIVE OVERVIEW
function renderExecutiveOverview(ctx){
  const {vpcs,subnets,instances,albs,peerings,vpns,s3bk,zones,rdsInstances,ecsServices,
    lambdaFns,ecacheClusters,redshiftClusters,cfDistributions,subByVpc,instBySub,albBySub,
    rdsBySub,ecsBySub,lambdaBySub,pvGws,shGws,vpceByVpc,tgwAttachments,
    rts,sgs,nacls,enis,igws,nats,vpces,tgs,volumes,snapshots,wafAcls,
    pubSubs,subRT,subNacl,sgByVpc,eniBySub,volByInst,snapByVol,tgByAlb,wafByAlb,
    ecacheByVpc,redshiftByVpc,cfByAlb}=ctx;
  
  // Store context for stat chip clicks
  _rlCtx=ctx;
  
  const svg=d3.select('#mapSvg');
  const W=document.querySelector('.main').clientWidth,H=document.querySelector('.main').clientHeight;
  svg.attr('width',W).attr('height',H);
  const g=svg.append('g').attr('class','map-root');
  const zB=d3.zoom().scaleExtent([.08,5]).on('zoom',e=>{g.attr('transform',e.transform);document.getElementById('zoomLevel').textContent=Math.round(e.transform.k*100)+'%'});svg.call(zB);
  _mapSvg=svg;_mapZoom=zB;_mapG=g;
  bindZoomButtons();
  
  const tt=document.getElementById('tooltip');
  
  // Per-VPC resource stats
  const vpcStats=vpcs.map(v=>{
    const ss=subByVpc[v.VpcId]||[];
    let ec2=0,alb=0,rds=0,ecs=0,fn=0,eniC=0,volC=0;
    ss.forEach(s=>{
      ec2+=(instBySub[s.SubnetId]||[]).length;
      alb+=(albBySub[s.SubnetId]||[]).length;
      rds+=(rdsBySub[s.SubnetId]||[]).length;
      ecs+=(ecsBySub[s.SubnetId]||[]).length;
      fn+=(lambdaBySub[s.SubnetId]||[]).length;
      eniC+=(eniBySub[s.SubnetId]||[]).length;
      (instBySub[s.SubnetId]||[]).forEach(i=>{volC+=(volByInst[i.InstanceId]||[]).length});
    });
    const sgC=(sgByVpc[v.VpcId]||[]).length;
    const gws=(pvGws[v.VpcId]||[]);
    const vpceCount=(vpceByVpc[v.VpcId]||[]).length;
    const region=ss.find(s=>s.AvailabilityZone)?.AvailabilityZone?.replace(/[a-z]$/,'')||'';
    return {vpc:v,subCount:ss.length,ec2,alb,rds,ecs,fn,eniC,volC,sgC,total:ec2+alb+rds+ecs+fn,gwCount:gws.length,vpceCount,region};
  });
  
  // Layout VPC cards in grid
  const CARD_W=300,CARD_H=220,CARD_GAP=40,COLS=Math.max(2,Math.min(4,Math.ceil(Math.sqrt(vpcs.length))));
  const startX=60,startY=120;
  
  const vpcPositions=new Map();
  vpcStats.forEach((vs,i)=>{
    const col=i%COLS,row=Math.floor(i/COLS);
    const cx=startX+col*(CARD_W+CARD_GAP);
    const cy=startY+row*(CARD_H+CARD_GAP);
    vpcPositions.set(vs.vpc.VpcId,{x:cx,y:cy,cx:cx+CARD_W/2,cy:cy+CARD_H/2,vs});
  });
  
  // Draw connections first (behind cards)
  const connG=g.append('g').attr('class','exec-connections');
  
  // Peering connections
  peerings.forEach(p=>{
    const aVpc=p.AccepterVpcInfo?.VpcId,rVpc=p.RequesterVpcInfo?.VpcId;
    const pa=vpcPositions.get(aVpc),pr=vpcPositions.get(rVpc);
    if(!pa||!pr)return;
    const mx=(pa.cx+pr.cx)/2,my=(pa.cy+pr.cy)/2;
    connG.append('path').attr('d',`M${pa.cx},${pa.cy} Q${mx},${my-30} ${pr.cx},${pr.cy}`)
      .attr('fill','none').attr('stroke','var(--pcx-color)').attr('stroke-width',2)
      .attr('stroke-dasharray','8 4').attr('opacity',.6);
    connG.append('circle').attr('cx',mx).attr('cy',my-15).attr('r',10)
      .attr('fill','var(--bg-card)').attr('stroke','var(--pcx-color)').attr('stroke-width',1);
    connG.append('text').attr('x',mx).attr('y',my-11).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--pcx-color)').text('PCX');
  });
  
  // TGW connections (shared gateways connect to all VPCs that route through them)
  const tgwVpcs=new Map();
  shGws.filter(g2=>g2.type==='TGW').forEach(tgw=>{
    const connected=[];
    vpcs.forEach(v=>{
      const ss=subByVpc[v.VpcId]||[];
      const rts2=ctx.rts.filter(rt=>rt.VpcId===v.VpcId||(rt.Associations||[]).some(a=>ss.some(s=>s.SubnetId===a.SubnetId)));
      const hasTgw=rts2.some(rt=>(rt.Routes||[]).some(r=>r.TransitGatewayId===tgw.id));
      if(hasTgw)connected.push(v.VpcId);
    });
    if(connected.length>1) tgwVpcs.set(tgw.id,connected);
  });
  
  // Draw TGW hub if present
  tgwVpcs.forEach((vids,tgwId)=>{
    let hubX=0,hubY=0,cnt=0;
    vids.forEach(vid=>{const p=vpcPositions.get(vid);if(p){hubX+=p.cx;hubY+=p.cy;cnt++}});
    if(!cnt)return;
    hubX/=cnt;hubY/=cnt;
    
    // TGW node
    connG.append('circle').attr('cx',hubX).attr('cy',hubY).attr('r',22)
      .attr('fill','var(--bg-card)').attr('stroke','var(--tgw-color)').attr('stroke-width',2);
    connG.append('text').attr('x',hubX).attr('y',hubY+3).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','700')
      .attr('fill','var(--tgw-color)').text('TGW');
    
    // Spokes to VPCs
    vids.forEach(vid=>{
      const p=vpcPositions.get(vid);if(!p)return;
      connG.append('line').attr('x1',hubX).attr('y1',hubY).attr('x2',p.cx).attr('y2',p.cy)
        .attr('stroke','var(--tgw-color)').attr('stroke-width',1.5).attr('stroke-dasharray','6 3').attr('opacity',.4);
    });
  });
  
  // Draw VPC cards
  const cardG=g.append('g').attr('class','exec-cards');
  
  vpcStats.forEach((vs,i)=>{
    const pos=vpcPositions.get(vs.vpc.VpcId);
    const cx=pos.x,cy=pos.y;
    const cG=cardG.append('g').attr('class','exec-card').style('cursor','pointer');
    
    // Card background
    cG.append('rect').attr('x',cx).attr('y',cy).attr('width',CARD_W).attr('height',CARD_H)
      .attr('rx',6).attr('fill','rgba(30,41,59,.85)').attr('stroke','var(--vpc-stroke)').attr('stroke-width',1.5);
    
    // Header bar
    cG.append('rect').attr('x',cx).attr('y',cy).attr('width',CARD_W).attr('height',32)
      .attr('rx',6).attr('fill','rgba(59,130,246,.12)');
    cG.append('rect').attr('x',cx).attr('y',cy+26).attr('width',CARD_W).attr('height',6)
      .attr('fill','rgba(59,130,246,.12)');
    
    // VPC name
    cG.append('text').attr('x',cx+12).attr('y',cy+20)
      .attr('font-family','IBM Plex Mono').style('font-size','calc(11px * var(--txt-scale,1))').attr('font-weight','700')
      .attr('fill','var(--text-primary)').text(gn(vs.vpc,vs.vpc.VpcId));
    
    // Region tag
    if(vs.region){
      cG.append('text').attr('x',cx+CARD_W-10).attr('y',cy+20).attr('text-anchor','end')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(vs.region);
    }
    
    // CIDR
    cG.append('text').attr('x',cx+12).attr('y',cy+48)
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
      .text(vs.vpc.CidrBlock||'N/A');
    
    // Subnet count
    cG.append('text').attr('x',cx+CARD_W-10).attr('y',cy+48).attr('text-anchor','end')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-secondary)')
      .text(vs.subCount+' subnet'+(vs.subCount!==1?'s':''));
    
    // Resource bars
    const barY=cy+62;
    const resTypes=[
      {label:'EC2',count:vs.ec2,col:'#10b981',rlType:'EC2'},
      {label:'ALB',count:vs.alb,col:'#38bdf8',rlType:'ALBs'},
      {label:'RDS',count:vs.rds,col:'#3b82f6',rlType:'RDS'},
      {label:'ECS',count:vs.ecs,col:'#f97316',rlType:'ECS'},
      {label:'Lambda',count:vs.fn,col:'#a855f7',rlType:'Lambda'},
      {label:'ENI',count:vs.eniC,col:'#64748b',rlType:'ENIs'},
      {label:'VOL',count:vs.volC,col:'#f59e0b',rlType:'Volumes'},
      {label:'SG',count:vs.sgC,col:'#eab308',rlType:'SGs'}
    ].filter(r=>r.count>0);
    
    const maxCount=Math.max(1,...resTypes.map(r=>r.count));
    const barMaxW=CARD_W-80;
    
    resTypes.forEach((rt,ri)=>{
      const by=barY+ri*16;
      const barG=cG.append('g').style('cursor','pointer');
      barG.append('rect').attr('x',cx).attr('y',by-1).attr('width',CARD_W).attr('height',15)
        .attr('fill','transparent');
      barG.append('text').attr('x',cx+12).attr('y',by+9)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6.5px * var(--txt-scale,1))').attr('fill',rt.col).text(rt.label);
      barG.append('rect').attr('x',cx+52).attr('y',by+1).attr('width',barMaxW).attr('height',9)
        .attr('rx',2).attr('fill','rgba(255,255,255,.03)');
      const bw=Math.max(4,(rt.count/maxCount)*barMaxW);
      barG.append('rect').attr('x',cx+52).attr('y',by+1).attr('width',bw).attr('height',9)
        .attr('rx',2).attr('fill',rt.col).attr('fill-opacity',.3);
      barG.append('text').attr('x',cx+54+bw).attr('y',by+9)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6.5px * var(--txt-scale,1))').attr('font-weight','600')
        .attr('fill',rt.col).text(rt.count);
      barG.on('click',function(event){event.stopPropagation();openResourceList(rt.rlType)});
      barG.on('mouseenter',function(){d3.select(this).selectAll('rect').filter(function(d,i){return i===2}).attr('fill-opacity',.6)})
        .on('mouseleave',function(){d3.select(this).selectAll('rect').filter(function(d,i){return i===2}).attr('fill-opacity',.3)});
    });
    
    // Gateway summary at bottom
    const gwY=cy+CARD_H-18;
    let gwX=cx+12;
    if(vs.gwCount){
      const gwG2=cG.append('g').style('cursor','pointer');
      gwG2.append('text').attr('x',gwX).attr('y',gwY)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6.5px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
        .text(vs.gwCount+' gateway'+(vs.gwCount!==1?'s':''));
      gwG2.on('click',function(event){event.stopPropagation();openResourceList('Gateways')});
      gwX+=vs.gwCount.toString().length*6+50;
    }
    if(vs.vpceCount){
      const vpceG2=cG.append('g').style('cursor','pointer');
      vpceG2.append('text').attr('x',gwX).attr('y',gwY)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6.5px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
        .text(vs.vpceCount+' endpoint'+(vs.vpceCount!==1?'s':''));
      vpceG2.on('click',function(event){event.stopPropagation();openResourceList('Endpoints')});
    }
    
    // Total resources badge
    if(vs.total>0){
      const tw=vs.total.toString().length*6+30;
      cG.append('rect').attr('x',cx+CARD_W-tw-8).attr('y',gwY-10).attr('width',tw).attr('height',14)
        .attr('rx',3).attr('fill','rgba(99,102,241,.15)').attr('stroke','rgba(99,102,241,.4)').attr('stroke-width',.5);
      cG.append('text').attr('x',cx+CARD_W-tw/2-8).attr('y',gwY+1).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','700')
        .attr('fill','#818cf8').text(vs.total+' total');
    }
    
    // Tooltip on hover
    cG.on('mouseenter',function(){
      let h='<div class="tt-title">'+gn(vs.vpc,vs.vpc.VpcId)+'</div>';
      h+='<div class="tt-sub">'+vs.vpc.VpcId+'</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Overview</div>';
      h+='<div class="tt-r">CIDR: <span class="i">'+vs.vpc.CidrBlock+'</span></div>';
      h+='<div class="tt-r">Region: <span class="i">'+(vs.region||'Unknown')+'</span></div>';
      h+='<div class="tt-r">Subnets: <span class="i">'+vs.subCount+'</span></div>';
      h+='<div class="tt-r">Total Resources: <span class="i">'+vs.total+'</span></div>';
      h+='</div>';
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){
      positionTooltip(event,tt);
    }).on('mouseleave',()=>{tt.style.display='none'})
    .on('click',function(){openResourceList('VPCs')});
  });
  
  // Global stats header with clickable chips
  const hdrG=g.append('g');
  hdrG.append('text').attr('x',startX).attr('y',40)
    .attr('font-family','IBM Plex Mono').style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700')
    .attr('fill','var(--text-primary)').text('Executive Overview');
  
  const hdrStats=[
    {l:'VPCs',v:vpcs.length,t:'VPCs',c:'#7C3AED'},
    {l:'Subnets',v:subnets.length,t:'Subnets',c:'#06b6d4'},
    {l:'EC2',v:instances.length,t:'EC2',c:'#10b981'},
    {l:'ALB',v:albs.length,t:'ALBs',c:'#38bdf8'},
    {l:'RDS',v:rdsInstances.length,t:'RDS',c:'#3b82f6'},
    {l:'ECS',v:ecsServices.length,t:'ECS',c:'#f97316'},
    {l:'Lambda',v:lambdaFns.length,t:'Lambda',c:'#a855f7'},
    {l:'ENI',v:enis.length,t:'ENIs',c:'#64748b'},
    {l:'SG',v:sgs.length,t:'SGs',c:'#eab308'},
    {l:'VOL',v:volumes.length,t:'Volumes',c:'#f59e0b'},
    {l:'S3',v:s3bk.length,t:'S3',c:'#ea580c'},
    {l:'R53',v:zones.length,t:'R53',c:'#06b6d4'}
  ].filter(s=>s.v>0);
  let hsx=startX;
  hdrStats.forEach(s=>{
    const chipW=s.l.length*5.5+String(s.v).length*6+14;
    const chipG=hdrG.append('g').style('cursor','pointer');
    chipG.append('rect').attr('x',hsx).attr('y',50).attr('width',chipW).attr('height',16)
      .attr('rx',3).attr('fill','rgba(255,255,255,.04)').attr('stroke',s.c).attr('stroke-width',.5);
    chipG.append('text').attr('x',hsx+4).attr('y',61)
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','700')
      .attr('fill',s.c).text(s.v);
    chipG.append('text').attr('x',hsx+4+String(s.v).length*6+2).attr('y',61)
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))')
      .attr('fill','var(--text-muted)').text(s.l);
    chipG.on('click',function(){openResourceList(s.t)});
    chipG.on('mouseenter',function(){d3.select(this).select('rect').attr('fill','rgba(255,255,255,.08)')})
      .on('mouseleave',function(){d3.select(this).select('rect').attr('fill','rgba(255,255,255,.04)')});
    hsx+=chipW+6;
  });
  
  // Shared services section
  const lastRow=Math.floor((vpcs.length-1)/COLS);
  const sharedY=startY+(lastRow+1)*(CARD_H+CARD_GAP)+20;
  
  if(s3bk.length||zones.length||cfDistributions.length||peerings.length||vpns.length||snapshots.length||wafAcls.length){
    const shG=g.append('g');
    shG.append('text').attr('x',startX).attr('y',sharedY)
      .attr('font-family','IBM Plex Mono').style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','700')
      .attr('fill','var(--text-secondary)').text('Global Services');
    
    let sx=startX;
    function sharedCard(label,count,col,rlType){
      if(!count)return;
      const w=80,h=36;
      const scG=shG.append('g').style('cursor','pointer');
      scG.append('rect').attr('x',sx).attr('y',sharedY+10).attr('width',w).attr('height',h)
        .attr('rx',4).attr('fill','rgba(30,41,59,.6)').attr('stroke',col).attr('stroke-width',.8);
      scG.append('text').attr('x',sx+w/2).attr('y',sharedY+26).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700')
        .attr('fill',col).text(count);
      scG.append('text').attr('x',sx+w/2).attr('y',sharedY+40).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(label);
      if(rlType)scG.on('click',function(){openResourceList(rlType)});
      scG.on('mouseenter',function(){d3.select(this).select('rect').attr('fill','rgba(30,41,59,.95)')})
        .on('mouseleave',function(){d3.select(this).select('rect').attr('fill','rgba(30,41,59,.6)')});
      sx+=w+12;
    }
    sharedCard('S3 Buckets',s3bk.length,'#f59e0b','S3');
    sharedCard('R53 Zones',zones.length,'#06b6d4','R53');
    sharedCard('CloudFront',cfDistributions.length,'#8b5cf6','CF');
    sharedCard('TGW',shGws.filter(g2=>g2.type==='TGW').length,'var(--tgw-color)','Gateways');
    sharedCard('VPN',vpns?.length||0,'#ef4444','VPNs');
    sharedCard('Peering',peerings.length,'#fb923c','Peering');
    sharedCard('Snapshots',snapshots.length,'#94a3b8','Snapshots');
    sharedCard('WAF',wafAcls.length,'#eab308','WAF');
  }
  
  // Hide stats bar in executive overview (stats are shown in the header)
  const sb2=document.getElementById('statsBar');sb2.innerHTML='';sb2.style.display='none';
  
  // Show legend but auto-collapse it
  const leg=document.getElementById('legend');
  leg.style.display='flex';
  leg.classList.add('collapsed');
  document.getElementById('exportBar').style.display='flex';
  setTimeout(()=>d3.select('#zoomFit').dispatch('click'),100);
}

function renderMap(){
  const overlay=document.getElementById('loadingOverlay');
  overlay.style.display='flex';
  requestAnimationFrame(()=>{requestAnimationFrame(()=>{_renderMapInner();overlay.style.display='none'})});
}
function _renderMapInner(){
  try{
  const svg=d3.select('#mapSvg');svg.selectAll('*').remove();svg.style('display','block');
  // SVG filter to prevent alpha stacking in route groups
  const defs=svg.append('defs');
  defs.append('filter').attr('id','alphaClamp')
    .append('feComponentTransfer')
    .append('feFuncA').attr('type','table').attr('tableValues','0 1 1 1');
  document.getElementById('emptyState').style.display='none';

  // parse all 18 inputs
  let vpcs=ext(safeParse(gv('in_vpcs')),['Vpcs']);
  let subnets=ext(safeParse(gv('in_subnets')),['Subnets']);
  let rts=ext(safeParse(gv('in_rts')),['RouteTables']);
  let sgs=ext(safeParse(gv('in_sgs')),['SecurityGroups']);
  let nacls=ext(safeParse(gv('in_nacls')),['NetworkAcls']);
  let enis=ext(safeParse(gv('in_enis')),['NetworkInterfaces']);
  let igws=ext(safeParse(gv('in_igws')),['InternetGateways']);
  let nats=ext(safeParse(gv('in_nats')),['NatGateways']);
  let vpces=ext(safeParse(gv('in_vpces')),['VpcEndpoints']);
  let instances=[];
  const eRaw=safeParse(gv('in_ec2'));
  if(eRaw){
    const reservations=ext(eRaw,['Reservations']);
    if(reservations.length){reservations.forEach(r=>{if(r.Instances)instances=instances.concat(r.Instances);else if(r.InstanceId)instances.push(r)})}
    else{
      // fallback: {Instances:[...]} or bare array of instances
      const flat=ext(eRaw,['Instances']);
      if(flat.length)instances=flat;
      else{const arr=Array.isArray(eRaw)?eRaw:[eRaw];arr.forEach(x=>{if(x.InstanceId)instances.push(x)})}
    }
  }
  let albs=ext(safeParse(gv('in_albs')),['LoadBalancers']);
  let tgs=ext(safeParse(gv('in_tgs')),['TargetGroups']);
  let peerings=ext(safeParse(gv('in_peer')),['VpcPeeringConnections']);
  let vpns=ext(safeParse(gv('in_vpn')),['VpnConnections']);
  let volumes=ext(safeParse(gv('in_vols')),['Volumes']);
  let snapshots=ext(safeParse(gv('in_snaps')),['Snapshots']);
  let s3raw=safeParse(gv('in_s3'));let s3bk=s3raw?ext(s3raw,['Buckets']):[];
  let zones=ext(safeParse(gv('in_r53')),['HostedZones']);
  const allRecSets=ext(safeParse(gv('in_r53records')),['ResourceRecordSets']);
  const recsByZoneMap={};
  allRecSets.forEach(r=>{if(r.HostedZoneId)(recsByZoneMap[r.HostedZoneId]=recsByZoneMap[r.HostedZoneId]||[]).push(r)});
  let wafAcls=ext(safeParse(gv('in_waf')),['WebACLs']);
  let rdsInstances=ext(safeParse(gv('in_rds')),['DBInstances']);
  let ecsServices=ext(safeParse(gv('in_ecs')),['services']);
  let lambdaFns=(ext(safeParse(gv('in_lambda')),['Functions'])).filter(f=>f.VpcConfig&&f.VpcConfig.VpcId);
  let ecacheClusters=ext(safeParse(gv('in_elasticache')),['CacheClusters']);
  let redshiftClusters=ext(safeParse(gv('in_redshift')),['Clusters']);
  let tgwAttachments=ext(safeParse(gv('in_tgwatt')),['TransitGatewayAttachments']);
  let cfDistributions=[];
  const cfRaw=safeParse(gv('in_cf'));
  if(cfRaw){const dl=cfRaw.DistributionList||cfRaw;cfDistributions=dl.Items||dl.Distributions||[];}

  if(!vpcs.length&&!subnets.length){document.getElementById('emptyState').style.display='flex';svg.style('display','none');return}

  // lookups
  const subByVpc={};subnets.forEach(s=>(subByVpc[s.VpcId]=subByVpc[s.VpcId]||[]).push(s));
  const pubSubs=new Set(),subRT={},gwSet=new Map();

  // gateway name enrichment from dedicated JSON
  gwNames={};
  igws.forEach(g=>{gwNames[g.InternetGatewayId]=gn(g,g.InternetGatewayId)});
  nats.forEach(g=>{gwNames[g.NatGatewayId]=gn(g,g.NatGatewayId)});
  vpces.forEach(g=>{gwNames[g.VpcEndpointId]=gn(g,g.VpcEndpointId)});
  vpns.forEach(g=>{if(g.VpnGatewayId) gwNames[g.VpnGatewayId]=gn(g,g.VpnGatewayId)});
  peerings.forEach(g=>{gwNames[g.VpcPeeringConnectionId]=gn(g,g.VpcPeeringConnectionId)});
  tgwAttachments.forEach(g=>{if(g.TransitGatewayId&&!gwNames[g.TransitGatewayId]) gwNames[g.TransitGatewayId]=gn(g,g.TransitGatewayId)});

  // Build Main route table fallback per VPC
  const mainRT={};
  rts.forEach(rt=>{
    if((rt.Associations||[]).some(a=>a.Main)) mainRT[rt.VpcId]=rt;
  });

  // discover gateways from route tables
  rts.forEach(rt=>{
    const hasIgw=(rt.Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
    (rt.Associations||[]).forEach(a=>{if(a.SubnetId){subRT[a.SubnetId]=rt;if(hasIgw)pubSubs.add(a.SubnetId)}});
    (rt.Routes||[]).forEach(r=>{
      if(r.GatewayId&&r.GatewayId!=='local')gwSet.set(r.GatewayId,{type:clsGw(r.GatewayId),id:r.GatewayId,vpcId:rt.VpcId});
      if(r.NatGatewayId)gwSet.set(r.NatGatewayId,{type:'NAT',id:r.NatGatewayId,vpcId:rt.VpcId});
      if(r.TransitGatewayId)gwSet.set(r.TransitGatewayId,{type:'TGW',id:r.TransitGatewayId,vpcId:'shared'});
      if(r.VpcPeeringConnectionId)gwSet.set(r.VpcPeeringConnectionId,{type:'PCX',id:r.VpcPeeringConnectionId,vpcId:'shared'});
    });
  });

  // also pull gateways from dedicated JSON even if not in route tables
  igws.forEach(g=>{if(!gwSet.has(g.InternetGatewayId)){const v=(g.Attachments||[])[0];gwSet.set(g.InternetGatewayId,{type:'IGW',id:g.InternetGatewayId,vpcId:v?v.VpcId:'unk'})}});
  nats.forEach(g=>{if(!gwSet.has(g.NatGatewayId))gwSet.set(g.NatGatewayId,{type:'NAT',id:g.NatGatewayId,vpcId:g.VpcId||'unk'})});
  vpces.forEach(g=>{if(!gwSet.has(g.VpcEndpointId)){const t=g.VpcEndpointType==='Gateway'?'VPCE':'VPCE';gwSet.set(g.VpcEndpointId,{type:'VPCE',id:g.VpcEndpointId,vpcId:g.VpcId||'unk'})}});

  // Assign Main route table to subnets without explicit associations
  subnets.forEach(s=>{
    if(!subRT[s.SubnetId]&&mainRT[s.VpcId]){
      subRT[s.SubnetId]=mainRT[s.VpcId];
      const hasIgw=(mainRT[s.VpcId].Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
      if(hasIgw)pubSubs.add(s.SubnetId);
    }
  });

  const subNacl={};nacls.forEach(n=>(n.Associations||[]).forEach(a=>{if(a.SubnetId)subNacl[a.SubnetId]=n}));
  const sgByVpc={};sgs.forEach(sg=>(sgByVpc[sg.VpcId]=sgByVpc[sg.VpcId]||[]).push(sg));
  const instBySub={};instances.forEach(i=>{if(i.SubnetId)(instBySub[i.SubnetId]=instBySub[i.SubnetId]||[]).push(i)});
  const eniBySub={};enis.forEach(e=>{if(e.SubnetId)(eniBySub[e.SubnetId]=eniBySub[e.SubnetId]||[]).push(e)});
  const albBySub={};albs.forEach(lb=>{(lb.AvailabilityZones||[]).forEach(az=>{if(az.SubnetId)(albBySub[az.SubnetId]=albBySub[az.SubnetId]||[]).push(lb)})});

  // volumes per instance
  const volByInst={};volumes.forEach(v=>{(v.Attachments||[]).forEach(a=>{if(a.InstanceId)(volByInst[a.InstanceId]=volByInst[a.InstanceId]||[]).push(v)})});

  // volumes by subnet (via ENI InstanceId->SubnetId for volumes whose instance isn't in EC2 data)
  const knownInstIds=new Set(instances.map(i=>i.InstanceId));
  const instSubFromEni={};enis.forEach(e=>{if(e.SubnetId&&e.Attachment&&e.Attachment.InstanceId)instSubFromEni[e.Attachment.InstanceId]=e.SubnetId});
  const volBySub={};volumes.forEach(v=>{
    const att=(v.Attachments||[])[0];
    if(att&&att.InstanceId){
      if(knownInstIds.has(att.InstanceId))return; // rendered as EC2 child
      const sid=instSubFromEni[att.InstanceId];
      if(sid)(volBySub[sid]=volBySub[sid]||[]).push(v);
    }
  });

  // snapshots per volume
  const snapByVol={};snapshots.forEach(s=>{if(s.VolumeId)(snapByVol[s.VolumeId]=snapByVol[s.VolumeId]||[]).push(s)});

  // target groups per ALB (by ARN)
  const tgByAlb={};tgs.forEach(tg=>{(tg.LoadBalancerArns||[]).forEach(arn=>{(tgByAlb[arn]=tgByAlb[arn]||[]).push(tg)})});

  // WAF WebACLs per ALB (by ARN)
  const wafByAlb={};wafAcls.forEach(acl=>{(acl.ResourceArns||[]).forEach(arn=>{(wafByAlb[arn]=wafByAlb[arn]||[]).push(acl)})});

  // RDS by subnet
  const rdsBySub={};rdsInstances.forEach(db=>{
    const sg=db.DBSubnetGroup;if(!sg)return;
    (sg.Subnets||[]).forEach(s=>{if(s.SubnetIdentifier)(rdsBySub[s.SubnetIdentifier]=rdsBySub[s.SubnetIdentifier]||[]).push(db)});
  });

  // ECS by subnet
  const ecsBySub={};ecsServices.forEach(svc=>{
    const nc=svc.networkConfiguration?.awsvpcConfiguration;if(!nc)return;
    (nc.subnets||[]).forEach(sid=>{(ecsBySub[sid]=ecsBySub[sid]||[]).push(svc)});
  });

  // Lambda by subnet
  const lambdaBySub={};lambdaFns.forEach(fn=>{
    (fn.VpcConfig?.SubnetIds||[]).forEach(sid=>{(lambdaBySub[sid]=lambdaBySub[sid]||[]).push(fn)});
  });

  // ElastiCache by VPC
  const ecacheByVpc={};ecacheClusters.forEach(c=>{if(c.VpcId)(ecacheByVpc[c.VpcId]=ecacheByVpc[c.VpcId]||[]).push(c)});

  // Redshift by VPC
  const redshiftByVpc={};redshiftClusters.forEach(c=>{if(c.VpcId)(redshiftByVpc[c.VpcId]=redshiftByVpc[c.VpcId]||[]).push(c)});

  // CloudFront origins mapped to ALB ARNs
  const cfByAlb={};cfDistributions.forEach(d=>{
    (d.Origins?.Items||[]).forEach(o=>{
      const matchAlb=albs.find(a=>a.DNSName&&o.DomainName&&o.DomainName.includes(a.DNSName));
      if(matchAlb)(cfByAlb[matchAlb.LoadBalancerArn]=cfByAlb[matchAlb.LoadBalancerArn]||[]).push(d);
    });
  });

  // separate per-VPC vs shared gateways; VPCEs always go to summary only
  const pvGws={},shGws=[],vpceByVpc={},vpceIds=new Set();
  [...gwSet.values()].forEach(gw=>{
    if(gw.type==='VPCE'){(vpceByVpc[gw.vpcId]=vpceByVpc[gw.vpcId]||[]).push(gw);vpceIds.add(gw.id);return}
    if(isShared(gw.type)){if(!shGws.find(g=>g.id===gw.id))shGws.push(gw)}
    else(pvGws[gw.vpcId]=pvGws[gw.vpcId]||[]).push(gw);
  });

  // Check layout mode
  const layoutMode=document.getElementById('layoutMode')?.value||'grid';
  
  if(layoutMode==='landingzone'){
    // LANDING ZONE HUB-SPOKE LAYOUT
    renderLandingZoneMap({
      vpcs,subnets,rts,sgs,nacls,enis,igws,nats,vpces,instances,albs,tgs,peerings,vpns,volumes,snapshots,s3bk,zones,
      subByVpc,pubSubs,subRT,gwSet,subNacl,sgByVpc,instBySub,eniBySub,albBySub,volByInst,volBySub,pvGws,shGws,vpceByVpc,vpceIds,gwNames,
      snapByVol,tgByAlb,wafAcls,wafByAlb,
      rdsInstances,ecsServices,lambdaFns,ecacheClusters,redshiftClusters,tgwAttachments,cfDistributions,
      rdsBySub,ecsBySub,lambdaBySub,ecacheByVpc,redshiftByVpc,cfByAlb
    });
    return;
  }
  
  if(layoutMode==='executive'){
    renderExecutiveOverview({
      vpcs,subnets,rts,sgs,nacls,enis,igws,nats,vpces,instances,albs,tgs,peerings,vpns,volumes,snapshots,s3bk,zones,
      subByVpc,pubSubs,subRT,gwSet,subNacl,sgByVpc,instBySub,eniBySub,albBySub,volByInst,pvGws,shGws,vpceByVpc,vpceIds,gwNames,
      snapByVol,tgByAlb,wafAcls,wafByAlb,
      rdsInstances,ecsServices,lambdaFns,ecacheClusters,redshiftClusters,tgwAttachments,cfDistributions,
      rdsBySub,ecsBySub,lambdaBySub,ecacheByVpc,redshiftByVpc,cfByAlb
    });
    return;
  }

  // GRID LAYOUT (original)

  // layout constants
  const SH_BASE=52,SG=12,VP=30,VH=40,GR=20,MSW=240,CW=6.5;
  const RES_ICON=26,RES_CHILD_H=11,RES_GAP=4,RES_COLS=2,RES_TOP=36,RES_BOT=12;
  
  // Tree context for buildResTree
  const treeCtx={instBySub,albBySub,rdsBySub,ecsBySub,lambdaBySub,volByInst,volBySub,enis,tgByAlb,wafByAlb,cfByAlb,snapByVol,eniBySub};
  
  // Pre-calc resource tree per subnet for sizing
  const subTrees={};
  subnets.forEach(s=>{
    subTrees[s.SubnetId]=buildResTree(s.SubnetId,treeCtx);
  });
  function subHeight(sid2){
    if(_detailLevel===0) return SH_BASE;
    const tree=subTrees[sid2]||[];
    if(!tree.length) return SH_BASE;
    const maxCh=Math.max(0,...tree.map(r=>(r.children||[]).length));
    const tallest=RES_ICON+maxCh*RES_CHILD_H;
    const rowH=tallest+6;
    const rows=Math.ceil(tree.length/RES_COLS);
    return Math.max(SH_BASE, RES_TOP+rows*rowH+RES_BOT+4);
  }
  
  const vSW={};
  vpcs.forEach(v=>{
    const ss=subByVpc[v.VpcId]||[];
    const vpcNameLen=(gn(v,v.VpcId).length+2)*CW+30;
    const cidrLen=((v.CidrBlock||'').length+15)*CW+20;
    let mx=Math.max(MSW,vpcNameLen+cidrLen);
    ss.forEach(s=>{
      const nameW=gn(s,s.SubnetId).length*CW+100;
      if(_detailLevel>0){
        const resCols=Math.min((subTrees[s.SubnetId]||[]).length, RES_COLS);
        const resW=resCols*(RES_ICON+RES_GAP+80)+50;
        mx=Math.max(mx,nameW,resW);
      } else {
        mx=Math.max(mx,nameW);
      }
    });
    vSW[v.VpcId]=Math.min(mx,600);
  });

  const getVpcRegion=(v)=>{
    const ss=subByVpc[v.VpcId]||[];
    const az=ss.find(s=>s.AvailabilityZone)?.AvailabilityZone||'';
    return az.replace(/[a-z]$/,'')||'unknown';
  };
  const knownVpcs=vpcs.filter(v=>getVpcRegion(v)!=='unknown');
  const unknownVpcs=vpcs.filter(v=>getVpcRegion(v)==='unknown');
  
  knownVpcs.sort((a,b)=>getVpcRegion(a).localeCompare(getVpcRegion(b)));

  const GC_BASE=140;
  const vL=[];let cx=60;
  
  // Calculate VPC height with dynamic subnet sizes
  function calcVpcHeight(ss){
    let ih=0;
    ss.forEach((s,i)=>{ih+=subHeight(s.SubnetId)+(i<ss.length-1?SG:0)});
    return Math.max(ih+VP*2+VH+30,150);
  }
  
  // Build subnet layout with cumulative Y positions
  function buildSubLayouts(ss,baseX,baseY,sw){
    const layouts=[];
    let cy=baseY+VH+VP;
    ss.forEach(s=>{
      const sh=subHeight(s.SubnetId);
      layouts.push({sub:s,x:baseX+VP,y:cy,w:sw,h:sh,pub:pubSubs.has(s.SubnetId)});
      cy+=sh+SG;
    });
    return layouts;
  }
  
  knownVpcs.forEach((vpc,idx)=>{
    const ss=subByVpc[vpc.VpcId]||[];
    const sw=vSW[vpc.VpcId]||MSW;
    const vw=sw+VP*2,vh=calcVpcHeight(ss);
    const routingGws=(pvGws[vpc.VpcId]||[]);
    let maxGwNameW=0;
    routingGws.forEach(gw=>{
      const nm=gwNames[gw.id]||sid(gw.id);
      maxGwNameW=Math.max(maxGwNameW,nm.length*6+40);
    });
    const chanW=Math.max(GC_BASE,routingGws.length*55+50,maxGwNameW+60);
    const isLast=idx===knownVpcs.length-1&&knownVpcs.length>1;
    const gwSide=isLast?'left':'right';

    if(isLast){
      // Last VPC: put channel to the LEFT (gateways between this and previous VPC)
      vL.push({vpc,x:cx+chanW,y:80,w:vw,h:vh,sw,chanW,gwSide,
        subs:buildSubLayouts(ss,cx+chanW,80,sw)
      });
      cx+=chanW+vw;
    }else{
      vL.push({vpc,x:cx,y:80,w:vw,h:vh,sw,chanW,gwSide,
        subs:buildSubLayouts(ss,cx,80,sw)
      });
      cx+=vw+chanW;
    }
  });
  
  // Calculate row 2 Y position for unknown VPCs (below all known VPCs + shared gateways area)
  const maxKnownH=vL.length>0?Math.max(...vL.map(v=>v.h)):0;
  const unknownRowY=80+maxKnownH+320;
  let ux=60;
  
  unknownVpcs.forEach((vpc,idx)=>{
    const ss=subByVpc[vpc.VpcId]||[];
    const sw=vSW[vpc.VpcId]||MSW;
    const vw=sw+VP*2,vh=calcVpcHeight(ss);
    const routingGws=(pvGws[vpc.VpcId]||[]);
    let maxGwNameW=0;
    routingGws.forEach(gw=>{
      const nm=gwNames[gw.id]||sid(gw.id);
      maxGwNameW=Math.max(maxGwNameW,nm.length*6+40);
    });
    const chanW=Math.max(GC_BASE,routingGws.length*55+50,maxGwNameW+60);
    const isLast=idx===unknownVpcs.length-1&&unknownVpcs.length>1;
    const gwSide=isLast?'left':'right';

    if(isLast){
      vL.push({vpc,x:ux+chanW,y:unknownRowY,w:vw,h:vh,sw,chanW,gwSide,
        subs:buildSubLayouts(ss,ux+chanW,unknownRowY,sw)
      });
      ux+=chanW+vw;
    }else{
      vL.push({vpc,x:ux,y:unknownRowY,w:vw,h:vh,sw,chanW,gwSide,
        subs:buildSubLayouts(ss,ux,unknownRowY,sw)
      });
      ux+=vw+chanW;
    }
  });

  const W=document.querySelector('.main').clientWidth,H=document.querySelector('.main').clientHeight;
  
  // Center known VPCs (row 1)
  const knownVL=vL.filter(v=>getVpcRegion(v.vpc)!=='unknown');
  const unknownVL=vL.filter(v=>getVpcRegion(v.vpc)==='unknown');
  
  if(knownVL.length>0){
    const knownWidth=cx-60-GC_BASE;
    const offX=Math.max(0,(W-knownWidth)/2-60);
    knownVL.forEach(v=>{v.x+=offX;v.subs.forEach(s=>s.x+=offX)});
  }
  
  // Center unknown VPCs (row 2) independently
  if(unknownVL.length>0){
    const unknownWidth=ux-60-GC_BASE;
    const offX2=Math.max(0,(W-unknownWidth)/2-60);
    unknownVL.forEach(v=>{v.x+=offX2;v.subs.forEach(s=>s.x+=offX2)});
  }

  // Pre-pass: determine which subnets connect to each per-VPC gateway
  // This lets us position gateways near their connected subnets instead of at VPC bottom
  // Uses subRT (which includes Main route table fallback) for complete coverage
  const gwSubnetYs=new Map(); // gwId -> [subnet Y midpoints]
  const preAllS=vL.flatMap(v=>v.subs);
  preAllS.forEach(sl=>{
    const rt=subRT[sl.sub.SubnetId];if(!rt)return;
    (rt.Routes||[]).forEach(r=>{
      if(r.GatewayId==='local')return;
      const tid=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId;
      if(!tid||vpceIds.has(tid))return;
      if(!gwSubnetYs.has(tid))gwSubnetYs.set(tid,[]);
      gwSubnetYs.get(tid).push(sl.y+sl.h/2);
    });
  });

  // per-VPC gateways positioned near connected subnet centroid
  const gwP=new Map();
  const gwOrder={IGW:0,NAT:1,VGW:2,EIGW:3,LGW:4};
  vL.forEach(vl=>{
    const gs=[...(pvGws[vl.vpc.VpcId]||[])].sort((a,b)=>{const oa=gwOrder[a.type]??9,ob=gwOrder[b.type]??9;return oa-ob;});
    const gwOff=Math.max(60,Math.min(vl.chanW*0.7,120));
    const gx=vl.gwSide==='left'?(vl.x-gwOff):(vl.x+vl.w+gwOff);
    const minGap=GR*2+12; // minimum vertical gap between gateway circles

    // Compute ideal Y for each gateway at centroid of its connected subnets
    const gwYs=gs.map(gw=>{
      const subYs=gwSubnetYs.get(gw.id);
      if(subYs&&subYs.length>0){
        const avgY=subYs.reduce((a,b)=>a+b,0)/subYs.length;
        let gy=avgY;
        gy=Math.min(gy, vl.y+vl.h-GR-10);
        gy=Math.max(gy, vl.y+GR+20);
        return {gw,gy};
      }
      return {gw,gy:vl.y+vl.h-GR-10}; // fallback: near bottom
    });

    // Resolve overlaps: push later gateways down if too close
    for(let i=1;i<gwYs.length;i++){
      if(gwYs[i].gy-gwYs[i-1].gy<minGap){
        gwYs[i].gy=gwYs[i-1].gy+minGap;
      }
    }
    // Final clamp to VPC bounds (don't let pushed gateways escape VPC)
    gwYs.forEach(g=>{
      g.gy=Math.min(g.gy, vl.y+vl.h-GR-10);
      g.gy=Math.max(g.gy, vl.y+GR+20);
    });

    gwYs.forEach(({gw,gy})=>gwP.set(gw.id,{x:gx,y:gy,gw}));
  });

  // shared gateways below KNOWN VPCs only (not disconnected)
  const knownVpcBot=knownVL.length>0?Math.max(...knownVL.map(v=>v.y+v.h)):80;
  const lE=knownVL[0]?.x||0,rE=knownVL.length?knownVL[knownVL.length-1].x+knownVL[knownVL.length-1].w:W;
  const sCX=(lE+rE)/2,sY=knownVpcBot+80;
  const ssX=sCX-((shGws.length-1)*80)/2;
  shGws.forEach((gw,i)=>{gwP.set(gw.id,{x:ssX+i*80,y:sY,gw})});
  
  // Track the lowest Y used by routing elements (gateways, bus lanes, peering)
  let routingBottomY=shGws.length>0?(sY+GR+20):(knownVpcBot+20);

  // Disconnected VPCs will be repositioned after all routing is computed

  // internet node positioned far left, anchoring the NET bus bar
  // Only IGWs connect to NET bus bar; NATs have their own subnet route lines
  const iGwList=[...gwP.values()].filter(p=>p.gw.type==='IGW');
  const allVpcRight=Math.max(...vL.map(v=>v.gwSide==='left'?(v.x+v.w):(v.x+v.w+v.chanW)));
  const allVpcLeft=Math.min(...vL.map(v=>v.x));
  const allVpcTop=Math.min(...vL.map(v=>v.y));
  const allVpcBottom=Math.max(...vL.map(v=>v.y+v.h));
  // Position NET node left of all VPCs
  const iX=allVpcLeft-80;
  const iY=allVpcTop-100;

  const allS=vL.flatMap(v=>v.subs);

  // trunk groups -- iterate subnets using subRT (includes Main route table fallback)
  const tG={};
  allS.forEach(sl=>{
    const rt=subRT[sl.sub.SubnetId];if(!rt)return;
    const ov=vL.find(v=>v.subs.includes(sl));if(!ov)return;
    (rt.Routes||[]).forEach(r=>{
      if(r.GatewayId==='local')return;
      const tid=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId;
      if(!tid||!gwP.has(tid)||vpceIds.has(tid))return;
      const k=tid+'|'+ov.vpc.VpcId;
      (tG[k]=tG[k]||[]).push({sl,sid:sl.sub.SubnetId,dst:r.DestinationCidrBlock||r.DestinationPrefixListId||'?',gid:tid,vid:ov.vpc.VpcId});
    });
  });

  // SVG
  const g=svg.append('g').attr('class','map-root');
  const zB=d3.zoom().scaleExtent([.08,5]).on('zoom',e=>{g.attr('transform',e.transform);document.getElementById('zoomLevel').textContent=Math.round(e.transform.k*100)+'%'});svg.call(zB);
  _mapSvg=svg;_mapZoom=zB;_mapG=g;
  bindZoomButtons();

  const lnL=g.append('g').attr('class','lines-layer'); // Routes first (bottom)
  const ndL=g.append('g').attr('class','nodes-layer'); // Nodes on top of routes
  const routeG=lnL.append('g').attr('class','route-group');
  const structG=lnL.append('g').attr('class','struct-group'); // structural route lines at full opacity
  const allLb=[];
  const olL=g.append('g').attr('class','highlight-overlay');
  const labelL=g.append('g').attr('class','label-layer'); // Labels on top of everything

  // Highlight lock state for click-to-toggle
  let _hlLocked=false, _hlKey=null, _hlType=null;
  const lockInd=document.getElementById('hlLockInd');
  function showLockInd(v){lockInd.style.display=v?'block':'none'}
  function setGwHl(gid){
    ndL.selectAll('.gw-node').classed('gw-hl',false);
    if(gid) ndL.selectAll('.gw-node').each(function(){
      const el=d3.select(this);
      if(el.datum&&el.datum()===gid) el.classed('gw-hl',true);
    });
  }
  
  function clonePathToOl(srcEl){
    const s=d3.select(srcEl);
    const op=olL.append('path')
      .attr('d',s.attr('d'))
      .style('stroke',s.attr('stroke'))
      .style('fill',s.attr('fill')||'none')
      .style('stroke-width','4px')
      .style('opacity','1')
      .style('stroke-dasharray','8 5')
      .style('pointer-events','none');
    // Preserve solid style for L-bends, connectors, junctions
    const srcDash=s.style('stroke-dasharray');
    if(srcDash==='none'||s.classed('route-junction')){
      op.style('stroke-dasharray','none').style('stroke-width','3px');
    }
    return op;
  }

  function hlGw(gid){
    olL.selectAll('*').remove();
    routeG.style('opacity','0.03');structG.style('opacity','0.03');
    g.classed('hl-active',true);
    ndL.selectAll('.gw-node').classed('gw-hl',false);
    ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width',null).style('filter',null);});
    ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true);

    // Find all VPCs connected to this gateway and highlight them
    const gwVids=new Set();
    structG.node().querySelectorAll('[data-gid="'+gid+'"][data-vid]').forEach(el=>{
      gwVids.add(el.getAttribute('data-vid'));
    });
    gwVids.forEach(vid=>ndL.selectAll('.vpc-group[data-vpc-id="'+vid+'"]').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');}));

    // Clone ALL structural paths for this gateway into overlay
    let hasNet=false;
    const sNode=structG.node();
    sNode.querySelectorAll('[data-gid="'+gid+'"]').forEach(el=>{
      if(el.hasAttribute('data-net-vert')) hasNet=true;
      clonePathToOl(el);
    });
    // Also clone paths with just data-gid (no data-vid)  e.g. bus-bar-to-gateway verticals
    // (already included above since querySelectorAll matches all with data-gid)

    if(hasNet){
      // Clone NET-vert segments: same X column (above this gateway) + intermediate X columns
      const gp=gwP.get(gid);
      if(gp){
        const gwX=gp.x;
        const gwBotY=gp.y-GR-4;
        sNode.querySelectorAll('[data-net-vert]').forEach(el=>{
          if(el.getAttribute('data-gid')===gid) return; // already cloned above
          const dm=el.getAttribute('d').match(/^M([\d.]+),([-\d.]+)\s*L\1,([-\d.]+)$/);
          if(dm){
            const segX=parseFloat(dm[1]);
            const segBot=Math.max(parseFloat(dm[2]),parseFloat(dm[3]));
            if(Math.abs(segX-gwX)<2){
              // Same X column: only segments above this gateway
              if(segBot<=gwBotY+2) clonePathToOl(el);
            }
          }
        });
      }
      const netLine=sNode.querySelector('[data-net-line]');
      if(netLine&&gp){
        // Trim NET horizontal line from Internet node to this gateway's X only
        const nlD=netLine.getAttribute('d');
        const nlM=nlD.match(/^M([-\d.]+),([-\d.]+)\s*L([-\d.]+),([-\d.]+)$/);
        if(nlM){
          const nlX1=parseFloat(nlM[1]),nlY=parseFloat(nlM[2]),nlX2=parseFloat(nlM[3]);
          const trimX=Math.min(Math.max(nlX1,nlX2),gp.x);
          const trimD=`M${Math.min(nlX1,nlX2)},${nlY} L${trimX},${nlY}`;
          const s=d3.select(netLine);
          olL.append('path').attr('d',trimD)
            .style('stroke',s.attr('stroke')).style('fill','none')
            .style('stroke-width','4px').style('opacity','1')
            .style('stroke-dasharray','8 5').style('pointer-events','none');
        }else{
          clonePathToOl(netLine);
        }
      }else if(netLine){
        clonePathToOl(netLine);
      }
      ndL.selectAll('.internet-node').style('opacity','1');
      // Highlight IGW gateways in the same X column (shared trunk) as this gateway
      if(gp){
        const gwX=gp.x;
        ndL.selectAll('.gw-node').each(function(){
          const c=d3.select(this).select('circle');
          const t=d3.select(this).select('text');
          if(!c.node()||!t.node()) return;
          const cx=parseFloat(c.attr('cx'));
          if(t.text()==='IGW'&&Math.abs(cx-gwX)<2) d3.select(this).classed('gw-hl',true);
        });
      }
    }
    allLb.forEach(l=>l.g.classed('visible',l.gid===gid));
  }
  
  function hlSub(sid){
    const subVpc=vL.find(v=>v.subs.some(s=>s.sub.SubnetId===sid));
    const subVid=subVpc?.vpc.VpcId;
    const subLayout=subVpc?.subs.find(s=>s.sub.SubnetId===sid);
    const subMidY=subLayout?(subLayout.y+subLayout.h/2):null;

    const mg=new Set();
    Object.entries(tG).forEach(([key,cs])=>{
      if(cs.some(c=>c.sid===sid)) mg.add(cs[0].gid);
    });

    olL.selectAll('*').remove();
    routeG.style('opacity','0.03');structG.style('opacity','0.03');
    g.classed('hl-active',true);
    ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width',null).style('filter',null);});
    if(subVid) ndL.selectAll('.vpc-group[data-vpc-id="'+subVid+'"]').each(function(){d3.select(this).select('rect').style('stroke-width','3px').style('filter','drop-shadow(0 0 8px rgba(99,180,255,.7))');});

    if(mg.size===0){
      allLb.forEach(l=>l.g.classed('visible',false));
      return;
    }

    ndL.selectAll('.gw-node').classed('gw-hl',false);
    const sNode=structG.node();

    mg.forEach(gid=>{
      ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true);

      // Find the subnet's route-line Y for this gateway
      const subRouteEl=sNode.querySelector('[data-gid="'+gid+'"][data-sid="'+sid+'"].route-line');
      let subY=subMidY;
      if(subRouteEl){
        const rm=subRouteEl.getAttribute('d').match(/M[\d.]+,([\d.]+)/);
        if(rm) subY=parseFloat(rm[1]);
      }

      // Find the gateway Y (L-bend endpoint or connector point)
      const gp=gwP.get(gid);
      const gwY=gp?gp.y:subY;

      // 1. Clone this subnet's route-lines + junctions for this gateway
      sNode.querySelectorAll('[data-gid="'+gid+'"][data-sid="'+sid+'"]').forEach(el=>clonePathToOl(el));

      // 2. Clone trunk/L-bend/junction paths  but TRIM vertical trunks to subnetgateway range
      // First, find the L-bend/connector Y to use as trim target
      let bendY=gwY;
      sNode.querySelectorAll('[data-gid="'+gid+'"][data-vid="'+subVid+'"]:not([data-sid]):not([data-net-vert])').forEach(el=>{
        if(el.style.strokeDasharray==='none'&&!el.classList.contains('route-junction')){
          // This is the L-bend or L-connector  extract its Y
          const bm=el.getAttribute('d').match(/^M[\d.]+,([\d.]+)/);
          if(bm) bendY=parseFloat(bm[1]);
        }
      });
      sNode.querySelectorAll('[data-gid="'+gid+'"][data-vid="'+subVid+'"]:not([data-sid]):not([data-net-vert])').forEach(el=>{
        const s=d3.select(el);
        const d=el.getAttribute('d');
        const isDashed=el.style.strokeDasharray!=='none'&&!el.classList.contains('route-junction');
        // Detect vertical trunk: M{x},{y1} L{x},{y2} (same X)
        const vm=isDashed&&d.match(/^M([\d.]+),([\d.]+)\s*L\1,([\d.]+)$/);
        if(vm){
          // Trim vertical trunk to span only from subY to the L-bend/connector Y
          const tx=parseFloat(vm[1]);
          const trimTop=Math.min(subY,bendY);
          const trimBot=Math.max(subY,bendY);
          const trimD=`M${tx},${trimTop} L${tx},${trimBot}`;
          olL.append('path').attr('d',trimD)
            .style('stroke',s.attr('stroke')).style('fill','none')
            .style('stroke-width','4px').style('opacity','1')
            .style('stroke-dasharray','8 5').style('pointer-events','none');
        }else{
          clonePathToOl(el);
        }
      });

      // 3. Clone shared gateway paths with no vid (bus-bar-to-gateway verticals)
      sNode.querySelectorAll('[data-gid="'+gid+'"]:not([data-vid]):not([data-net-vert]):not([data-net-line])').forEach(el=>clonePathToOl(el));

      // 4. For IGW: show full path from gateway up to internet node
      // NET verticals are segmented per-gateway, so collect ALL segments
      // at this gateway's X from iY down to the gateway's Y,
      // PLUS intermediate NET-vert segments at other X columns between NET node and this gateway
      if(gp&&gp.gw.type==='IGW'){
        const gwX=gp.x;
        const gwBotY=gp.y-GR-4; // top of gateway circle
        sNode.querySelectorAll('[data-net-vert]').forEach(el=>{
          const dm=el.getAttribute('d').match(/^M([\d.]+),([-\d.]+)\s*L\1,([-\d.]+)$/);
          if(dm){
            const segX=parseFloat(dm[1]);
            const segTop=Math.min(parseFloat(dm[2]),parseFloat(dm[3]));
            const segBot=Math.max(parseFloat(dm[2]),parseFloat(dm[3]));
            if(Math.abs(segX-gwX)<2){
              // Same X column: only segments above or touching the gateway
              if(segTop<=gwBotY+2 && segBot<=gwBotY+2) clonePathToOl(el);
            }
          }
        });
        const netLine=sNode.querySelector('[data-net-line]');
        if(netLine){
          // Trim NET horizontal line to only extend from Internet node to this gateway's X
          const nlD=netLine.getAttribute('d');
          const nlM=nlD.match(/^M([-\d.]+),([-\d.]+)\s*L([-\d.]+),([-\d.]+)$/);
          if(nlM){
            const nlX1=parseFloat(nlM[1]),nlY=parseFloat(nlM[2]),nlX2=parseFloat(nlM[3]);
            const trimX=Math.min(Math.max(nlX1,nlX2),gwX);
            const trimD=`M${Math.min(nlX1,nlX2)},${nlY} L${trimX},${nlY}`;
            const s=d3.select(netLine);
            olL.append('path').attr('d',trimD)
              .style('stroke',s.attr('stroke')).style('fill','none')
              .style('stroke-width','4px').style('opacity','1')
              .style('stroke-dasharray','8 5').style('pointer-events','none');
          }else{
            clonePathToOl(netLine);
          }
        }
        ndL.selectAll('.internet-node').style('opacity','1');
        // Highlight IGW gateways in the same X column (shared trunk) as this gateway
        ndL.selectAll('.gw-node').each(function(){
          const c=d3.select(this).select('circle');
          const t=d3.select(this).select('text');
          if(!c.node()||!t.node()) return;
          const cx=parseFloat(c.attr('cx'));
          if(t.text()==='IGW'&&Math.abs(cx-gwX)<2) d3.select(this).classed('gw-hl',true);
        });
      }
    });
    
    // Position labels based on gateway type
    let labelOffset=0;
    const visibleLabels=[];
    if(subVpc){
      allLb.forEach(l=>{
        const show=mg.has(l.gid)&&(l.shared||l.vid===subVid);
        l.g.classed('visible',show);
        if(show&&subMidY!=null){
          const ly=subMidY+labelOffset;
          let labelX;
          if(l.shared){
            if(subVpc.gwSide==='left'){
              labelX=subVpc.x-(subVpc.chanW||100)/2-40;
            }else{
              labelX=subVpc.x+subVpc.w+(subVpc.chanW||100)/2+40;
            }
          }else{
            const gp=gwP.get(l.gid);
            if(subVpc.gwSide==='left'){
              labelX=gp?gp.x-GR-50:subVpc.x-100;
            }else{
              labelX=gp?gp.x+GR+50:subVpc.x+subVpc.w+100;
            }
          }
          l.g.select('rect').attr('x',labelX-l.lw/2).attr('y',ly-8);
          l.g.select('text').attr('x',labelX).attr('y',ly+3);
          visibleLabels.push({g:l.g,lw:l.lw,x:labelX-l.lw/2,y:ly-8,h:16});
          labelOffset+=22;
        }
      });
      
      // Dynamic collision avoidance: shift labels right if any route lines pass through
      visibleLabels.forEach(vl=>{
        let lx=vl.x,ly=vl.y,lw=vl.lw,lh=vl.h;
        let shifted=false;
        for(let iter=0;iter<5;iter++){
          let maxCrossX=0;
          // Check all route paths (trunks and lines)
          structG.selectAll('.route-trunk,.route-line').each(function(){
            const d=d3.select(this).attr('d')||'';
            // Check vertical lines: M{x},{y1} L{x},{y2}
            const vm=d.match(/M([\d.]+),([\d.]+)\s*L\1,([\d.]+)/);
            if(vm){
              const tx=parseFloat(vm[1]);
              const ty1=Math.min(parseFloat(vm[2]),parseFloat(vm[3]));
              const ty2=Math.max(parseFloat(vm[2]),parseFloat(vm[3]));
              if(tx>=lx&&tx<=lx+lw&&ty1<=ly+lh&&ty2>=ly){
                if(tx>maxCrossX)maxCrossX=tx;
              }
            }
            // Check horizontal lines: M{x1},{y} L{x2},{y}
            const hm=d.match(/M([\d.]+),([\d.]+)\s*L([\d.]+),\2/);
            if(hm){
              const hx1=Math.min(parseFloat(hm[1]),parseFloat(hm[3]));
              const hx2=Math.max(parseFloat(hm[1]),parseFloat(hm[3]));
              const hy=parseFloat(hm[2]);
              if(hy>=ly&&hy<=ly+lh&&hx2>=lx&&hx1<=lx+lw){
                if(hx2>maxCrossX)maxCrossX=hx2;
              }
            }
          });
          if(maxCrossX>0){
            lx=maxCrossX+12;
            shifted=true;
          }else break;
        }
        if(shifted){
          vl.g.select('rect').attr('x',lx);
          vl.g.select('text').attr('x',lx+lw/2);
        }
      });
    }
  }
  function clr(){
    if(_hlLocked) return;
    olL.selectAll('*').remove();routeG.style('opacity',null);structG.style('opacity',null);allLb.forEach(l=>l.g.classed('visible',false));g.classed('hl-active',false);
    ndL.selectAll('.gw-node').classed('gw-hl',false);
    ndL.selectAll('.internet-node').style('opacity',null);
    ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width',null).style('filter',null);});
  }
  function forceClr(){
    _hlLocked=false;_hlKey=null;_hlType=null;showLockInd(false);
    olL.selectAll('*').remove();routeG.style('opacity',null);structG.style('opacity',null);allLb.forEach(l=>l.g.classed('visible',false));g.classed('hl-active',false);
    ndL.selectAll('.gw-node').classed('gw-hl',false);
    ndL.selectAll('.internet-node').style('opacity',null);
    ndL.selectAll('.vpc-group').each(function(){d3.select(this).select('rect').style('stroke-width',null).style('filter',null);});
  }
  // Expose gateway highlight globally for panel link navigation
  window._hlGwGlobal=function(gid){
    forceClr();hlGw(gid);
    ndL.selectAll('.gw-node').classed('gw-hl',false);
    ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true);
    _hlLocked=true;_hlKey=gid;_hlType='gw';showLockInd(true);
  };
  document.addEventListener('hl-unlock',forceClr);
  svg.on('click',function(event){
    if(!event.target.closest('.gw-node')&&!event.target.closest('.subnet-node')&&!event.target.closest('.res-node')&&!event.target.closest('.route-hitarea')&&!event.target.closest('.internet-node')){
      forceClr();
    }
  });

  // Attach route-highlighting to subnet bodies and their resource nodes
  ndL.selectAll('.subnet-node').each(function(){
    const el=d3.select(this);
    const sid=el.attr('data-subnet-id');
    if(!sid)return;
    el.on('mouseenter.hl',function(){if(!_hlLocked)hlSub(sid)})
      .on('mouseleave.hl',function(){if(!_hlLocked)clr()})
      .on('click.hl',function(event){
        if(event.target.closest('.res-node'))return;
        event.stopPropagation();
        if(_hlLocked&&_hlKey===sid&&_hlType==='sub'){forceClr();return}
        forceClr();hlSub(sid);_hlLocked=true;_hlKey=sid;_hlType='sub';showLockInd(true);
      });
    el.selectAll('.res-node')
      .on('mouseenter.hl',function(){if(!_hlLocked)hlSub(sid)})
      .on('mouseleave.hl',function(){if(!_hlLocked)clr()})
      .on('click.hl',function(event){
        event.stopPropagation();
        if(_hlLocked&&_hlKey===sid&&_hlType==='sub'){forceClr();return}
        forceClr();hlSub(sid);_hlLocked=true;_hlKey=sid;_hlType='sub';showLockInd(true);
      });
  });

  // peering lines - horizontal connections between VPC edges, stacked by span
  const peeringG=lnL.append('g').attr('class','peering-group');
  
  const activePeerings = peerings
    .filter(pcx => !pcx.Status || pcx.Status.Code === 'active')
    .map(pcx => {
      const rv = pcx.RequesterVpcInfo?.VpcId, av = pcx.AccepterVpcInfo?.VpcId;
      const v1 = vL.find(v => v.vpc.VpcId === rv), v2 = vL.find(v => v.vpc.VpcId === av);
      if (!v1 || !v2) return null;
      const leftVpc = v1.x < v2.x ? v1 : v2;
      const rightVpc = v1.x < v2.x ? v2 : v1;
      const span = (rightVpc.x) - (leftVpc.x + leftVpc.w);
      return { pcx, leftVpc, rightVpc, span };
    })
    .filter(p => p !== null)
    .sort((a, b) => a.span - b.span); // shortest first = closest to VPCs
  
  const globalMinY = Math.min(...vL.map(v => v.y));
  const laneSpacing = 18;
  
  activePeerings.forEach((p, idx) => {
    const { pcx, leftVpc, rightVpc } = p;
    const pn = gn(pcx, pcx.VpcPeeringConnectionId);
    
    // Each peering gets its own Y lane above VPCs
    // Shortest spans closest to VPCs, longest furthest away
    const y = globalMinY - 20 - idx * laneSpacing;
    
    const stubLen = 15;
    
    // Exit points on VPC tops
    const leftExitX = leftVpc.x + leftVpc.w - stubLen;
    const rightExitX = rightVpc.x + stubLen;
    const leftVpcTopY = leftVpc.y;
    const rightVpcTopY = rightVpc.y;
    
    // Complete path: down from left VPC, across, down to right VPC
    const d = `M${leftExitX},${leftVpcTopY} L${leftExitX},${y} L${rightExitX},${y} L${rightExitX},${rightVpcTopY}`;
    
    peeringG.append('path')
      .attr('class', 'peering-line animated')
      .attr('d', d)
      .attr('stroke', 'var(--pcx-color)');
    
    // Label at midpoint of horizontal segment
    const midX = (leftExitX + rightExitX) / 2;
    const pw = pn.length * 5.5 + 20;
    const pg = lnL.append('g').attr('class','peering-label-g');
    pg.append('rect')
      .attr('x', midX - pw / 2).attr('y', y - 9)
      .attr('width', pw).attr('height', 18).attr('rx', 3)
      .attr('fill', 'rgba(10,14,23,.95)').attr('stroke', '#fb923c').attr('stroke-width', .5);
    pg.append('text')
      .attr('x', midX).attr('y', y + 4)
      .attr('text-anchor', 'middle').attr('font-family', 'IBM Plex Mono')
      .style('font-size','calc(9px * var(--txt-scale,1))').attr('fill', '#fb923c').text(pn);
  });

  // VPN marker
  vpns.forEach(vpn=>{
    if(vpn.State!=='available')return;
    const vgwId=vpn.VpnGatewayId;if(!vgwId||!gwP.has(vgwId))return;
    const pos=gwP.get(vgwId);
    ndL.append('text').attr('x',pos.x).attr('y',pos.y-GR-18).attr('text-anchor','middle').attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','#f97316').text('VPN: '+gn(vpn,'VPN'));
  });

  // route trunks
  const tpv={};
  // Count per-VPC and shared gateways separately for trunk spacing
  const tpvPerVpc={};
  const tpvShared={};
  Object.entries(tG).forEach(([k])=>{
    const parts=k.split('|');
    const gid=parts[0],vid=parts[1];
    const gp=gwP.get(gid);
    if(gp&&isShared(gp.gw.type)){
      tpvShared[vid]=(tpvShared[vid]||0)+1;
    }else{
      tpvPerVpc[vid]=(tpvPerVpc[vid]||0)+1;
    }
    tpv[vid]=(tpv[vid]||0)+1;
  });
  const vtcPerVpc={};
  const vtcPerVpcUp={}; // Counter for UP-going per-VPC gateways
  const vtcPerVpcDown={}; // Counter for DOWN-going per-VPC gateways
  const vtcShared={};
  const lsg=new Set();
  
  // Track bus Y levels per shared gateway for vertical connector
  const sharedGwBusY={};

  // Sort gateway entries by DIRECTION relative to subnets to prevent line crossings
  // Lines going UP (gateway above subnets) get trunk X further LEFT
  // Lines going DOWN (gateway below subnets) get trunk X further RIGHT
  const sortedTgEntries=Object.entries(tG).sort((a,b)=>{
    const connsA=a[1],connsB=b[1];
    const gpA=gwP.get(connsA[0].gid);
    const gpB=gwP.get(connsB[0].gid);
    const vidA=connsA[0].vid,vidB=connsB[0].vid;
    // Group by VPC first
    if(vidA!==vidB)return 0;
    if(!gpA||!gpB)return 0;
    // Calculate average subnet Y for each gateway's connections
    const avgSubYA=connsA.reduce((s,c)=>s+c.sl.y+c.sl.h/2,0)/connsA.length;
    const avgSubYB=connsB.reduce((s,c)=>s+c.sl.y+c.sl.h/2,0)/connsB.length;
    // Direction: negative = going UP, positive = going DOWN
    const dirA=gpA.y-avgSubYA;
    const dirB=gpB.y-avgSubYB;
    // Lines going UP (negative dir) should be LEFT (sorted first)
    // Lines going DOWN (positive dir) should be RIGHT (sorted later)
    return dirA-dirB;
  });

  sortedTgEntries.forEach(([key,conns])=>{
    const gid=conns[0].gid,vid=conns[0].vid;
    const gp=gwP.get(gid);if(!gp)return;
    const gi=gp.gw,col=gcv(gi.type),colH=gch(gi.type);
    const ov=vL.find(v=>v.vpc.VpcId===vid);if(!ov)return;
    conns.sort((a,b)=>a.sl.y-b.sl.y);

    // Separate trunk X for per-VPC vs shared gateways - large gap to avoid visual collision
    const sh=isShared(gi.type);
    const gwLeft=ov.gwSide==='left'; // last VPC: gateways to the left
    const cl=gwLeft?(ov.x-8):(ov.x+ov.w+8);

    // Direction based on gateway type: per-VPC (IGW/NAT) go UP to NET, shared (TGW) go DOWN to bus
    conns.sort((a,b)=>a.sl.y-b.sl.y);
    const goingUp=!sh; // per-VPC gateways route UP, shared gateways route DOWN

    let tx;
    if(sh){
      // Shared gateways (TGW) use trunks close to VPC edge
      const tn=vtcShared[vid]=(vtcShared[vid]||0)+1;
      const nt=tpvShared[vid]||1;
      const sp=Math.max(6,Math.min(10,(ov.chanW*0.1)/Math.max(nt,1)));
      tx=gwLeft?(cl-2-(tn-1)*sp):(cl+2+(tn-1)*sp);
    }else{
      // Per-VPC gateways: UP lines get inner trunks, DOWN lines get outer trunks
      const baseOffset=50;
      const perVpcCount=tpvPerVpc[vid]||1;
      const sp=Math.max(8,Math.min(14,(ov.chanW*0.25)/Math.max(perVpcCount,1)));

      // Separate counters for up vs down
      if(!vtcPerVpcUp[vid])vtcPerVpcUp[vid]=0;
      if(!vtcPerVpcDown[vid])vtcPerVpcDown[vid]=0;

      if(goingUp){
        const tn=++vtcPerVpcUp[vid];
        tx=gwLeft?(cl-baseOffset-(tn-1)*sp):(cl+baseOffset+(tn-1)*sp);
      }else{
        const tn=++vtcPerVpcDown[vid];
        const upCount=Object.keys(tG).filter(k=>{
          const c=tG[k][0];
          if(c.vid!==vid)return false;
          const g=gwP.get(c.gid);
          return g&&!isShared(g.gw.type)&&g.y<avgSubY;
        }).length;
        tx=gwLeft?(cl-baseOffset-(upCount)*sp-(tn-1)*sp):(cl+baseOffset+(upCount)*sp+(tn-1)*sp);
      }
    }

    // Deduplicate connections by subnet ID
    const seenSubs=new Set();
    const uniqueConns=conns.filter(c=>{
      if(seenSubs.has(c.sid))return false;
      seenSubs.add(c.sid);return true;
    });

    // Collect all per-VPC gateway positions for this VPC to avoid crossing them
    const vpcGwPositions=[];
    gwP.forEach((pos,id)=>{
      if(!isShared(pos.gw.type)){
        const ovGw=vL.find(v=>v.subs.some(s=>true)&&pvGws[v.vpc.VpcId]?.some(g=>g.id===id));
        if(ovGw&&ovGw.vpc.VpcId===vid) vpcGwPositions.push(pos);
      }
    });

    uniqueConns.forEach(c=>{
      // Exit from top of subnet if going UP, bottom if going DOWN
      const sy=goingUp?(c.sl.y+6):(c.sl.y+c.sl.h-6);

      // Check if horizontal line would cross any gateway circle (not our own)
      let d;
      if(gwLeft){
        // Left-side gateways: route line goes LEFT from subnet left edge
        const subLeft=c.sl.x;
        const crossingGw=vpcGwPositions.find(g=>g!==gp&&Math.abs(g.y-sy)<GR+8&&g.x<subLeft&&g.x>tx);
        if(crossingGw){
          const jogY=sy<crossingGw.y?(crossingGw.y-GR-10):(crossingGw.y+GR+10);
          d=`M${subLeft},${sy} L${crossingGw.x+GR+6},${sy} L${crossingGw.x+GR+6},${jogY} L${tx},${jogY} L${tx},${sy}`;
        }else{
          d=`M${subLeft},${sy} L${tx},${sy}`;
        }
      }else{
        // Right-side gateways: route line goes RIGHT from subnet right edge
        const subRight=c.sl.x+c.sl.w;
        const crossingGw=vpcGwPositions.find(g=>g!==gp&&Math.abs(g.y-sy)<GR+8&&g.x>subRight&&g.x<tx);
        if(crossingGw){
          const jogY=sy<crossingGw.y?(crossingGw.y-GR-10):(crossingGw.y+GR+10);
          d=`M${subRight},${sy} L${crossingGw.x-GR-6},${sy} L${crossingGw.x-GR-6},${jogY} L${tx},${jogY} L${tx},${sy}`;
        }else{
          d=`M${subRight},${sy} L${tx},${sy}`;
        }
      }
      structG.append('path').attr('class','route-line route-structural').attr('d',d).attr('stroke',col).attr('data-gid',gid).attr('data-vid',vid).attr('data-sid',c.sid);
      // Solid filled square at trunk junction to cover dash-pattern gaps
      const jd=`M${tx-3},${sy-3} L${tx+3},${sy-3} L${tx+3},${sy+3} L${tx-3},${sy+3} Z`;
      structG.append('path').attr('class','route-junction route-structural').attr('d',jd).attr('stroke',col).attr('fill',col).attr('stroke-width',1).style('stroke-dasharray','none').attr('data-gid',gid).attr('data-vid',vid).attr('data-sid',c.sid);
      lnL.append('path').attr('class','route-hitarea').attr('d',d)
        .on('mouseenter',()=>{if(!_hlLocked)hlSub(c.sid)}).on('mouseleave',clr)
        .on('click',function(event){event.stopPropagation();
          if(_hlLocked&&_hlKey===c.sid&&_hlType==='sub'){forceClr();return}
          forceClr();hlSub(c.sid);_hlLocked=true;_hlKey=c.sid;_hlType='sub';showLockInd(true);
        });
    });

    // Trunk Y matches horizontal line positions
    const topY=goingUp?(uniqueConns[0].sl.y+6):(uniqueConns[0].sl.y+uniqueConns[0].sl.h-6);
    const botY=goingUp?(uniqueConns[uniqueConns.length-1].sl.y+6):(uniqueConns[uniqueConns.length-1].sl.y+uniqueConns[uniqueConns.length-1].sl.h-6);
    let lx,ly;

    if(!sh){
      // Per-VPC gateway: trunk spans ALL connected subnets AND gateway, then L-connector
      const gwEdgeX=gwLeft?(gp.x+GR+4):(gp.x-GR-4);

      // Compute actual min/max Y across ALL connected subnets (not just first/last)
      const allSubYs=uniqueConns.map(c=>goingUp?(c.sl.y+6):(c.sl.y+c.sl.h-6));
      // Trunk must cover ALL subnet Ys AND the gateway Y
      const vertTop=Math.min(...allSubYs,gp.y);
      const vertBot=Math.max(...allSubYs,gp.y);

      // Vertical trunk covering full range + L-bend to gateway
      const fullPath=`M${tx},${vertTop} L${tx},${vertBot}`;
      const lbendPath=`M${tx},${gp.y} L${gwEdgeX},${gp.y}`;
      const combinedPath=`M${tx},${vertTop} L${tx},${vertBot} M${tx},${gp.y} L${gwEdgeX},${gp.y}`;
      // Dashed vertical trunk spanning all subnets
      structG.append('path').attr('class','route-trunk route-structural').attr('d',fullPath).attr('stroke',col).attr('data-gid',gid).attr('data-vid',vid);
      // Solid L-bend connector from trunk to gateway
      structG.append('path').attr('class','route-trunk route-structural').attr('d',lbendPath).attr('stroke',col).attr('data-gid',gid).attr('data-vid',vid);
      // Solid patch at L-bend corner
      const bendPatch=`M${tx-3},${gp.y-3} L${tx+3},${gp.y-3} L${tx+3},${gp.y+3} L${tx-3},${gp.y+3} Z`;
      structG.append('path').attr('class','route-junction route-structural').attr('d',bendPatch).attr('stroke',col).attr('fill',col).style('stroke-dasharray','none').attr('data-gid',gid).attr('data-vid',vid);
      lnL.append('path').attr('class','route-hitarea').attr('d',combinedPath)
        .on('mouseenter',()=>{if(!_hlLocked){hlGw(gid);ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true)}}).on('mouseleave',()=>{clr()})
        .on('click',function(event){event.stopPropagation();
          if(_hlLocked&&_hlKey===gid&&_hlType==='gw'){forceClr();return}
          forceClr();hlGw(gid);ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true);
          _hlLocked=true;_hlKey=gid;_hlType='gw';showLockInd(true);
        });

      // Label near the gateway
      lx=gwLeft?(gp.x-GR-10):(gp.x+GR+10);ly=gp.y-GR-12;
    }else{
      // Shared gateway: collect for bus bar routing (drawn later)
      if(!sharedGwBusY[gid]){
        sharedGwBusY[gid]={vpcs:[],col,gp};
      }
      sharedGwBusY[gid].vpcs.push({tx,ov,conns:uniqueConns});
      
      // For shared gateways, label near the trunk line at the last connected subnet
      lx=gwLeft?(tx-4):(tx+4);ly=uniqueConns[uniqueConns.length-1].sl.y+uniqueConns[uniqueConns.length-1].sl.h+10;
    }

    let skip=false;
    if(sh){if(lsg.has(gid))skip=true;else lsg.add(gid)}
    if(!skip){
      const lt=uniqueConns[0].dst+' > '+gi.type,lw=lt.length*5.4+16;
      const lg=labelL.append('g').attr('class','route-label-g');
      lg.append('rect').attr('x',lx-lw/2).attr('y',ly-8).attr('width',lw).attr('height',16).attr('rx',3).attr('fill','rgba(10,14,23,.92)').attr('stroke',colH).attr('stroke-width',.5);
      lg.append('text').attr('x',lx).attr('y',ly+3).attr('text-anchor','middle').attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','500').attr('fill',colH).text(lt);
      allLb.push({gid,vid,shared:sh,lx,lw,g:lg});
    }
  });

  // Draw shared gateway bus routing AFTER all VPCs processed
  Object.entries(sharedGwBusY).forEach(([gid,info])=>{
    const {vpcs:vpcConns,col,gp}=info;
    if(!vpcConns.length)return;

    // Bus bar Y: just enough below VPCs to clear, halfway to the gateway
    const allVpcBotForBus=Math.max(...vpcConns.map(v=>v.ov.y+v.ov.h));
    const busY=allVpcBotForBus+30;

    // Each VPC trunk: dashed trunk spanning subnets + solid connector to bus bar
    vpcConns.forEach(vc=>{
      const uniqueC=vc.conns.sort((a,b)=>a.sl.y-b.sl.y);
      const vpcId=vc.ov.vpc.VpcId;
      const allSubYs=uniqueC.map(c=>c.sl.y+c.sl.h-6);
      const trunkTop=Math.min(...allSubYs);
      const trunkBot=Math.max(...allSubYs);

      // Dashed trunk spanning only connected subnet range
      if(trunkTop!==trunkBot){
        const trunkPath=`M${vc.tx},${trunkTop} L${vc.tx},${trunkBot}`;
        structG.append('path').attr('class','route-trunk route-structural').attr('d',trunkPath).attr('stroke',col).attr('data-gid',gid).attr('data-vid',vpcId);
      }

      // Solid L-connector from bottom of trunk down to bus Y, then horizontal to TGW X
      const connPath=`M${vc.tx},${trunkBot} L${vc.tx},${busY} L${gp.x},${busY}`;
      structG.append('path').attr('class','route-trunk route-structural').attr('d',connPath).attr('stroke',col).attr('data-gid',gid).attr('data-vid',vpcId);
      // Solid patch at trunk-to-connector junction
      const tgwJunc=`M${vc.tx-3},${trunkBot-3} L${vc.tx+3},${trunkBot-3} L${vc.tx+3},${trunkBot+3} L${vc.tx-3},${trunkBot+3} Z`;
      structG.append('path').attr('class','route-junction route-structural').attr('d',tgwJunc).attr('stroke',col).attr('fill',col).style('stroke-dasharray','none').attr('data-gid',gid).attr('data-vid',vpcId);

      // Hitarea covers full path
      const fullPath=`M${vc.tx},${trunkTop} L${vc.tx},${busY} L${gp.x},${busY}`;
      lnL.append('path').attr('class','route-hitarea').attr('d',fullPath)
        .on('mouseenter',()=>{if(!_hlLocked){hlGw(gid);ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true)}}).on('mouseleave',()=>{clr()})
        .on('click',function(event){event.stopPropagation();
          if(_hlLocked&&_hlKey===gid&&_hlType==='gw'){forceClr();return}
          forceClr();hlGw(gid);ndL.selectAll('.gw-node[data-gwid="'+gid+'"]').classed('gw-hl',true);
          _hlLocked=true;_hlKey=gid;_hlType='gw';showLockInd(true);
        });
    });

    // Single vertical from bus bar to gateway circle
    const gwConnect=`M${gp.x},${busY} L${gp.x},${gp.y-GR-4}`;
    structG.append('path').attr('class','route-trunk route-structural').attr('d',gwConnect).attr('stroke',col).attr('data-gid',gid);
  });

  // (Per-VPC verticals to gateway drawn inline above)

  // Find edges for routing
  const allVpcBottomEdge=Math.max(...vL.map(v=>v.y+v.h));

  // IGW/NAT to Internet lines are now drawn with the NET node for proper animation

  // Reposition disconnected VPCs below all routing (gateways, bus lanes, peering)
  if(unknownVL.length>0){
    const newUnkY=routingBottomY+60;
    const oldUnkY=unknownVL[0].y;
    const dy=newUnkY-oldUnkY;
    if(dy!==0){
      unknownVL.forEach(v=>{v.y+=dy;v.subs.forEach(s=>{s.y+=dy})});
    }
    routingBottomY=Math.max(...unknownVL.map(v=>v.y+v.h))+20;
  }

  // Region labels above VPC groups - process known VPCs (row 1) separately from unknown (row 2)
  const vpcRegionMap={};
  vL.forEach(vl=>{
    const ss=subByVpc[vl.vpc.VpcId]||[];
    const az=ss.find(s=>s.AvailabilityZone)?.AvailabilityZone||'';
    const region=az.replace(/[a-z]$/,'')||'unknown';
    vpcRegionMap[vl.vpc.VpcId]=region;
  });
  
  // group consecutive known VPCs by region, draw region background
  let prevRegion='',regionStartX=0,regionVpcs=[];
  const regionGroups=[];
  knownVL.forEach((vl,i)=>{
    const r=vpcRegionMap[vl.vpc.VpcId];
    if(r!==prevRegion&&prevRegion&&regionVpcs.length){
      regionGroups.push({region:prevRegion,vpcs:[...regionVpcs]});
      regionVpcs=[];
    }
    if(regionVpcs.length===0)regionStartX=vl.x;
    regionVpcs.push(vl);
    prevRegion=r;
    if(i===knownVL.length-1&&regionVpcs.length)regionGroups.push({region:r,vpcs:[...regionVpcs]});
  });
  
  // Add unknown VPCs as separate group if any
  if(unknownVL.length>0){
    regionGroups.push({region:'DISCONNECTED',vpcs:unknownVL});
  }
  
  regionGroups.forEach(rg=>{
    const first=rg.vpcs[0],last=rg.vpcs[rg.vpcs.length-1];
    const ry=first.y-30;
    const lastRight=last.gwSide==='left'?(last.x+last.w):(last.x+last.w+last.chanW);
    const rx=first.x-10;
    const rw=lastRight-first.x+20;
    const rh=Math.max(...rg.vpcs.map(v=>v.h))+50;
    // Different styling for disconnected region
    const isDisconnected=rg.region==='DISCONNECTED';
    ndL.append('rect').attr('class','region-boundary').attr('x',rx).attr('y',ry).attr('width',rw).attr('height',rh)
      .attr('fill',isDisconnected?'rgba(239,68,68,.06)':'rgba(59,130,246,.06)')
      .attr('stroke',isDisconnected?'rgba(239,68,68,.3)':'rgba(59,130,246,.15)')
      .attr('stroke-width',1)
      .attr('stroke-dasharray',isDisconnected?'4 2':'none')
      .attr('rx',12);
    ndL.append('text').attr('class','region-label')
      .attr('x',rx+10).attr('y',ry-6)
      .attr('fill',isDisconnected?'var(--accent-red)':'var(--text-muted)')
      .text(rg.region);
  });

  // VPC boxes
  const tt=document.getElementById('tooltip');
  vL.forEach(vl=>{
    const vG=ndL.append('g').attr('class','vpc-group').attr('data-vpc-id',vl.vpc.VpcId);
    vG.append('rect').attr('x',vl.x).attr('y',vl.y).attr('width',vl.w).attr('height',vl.h).attr('fill','rgba(59,130,246,.03)').attr('stroke','var(--vpc-stroke)').attr('stroke-width',1.5);
    const _vpcName=gn(vl.vpc,vl.vpc.VpcId);
    vG.append('text').attr('class','vpc-label').attr('x',vl.x+14).attr('y',vl.y+26)
      .attr('textLength',Math.min(_vpcName.length*8,vl.w*0.55)).attr('lengthAdjust','spacing').text(_vpcName);
    const regionTag=vpcRegionMap[vl.vpc.VpcId]||'';
    vG.append('text').attr('class','vpc-cidr').attr('x',vl.x+vl.w-14).attr('y',vl.y+26).attr('text-anchor','end').text(vl.vpc.CidrBlock+(regionTag?' | '+regionTag:''));
    // show indicator for VPCs with no subnets
    if(vl.subs.length===0){
      vG.append('text').attr('x',vl.x+vl.w/2).attr('y',vl.y+vl.h/2+10).attr('text-anchor','middle').attr('font-family','IBM Plex Mono').style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text('No subnets');
    }
  });

  // subnets
  vL.forEach(vl=>{vl.subs.forEach(sl=>{
    const sG=ndL.append('g').attr('class','subnet-node').attr('data-subnet-id',sl.sub.SubnetId);
    const col=sl.pub?'var(--subnet-public)':'var(--subnet-private)';
    sG.append('rect').attr('x',sl.x).attr('y',sl.y).attr('width',sl.w).attr('height',sl.h).attr('fill',sl.pub?'rgba(6,182,212,.15)':'rgba(139,92,246,.15)').attr('stroke',col).attr('stroke-width',1.2);
    const cid='c-'+sl.sub.SubnetId.replace(/[^a-zA-Z0-9]/g,'');
    sG.append('clipPath').attr('id',cid).append('rect').attr('x',sl.x+6).attr('y',sl.y).attr('width',sl.w-12).attr('height',sl.h);
    const tG2=sG.append('g').attr('clip-path',`url(#${cid})`);
    tG2.append('text').attr('class','subnet-label').attr('x',sl.x+8).attr('y',sl.y+18).text(gn(sl.sub,sl.sub.SubnetId));
    tG2.append('text').attr('class','subnet-cidr').attr('x',sl.x+8).attr('y',sl.y+30).text(sl.sub.CidrBlock+(sl.sub.AvailabilityZone?'  '+sl.sub.AvailabilityZone.slice(-2):''));
    sG.append('text').attr('x',sl.x+sl.w-8).attr('y',sl.y+14).attr('text-anchor','end').attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',col).text(sl.pub?'PUBLIC':'PRIVATE');

    // resource icons inside subnet (tree-based with nesting)
    const tree=subTrees[sl.sub.SubnetId]||[];
    
    if(_detailLevel===0&&tree.length>0){
      // collapsed: show resource count summary
      const counts={};
      tree.forEach(r=>{counts[r.type]=(counts[r.type]||0)+1});
      const summary=Object.entries(counts).map(([t,c])=>c+' '+t).join(', ');
      sG.append('text').attr('x',sl.x+8).attr('y',sl.y+sl.h-6)
        .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('fill','var(--text-muted)').attr('opacity',.5).text(summary);
    } else if(tree.length>0){
      const iconW=Math.max(70,Math.floor((sl.w-16)/RES_COLS)-RES_GAP);
      const maxCh=Math.max(0,...tree.map(r=>(r.children||[]).length));
      const rowH=RES_ICON+maxCh*RES_CHILD_H+6;
      let rx=sl.x+6, ry=sl.y+RES_TOP, rci=0;
      tree.forEach((res,ri)=>{
        if(rci>=RES_COLS){rci=0;rx=sl.x+6;ry+=rowH;}
        const nCh=(res.children||[]).length;
        const iconH=RES_ICON+nCh*RES_CHILD_H;
        // wrap in interactive group
        const rG=sG.append('g').attr('class','res-node');
        const _rx=rx,_ry=ry;
        rG.on('mouseenter',function(event){
          event.stopPropagation();
          if(!_hlLocked) hlSub(sl.sub.SubnetId);
          tt.innerHTML=resTooltipHtml(res,sl.sub.SubnetId,subRT);
          tt.style.display='block';
        }).on('mousemove',function(event){
          positionTooltip(event,tt);
        }).on('mouseleave',function(){
          tt.style.display='none';
        });
        // outer box
        rG.append('rect').attr('x',rx).attr('y',ry).attr('width',iconW).attr('height',iconH)
          .attr('rx',3).attr('fill',res.bg).attr('stroke',res.col).attr('stroke-width',.7);
        // type badge
        rG.append('rect').attr('x',rx).attr('y',ry).attr('width',24).attr('height',iconH)
          .attr('rx',3).attr('fill',res.col).attr('fill-opacity',.3);
        rG.append('text').attr('x',rx+12).attr('y',ry+13).attr('text-anchor','middle')
          .attr('font-family','IBM Plex Mono').style('font-size','calc(6px * var(--txt-scale,1))').attr('font-weight','700')
          .attr('fill',res.col).text(res.type);
        // clip for text overflow
        const nameClip='rc-'+sl.sub.SubnetId.replace(/[^a-zA-Z0-9]/g,'')+'-'+ri;
        rG.append('clipPath').attr('id',nameClip).append('rect')
          .attr('x',rx+26).attr('y',ry).attr('width',iconW-28).attr('height',iconH);
        // name
        rG.append('text').attr('x',rx+28).attr('y',ry+10).attr('clip-path',`url(#${nameClip})`)
          .attr('font-family','IBM Plex Mono').style('font-size','calc(6.5px * var(--txt-scale,1))').attr('font-weight','600')
          .attr('fill','var(--text-primary)').text(res.name);
        // IP
        if(res.ip){
          rG.append('text').attr('x',rx+28).attr('y',ry+20).attr('clip-path',`url(#${nameClip})`)
            .attr('font-family','IBM Plex Mono').style('font-size','calc(5.5px * var(--txt-scale,1))')
            .attr('fill','var(--text-muted)').text(res.ip);
        }
        // state dot
        if(res.state){
          const sc=res.state==='running'?'#10b981':'#ef4444';
          rG.append('circle').attr('cx',rx+iconW-6).attr('cy',ry+6).attr('r',2.5).attr('fill',sc);
        }
        // nested children
        if(nCh>0){
          (res.children||[]).forEach((ch,ci)=>{
            const cy2=ry+RES_ICON-2+ci*RES_CHILD_H;
            const cx2=rx+26,cw=iconW-30,ch2=RES_CHILD_H-2;
            rG.append('rect').attr('x',cx2).attr('y',cy2).attr('width',cw).attr('height',ch2)
              .attr('rx',2).attr('fill',ch.bg).attr('stroke',ch.col).attr('stroke-width',.4);
            rG.append('text').attr('x',cx2+2).attr('y',cy2+ch2/2+2)
              .attr('font-family','IBM Plex Mono').style('font-size','calc(4.5px * var(--txt-scale,1))').attr('font-weight','600')
              .attr('fill',ch.col).text(ch.type);
            rG.append('text').attr('x',cx2+19).attr('y',cy2+ch2/2+2).attr('clip-path',`url(#${nameClip})`)
              .attr('font-family','IBM Plex Mono').style('font-size','calc(4.5px * var(--txt-scale,1))')
              .attr('fill','rgba(255,255,255,.5)').text(ch.name+(ch.detail?' '+ch.detail:''));
          });
        }
        rx+=iconW+RES_GAP;
        rci++;
      });
    } else {
      // empty subnet indicator
      sG.append('text').attr('x',sl.x+sl.w/2).attr('y',sl.y+sl.h/2+4).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)').attr('opacity',.4).text('No resources');
    }

    // click to open detail panel, hover for highlight only
    sG.on('mouseenter',function(){if(!_hlLocked)hlSub(sl.sub.SubnetId)})
    .on('mouseleave',()=>{clr()})
    .on('click',function(event){
      event.stopPropagation();
      const sid2=sl.sub.SubnetId;
      if(_hlLocked&&_hlKey===sid2&&_hlType==='sub'){
        // already locked on this subnet, just open panel
      } else {
        forceClr();hlSub(sid2);
        _hlLocked=true;_hlKey=sid2;_hlType='sub';showLockInd(true);
      }
      _lastRlType=null;_navStack=[];
      openSubnetPanel(sl.sub,vl.vpc.VpcId,{pubSubs,subRT,subNacl,instBySub,eniBySub,albBySub,sgByVpc,volByInst,enis,snapByVol,tgByAlb,wafByAlb,rdsBySub,ecsBySub,lambdaBySub,ecacheByVpc,redshiftByVpc,cfByAlb});
    });
  })});

  // gateway circles -- skip VPCEs (they get summary boxes instead)
  gwP.forEach((pos,id)=>{
    if(vpceIds.has(id))return;
    const gw=pos.gw,gG=ndL.append('g').attr('class','gw-node').attr('data-gwid',id),col=gcv(gw.type);
    gG.append('circle').attr('cx',pos.x).attr('cy',pos.y).attr('r',GR).attr('fill','var(--bg-primary)').attr('stroke',col).attr('stroke-width',2);
    gG.append('text').attr('class','gw-label').attr('x',pos.x).attr('y',pos.y+1).attr('text-anchor','middle').attr('dominant-baseline','middle').attr('fill',col).text(gw.type);
    const nm=gwNames[gw.id];
    if(nm&&nm!==gw.id)gG.append('text').attr('class','gw-name').attr('x',pos.x).attr('y',pos.y-GR-26).attr('text-anchor','middle').text(nm);
    gG.append('text').attr('class','gw-id').attr('x',pos.x).attr('y',pos.y+GR+16).attr('text-anchor','middle').text(sid(gw.id));
    gG.on('mouseenter',function(){
      if(_hlLocked) return;
      hlGw(id);
      ndL.selectAll('.gw-node').classed('gw-hl',false);
      gG.classed('gw-hl',true);
      let h=`<div class="tt-title">${nm||gw.id}</div><div class="tt-sub">${gw.type} | ${gw.id}</div>`;
      const natInfo=nats.find(n=>n.NatGatewayId===gw.id);
      if(natInfo){h+=`<div class="tt-sec"><div class="tt-sh">NAT Gateway</div><div class="tt-r">Subnet: <span class="i">${natInfo.SubnetId||'N/A'}</span></div><div class="tt-r">State: ${natInfo.State||'N/A'}</div></div>`}
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none';clr()})
    .on('click',function(event){
      event.stopPropagation();
      if(_hlLocked&&_hlKey===id&&_hlType==='gw'){forceClr();return}
      forceClr();hlGw(id);
      ndL.selectAll('.gw-node').classed('gw-hl',false);gG.classed('gw-hl',true);
      _hlLocked=true;_hlKey=id;_hlType='gw';showLockInd(true);
      _lastRlType=null;_navStack=[];
      openGatewayPanel(gw.id,gw.type,{gwNames,igws,nats,vpns,vpces,peerings,rts,subnets,subRT,pubSubs,vpcs,tgwAttachments});
    });
  });

  // internet node - positioned at top-left
  if(iGwList.length){
    const iG=ndL.append('g').attr('class','internet-node');
    // Outer glow
    iG.append('circle').attr('cx',iX).attr('cy',iY).attr('r',42)
      .attr('fill','none').attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.15);
    // Main circle
    iG.append('circle').attr('cx',iX).attr('cy',iY).attr('r',36)
      .attr('fill','rgba(16,185,129,.06)').attr('stroke','var(--igw-color)').attr('stroke-width',2);
    // Globe effect
    iG.append('ellipse').attr('cx',iX).attr('cy',iY).attr('rx',22).attr('ry',36)
      .attr('fill','none').attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.25);
    iG.append('line').attr('x1',iX-36).attr('y1',iY).attr('x2',iX+36).attr('y2',iY)
      .attr('stroke','var(--igw-color)').attr('stroke-width',1).attr('opacity',.25);
    // Text inside circle
    iG.append('text').attr('x',iX).attr('y',iY+4).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(13px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','var(--igw-color)').text('NET');
    // Text below circle
    iG.append('text').attr('x',iX).attr('y',iY+50).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text('Internet');
    iG.append('text').attr('x',iX).attr('y',iY+62).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--igw-color)').text(iGwList.length+' Gateway'+(iGwList.length>1?'s':''));
    
    // Draw NET connections: L-shaped paths from bus-bar to each IGW.
    // Each IGW gets its own L-bend: horizontal from NET node at bus-bar Y,
    // then vertical down to IGW. No continuous bus bar  eliminates dead ends.
    const connectedIgwIds=new Set(Object.keys(tG).map(k=>k.split('|')[0]));
    const connectedIgwList=iGwList.filter(p=>connectedIgwIds.has(p.gw.id));
    // Group by X to handle stacked gateways at same position
    const netXGroups=new Map();
    connectedIgwList.forEach(pos=>{
      const gx=pos.x;
      if(!netXGroups.has(gx)) netXGroups.set(gx,[]);
      netXGroups.get(gx).push(pos);
    });
    // Collect X positions that reach bus-bar Y, sorted left to right
    const netXPositions=[];
    netXGroups.forEach((group,gx)=>{
      group.sort((a,b)=>(a.y-GR-4)-(b.y-GR-4));
      let reachesBus=false;
      for(let i=0;i<group.length;i++){
        const topY=i===0?iY:(group[i-1].y-GR-4);
        const botY=group[i].y-GR-4;
        const col='var(--igw-color)';
        if(Math.abs(botY-topY)>2){
          structG.append('path')
            .attr('class','route-trunk route-structural')
            .attr('d',`M${gx},${topY} L${gx},${botY}`)
            .attr('stroke',col).attr('stroke-width',3)
            .attr('data-gid',group[i].gw.id).attr('data-net-vert','1');
          if(topY===iY) reachesBus=true;
        }
      }
      if(reachesBus) netXPositions.push(gx);
    });
    netXPositions.sort((a,b)=>a-b);
    // Draw one horizontal bus from NET node to rightmost IGW column
    if(netXPositions.length>0){
      const rightmostNetX=netXPositions[netXPositions.length-1];
      structG.append('path')
        .attr('class','route-trunk route-structural')
        .attr('d',`M${iX+38},${iY} L${rightmostNetX},${iY}`)
        .attr('stroke','var(--igw-color)').attr('stroke-width',3)
        .attr('data-net-line','1');
    }
  }

  // VPCE summary nodes - positioned at bottom-left of VPC
  vL.forEach(vl=>{
    const vpcVpces=vpceByVpc[vl.vpc.VpcId]||[];
    if(!vpcVpces.length)return;
    const nw=70,nh=16;
    // Position at bottom-left inside VPC
    const gx=vl.x+nw/2+8;
    const ny=vl.y+vl.h-nh-8;
    const eG=ndL.append('g').attr('class','vpce-summary').style('cursor','pointer');
    eG.append('rect').attr('x',gx-nw/2).attr('y',ny).attr('width',nw).attr('height',nh).attr('rx',3)
      .attr('fill','rgba(167,139,250,.2)').attr('stroke','var(--vpce-color)').attr('stroke-width',1);
    eG.append('text').attr('x',gx).attr('y',ny+12).attr('text-anchor','middle').attr('font-family','IBM Plex Mono')
      .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','var(--vpce-color)').text(vpcVpces.length+' VPCE');
    // tooltip on hover
    eG.on('mouseenter',function(){
      let h='<div class="tt-title">VPC Endpoints ('+vpcVpces.length+')</div>';
      h+='<div class="tt-sub">'+gn(vl.vpc,vl.vpc.VpcId)+'</div>';
      h+='<div class="tt-sec"><div class="tt-sh">Endpoints</div>';
      vpcVpces.forEach(v=>{
        const vi=vpces.find(x=>x.VpcEndpointId===v.id);
        const svc=vi?.ServiceName||'?';
        const nm=gwNames[v.id];
        h+='<div class="tt-r"><span class="i">'+(nm||sid(v.id))+'</span> '+svc.split('.').pop()+' ['+vi?.VpcEndpointType+']</div>';
      });
      h+='</div>';
      tt.innerHTML=h;tt.style.display='block';
    }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
    .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('Endpoints')});
  });

  // Private zone VPC badges - positioned at bottom-right of VPC
  let dnsBoxH=0;
  if(zones.length>0){
    const privZonesByVpc={};
    zones.forEach(z=>{
      if(z.Config?.PrivateZone&&z.VPCs){
        z.VPCs.forEach(v=>{
          const vid=v.VPCId||v.VpcId;
          if(vid)(privZonesByVpc[vid]=privZonesByVpc[vid]||[]).push(z);
        });
      }
    });
    vL.forEach(vl=>{
      const pz=privZonesByVpc[vl.vpc.VpcId];
      if(!pz||!pz.length)return;
      // Skip VPCs without valid layout - must have reasonable size and position
      if(!vl.w||vl.w<50||!vl.h||vl.h<50) return;
      // Skip if position is clearly wrong (too far from diagram area)
      if(vl.x<0||vl.y<0||vl.x>10000||vl.y>10000) return;
      // Skip unknown/disconnected VPCs
      if(unknownVL.includes(vl)) return;
      // Skip VPCs with no subnets rendered
      if(!vl.subs||vl.subs.length===0) return;
      const nw=70,nh=16;
      // Position badge at bottom-right of VPC (inside the VPC box)
      const gx=vl.x+vl.w-nw/2-8;
      const ny=vl.y+vl.h-nh-8;
      const dG=ndL.append('g').attr('class','dns-summary').style('cursor','pointer');
      dG.append('rect').attr('x',gx-nw/2).attr('y',ny).attr('width',nw).attr('height',nh).attr('rx',3)
        .attr('fill','rgba(14,165,233,.15)').attr('stroke','#0ea5e9').attr('stroke-width',1);
      dG.append('text').attr('x',gx).attr('y',ny+12).attr('text-anchor','middle').attr('font-family','IBM Plex Mono')
        .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','#0ea5e9').text(pz.length+' DNS');
      dG.on('mouseenter',function(){
        let h='<div class="tt-title">Private Hosted Zones ('+pz.length+')</div>';
        h+='<div class="tt-sub">'+gn(vl.vpc,vl.vpc.VpcId)+'</div>';
        h+='<div class="tt-sec"><div class="tt-sh">Zones</div>';
        pz.forEach(z=>{
          const zid=z.Id.replace('/hostedzone/','');
          h+='<div class="tt-r"><span class="i">'+z.Name+'</span> '+z.ResourceRecordSetCount+' records ['+zid+']</div>';
        });
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('R53')});
    });

    // DNS Zone section - positioned below all routing elements
    const dnsY=routingBottomY+40;
    const pubZones=zones.filter(z=>!z.Config?.PrivateZone);
    const privZones=zones.filter(z=>z.Config?.PrivateZone);
    const dnsBoxW=Math.max(320,allVpcRight-60);
    const dnsRecExp=_dnsRecordsExpanded;
    const recRowH=14;

    // Pre-calculate zone heights and positions
    const zoneLayouts=[];
    if(dnsRecExp){
      // Records expanded: single column, metadata + records nested inside
      const fullW=dnsBoxW-40;
      let cy=0;
      zones.forEach(z=>{
        const zid=z.Id.replace('/hostedzone/','');
        const isPub=!z.Config?.PrivateZone;
        const zRecs=recsByZoneMap[zid]||[];
        const assocVpcs=(!isPub&&z.VPCs)?z.VPCs.map(v=>{const vid=v.VPCId||v.VpcId;const vpc=vpcs.find(vp=>vp.VpcId===vid);return gn(vpc||{},vid)}).join(', '):'';
        let metaLines=2;
        if(assocVpcs)metaLines++;
        const headerH=18+metaLines*14+4;
        const recsH=zRecs.length>0?(4+zRecs.length*recRowH):16;
        const zh=headerH+recsH+6;
        zoneLayouts.push({x:70,y:cy,w:fullW,h:zh,recs:zRecs,assocVpcs});
        cy+=zh+6;
      });
    }else{
      // Default: 2-column compact zones with record count
      const colW2=Math.min(450,(dnsBoxW-40)/2);
      zones.forEach((z,zi)=>{
        const col=zi%2;
        const row=Math.floor(zi/2);
        zoneLayouts.push({x:70+col*(colW2+10),y:row*32,w:colW2-10,h:26,recs:[]});
      });
    }
    const totalContentH=dnsRecExp?
      (zoneLayouts.length>0?zoneLayouts[zoneLayouts.length-1].y+zoneLayouts[zoneLayouts.length-1].h:0):
      (Math.ceil(zones.length/2)*32);
    dnsBoxH=60+totalContentH+20;

    const dnsG=ndL.append('g').attr('class','dns-section');

    // Section container
    dnsG.append('rect').attr('x',60).attr('y',dnsY).attr('width',dnsBoxW).attr('height',dnsBoxH).attr('rx',8)
      .attr('fill','rgba(14,165,233,.06)').attr('stroke','#0ea5e9').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');

    // Section title
    dnsG.append('text').attr('x',80).attr('y',dnsY+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#0ea5e9').text('Route 53 Hosted Zones');
    dnsG.append('text').attr('x',80).attr('y',dnsY+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(pubZones.length+' public, '+privZones.length+' private');

    // Records expand/collapse toggle button
    const togX=60+dnsBoxW-80;
    const togY=dnsY+8;
    const togG=dnsG.append('g').style('cursor','pointer');
    togG.append('rect').attr('x',togX).attr('y',togY).attr('width',70).attr('height',20).attr('rx',4)
      .attr('fill','rgba(14,165,233,.15)').attr('stroke','#0ea5e9').attr('stroke-width',0.8);
    togG.append('text').attr('x',togX+35).attr('y',togY+14).attr('text-anchor','middle')
      .attr('font-family','IBM Plex Mono').style('font-size','calc(8px * var(--txt-scale,1))').attr('font-weight','600')
      .attr('fill','#0ea5e9').text(dnsRecExp?'\u25B2 Collapse':'\u25BC Expand');
    togG.on('click',function(event){
      event.stopPropagation();
      _dnsRecordsExpanded=!_dnsRecordsExpanded;
      renderMap();
    });

    const colW=Math.min(450,(dnsBoxW-40)/2);

    zones.forEach((z,zi)=>{
      const isPub=!z.Config?.PrivateZone;
      const zid=z.Id.replace('/hostedzone/','');
      const lay=zoneLayouts[zi];
      const zx=lay.x;
      const zy=dnsY+52+lay.y;
      const zw=lay.w;
      const zh=lay.h;

      const zG=dnsG.append('g').style('cursor','pointer');
      zG.append('rect').attr('x',zx).attr('y',zy).attr('width',zw).attr('height',zh).attr('rx',4)
        .attr('fill',isPub?'rgba(16,185,129,.18)':'rgba(14,165,233,.18)')
        .attr('stroke',isPub?'#10b981':'#0ea5e9').attr('stroke-width',1.5);

      // Icon indicator
      zG.append('circle').attr('cx',zx+12).attr('cy',zy+13).attr('r',6)
        .attr('fill',isPub?'#10b981':'#0ea5e9');
      zG.append('text').attr('x',zx+12).attr('y',zy+16.5).attr('text-anchor','middle')
        .attr('font-family','IBM Plex Mono').style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','700')
        .attr('fill','#fff').text(isPub?'P':'R');

      // Zone name (full in expanded, truncated in compact)
      const dispName=dnsRecExp?z.Name:(z.Name.length>35?z.Name.substring(0,33)+'..':z.Name);
      zG.append('text').attr('x',zx+24).attr('y',zy+15).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',isPub?'#10b981':'#0ea5e9')
        .text(dispName);

      // Compact: record count only
      if(!dnsRecExp){
        zG.append('text').attr('x',zx+zw).attr('y',zy+15).attr('text-anchor','end')
          .attr('font-family','IBM Plex Mono').style('font-size','calc(9px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
          .text(z.ResourceRecordSetCount+' rec');
      }

      // Records expanded: metadata lines + record rows
      if(dnsRecExp){
        let my=zy+18;
        // Metadata: Zone ID
        zG.append('text').attr('x',zx+24).attr('y',my+14).attr('font-family','IBM Plex Mono')
          .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
          .text('Zone ID: '+zid+'  |  '+z.ResourceRecordSetCount+' records  |  '+(isPub?'Public':'Private'));
        my+=14;
        // Metadata: Associated VPCs (if private)
        if(lay.assocVpcs){
          zG.append('text').attr('x',zx+24).attr('y',my+14).attr('font-family','IBM Plex Mono')
            .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
            .text('VPCs: '+lay.assocVpcs);
          my+=14;
        }

        // Record sets (if available)
        if(lay.recs.length>0){
          my+=4;
          zG.append('line').attr('x1',zx+8).attr('y1',my).attr('x2',zx+zw-8).attr('y2',my)
            .attr('stroke',isPub?'#10b981':'#0ea5e9').attr('stroke-width',0.5).attr('stroke-opacity',0.4);
          my+=4;
          lay.recs.forEach(rec=>{
            const rName=(rec.Name||'').replace(/\.$/,'');
            const rType=rec.Type||'';
            const rVal=rec.AliasTarget?'ALIAS \u2192 '+(rec.AliasTarget.DNSName||'').replace(/\.$/,''):
              (rec.ResourceRecords||[]).map(rr=>rr.Value).join(', ');
            zG.append('text').attr('x',zx+10).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(7px * var(--txt-scale,1))').attr('font-weight','600').attr('fill',isPub?'#059669':'#0284c7')
              .text(rType);
            zG.append('text').attr('x',zx+50).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-primary)')
              .text(rName.length>50?rName.substring(0,48)+'..':rName);
            zG.append('text').attr('x',zx+350).attr('y',my+10).attr('font-family','IBM Plex Mono')
              .style('font-size','calc(7px * var(--txt-scale,1))').attr('fill','var(--text-muted)')
              .text(rVal.length>80?rVal.substring(0,78)+'..':rVal);
            my+=recRowH;
          });
        }else{
          my+=6;
          zG.append('text').attr('x',zx+24).attr('y',my+10).attr('font-family','IBM Plex Mono')
            .style('font-size','calc(8px * var(--txt-scale,1))').attr('font-style','italic').attr('fill','var(--text-muted)')
            .text('Click zone for details \u2022 Load record sets via "Record Sets" input');
        }
      }

      // Tooltip (always)
      zG.on('mouseenter',function(){
        let h='<div class="tt-title">'+(isPub?'Public':'Private')+' Hosted Zone</div>';
        h+='<div class="tt-sub">'+z.Name+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">Zone ID</span> '+zid+'</div>';
        h+='<div class="tt-r"><span class="i">Records</span> '+z.ResourceRecordSetCount+'</div>';
        h+='<div class="tt-r"><span class="i">Type</span> '+(isPub?'Public':'Private')+'</div>';
        if(!isPub&&z.VPCs&&z.VPCs.length>0){
          h+='<div class="tt-sh" style="margin-top:6px">Associated VPCs</div>';
          z.VPCs.forEach(v=>{
            const vid=v.VPCId||v.VpcId;
            const vpc=vpcs.find(vp=>vp.VpcId===vid);
            h+='<div class="tt-r"><span class="i">'+gn(vpc||{},vid)+'</span> '+vid+'</div>';
          });
        }
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('R53')});
    });
  }

  // S3 Buckets section - positioned below DNS section (or below routing if no DNS)
  const dnsExists=zones.length>0;
  const dnsBase=routingBottomY+40;
  const dnsSectionH=dnsExists?dnsBoxH:0;
  let sectionBottomY=dnsExists?(dnsBase+dnsSectionH):(routingBottomY);
  if(s3bk.length>0){
    const s3Y=sectionBottomY+40;
    const s3BoxW=Math.max(320,allVpcRight-60);
    const s3Cols=3;
    const s3ColW=Math.min(320,(s3BoxW-40)/s3Cols);
    const s3RowH=24;
    const s3Rows=Math.ceil(s3bk.length/s3Cols);
    const s3BoxH=50+s3Rows*(s3RowH+4)+20;
    
    const s3G=ndL.append('g').attr('class','s3-section');
    s3G.append('rect').attr('x',60).attr('y',s3Y).attr('width',s3BoxW).attr('height',s3BoxH).attr('rx',8)
      .attr('fill','rgba(234,88,12,.04)').attr('stroke','#ea580c').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');
    s3G.append('text').attr('x',80).attr('y',s3Y+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#ea580c').text('S3 Buckets');
    s3G.append('text').attr('x',80).attr('y',s3Y+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(s3bk.length+' buckets');
    
    s3bk.forEach((bk,bi)=>{
      const col=bi%s3Cols;
      const row=Math.floor(bi/s3Cols);
      const bx=70+col*(s3ColW+5);
      const by=s3Y+48+row*(s3RowH+4);
      
      const bG=s3G.append('g').style('cursor','pointer');
      bG.append('rect').attr('x',bx).attr('y',by).attr('width',s3ColW-10).attr('height',s3RowH).attr('rx',3)
        .attr('fill','rgba(234,88,12,.1)').attr('stroke','#ea580c').attr('stroke-width',0.8);
      
      const maxChars=Math.floor((s3ColW-20)/6);
      const dispName=bk.Name.length>maxChars?bk.Name.substring(0,maxChars-2)+'..':bk.Name;
      bG.append('text').attr('x',bx+6).attr('y',by+16).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(10px * var(--txt-scale,1))').attr('font-weight','500').attr('fill','#ea580c').text(dispName);
      
      bG.on('mouseenter',function(){
        let h='<div class="tt-title">S3 Bucket</div>';
        h+='<div class="tt-sub">'+bk.Name+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">Created</span> '+(bk.CreationDate||'N/A').split('T')[0]+'</div>';
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('S3')});
    });
    sectionBottomY=s3Y+s3BoxH;
  }

  // CloudFront distributions section
  if(cfDistributions.length>0){
    const cfY=sectionBottomY+40;
    const cfBoxW=Math.max(320,allVpcRight-60);
    const cfCols=2;
    const cfColW=Math.min(480,(cfBoxW-40)/cfCols);
    const cfRowH=28;
    const cfRows=Math.ceil(cfDistributions.length/cfCols);
    const cfBoxH=50+cfRows*(cfRowH+4)+20;

    const cfG=ndL.append('g').attr('class','cf-section');
    cfG.append('rect').attr('x',60).attr('y',cfY).attr('width',cfBoxW).attr('height',cfBoxH).attr('rx',8)
      .attr('fill','rgba(139,92,246,.06)').attr('stroke','#8b5cf6').attr('stroke-width',1.5).attr('stroke-dasharray','6 3');
    cfG.append('text').attr('x',80).attr('y',cfY+22).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(14px * var(--txt-scale,1))').attr('font-weight','700').attr('fill','#8b5cf6').text('CloudFront Distributions');
    cfG.append('text').attr('x',80).attr('y',cfY+36).attr('font-family','IBM Plex Mono')
      .style('font-size','calc(10px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(cfDistributions.length+' distributions');

    cfDistributions.forEach((d,di)=>{
      const col=di%cfCols;
      const row=Math.floor(di/cfCols);
      const cx=70+col*(cfColW+5);
      const cy=cfY+48+row*(cfRowH+4);
      const aliases=(d.Aliases?.Items||[]);

      const cG=cfG.append('g').style('cursor','pointer');
      cG.append('rect').attr('x',cx).attr('y',cy).attr('width',cfColW-10).attr('height',cfRowH).attr('rx',3)
        .attr('fill','rgba(139,92,246,.12)').attr('stroke','#8b5cf6').attr('stroke-width',0.8);
      cG.append('text').attr('x',cx+6).attr('y',cy+12).attr('font-family','IBM Plex Mono')
        .style('font-size','calc(9px * var(--txt-scale,1))').attr('font-weight','600').attr('fill','#8b5cf6').text(d.DomainName||d.Id);
      if(aliases.length){
        cG.append('text').attr('x',cx+6).attr('y',cy+23).attr('font-family','IBM Plex Mono')
          .style('font-size','calc(8px * var(--txt-scale,1))').attr('fill','var(--text-muted)').text(aliases.join(', '));
      }

      cG.on('mouseenter',function(){
        let h='<div class="tt-title">CloudFront Distribution</div>';
        h+='<div class="tt-sub">'+(d.DomainName||d.Id)+'</div>';
        h+='<div class="tt-sec">';
        h+='<div class="tt-r"><span class="i">ID</span> '+d.Id+'</div>';
        h+='<div class="tt-r"><span class="i">Status</span> '+(d.Status||'?')+'</div>';
        if(aliases.length)h+='<div class="tt-r"><span class="i">Aliases</span> '+aliases.join(', ')+'</div>';
        const origins=(d.Origins?.Items||[]);
        if(origins.length){
          h+='<div class="tt-sh" style="margin-top:4px">Origins</div>';
          origins.forEach(o=>{h+='<div class="tt-r"><span class="i">'+(o.Id||'')+'</span> '+o.DomainName+'</div>'});
        }
        if(d.WebACLId)h+='<div class="tt-r"><span class="i">WAF</span> '+d.WebACLId.split('/').pop()+'</div>';
        h+='</div>';
        tt.innerHTML=h;tt.style.display='block';
      }).on('mousemove',function(event){positionTooltip(event,tt)}).on('mouseleave',()=>{tt.style.display='none'})
      .on('click',function(event){event.stopPropagation();tt.style.display='none';_lastRlType=null;_navStack=[];openResourceList('CF')});
    });
  }

  // stats bar
  _rlCtx={vpcs,subnets,pubSubs,rts,sgs,nacls,enis,igws,nats,vpces,instances,albs,tgs,peerings,vpns,volumes,snapshots,s3bk,zones,wafAcls,wafByAlb,tgByAlb,cfByAlb,rdsInstances,ecsServices,lambdaFns,ecacheClusters,redshiftClusters,cfDistributions,instBySub,albBySub,eniBySub,rdsBySub,ecsBySub,lambdaBySub,subRT,subNacl,sgByVpc,volByInst,snapByVol,ecacheByVpc,redshiftByVpc,tgwAttachments,recsByZone:recsByZoneMap};
  const sb2=document.getElementById('statsBar');sb2.innerHTML='';sb2.style.display='flex';
  [{l:'VPCs',v:vpcs.length},{l:'Subnets',v:subnets.length},{l:'Public',v:pubSubs.size},{l:'Private',v:subnets.length-pubSubs.size},{l:'Gateways',v:gwSet.size},{l:'RTs',v:rts.length},{l:'NACLs',v:nacls.length},{l:'SGs',v:sgs.length},{l:'EC2',v:instances.length},{l:'ENIs',v:enis.length},{l:'ALBs',v:albs.length},{l:'TGs',v:tgs.length},{l:'RDS',v:rdsInstances.length},{l:'ECS',v:ecsServices.length},{l:'Lambda',v:lambdaFns.length},{l:'Cache',v:ecacheClusters.length},{l:'Redshift',v:redshiftClusters.length},{l:'Peering',v:peerings.length},{l:'VPNs',v:vpns.length},{l:'Endpoints',v:vpces.length},{l:'Volumes',v:volumes.length},{l:'Snapshots',v:snapshots.length},{l:'S3',v:s3bk.length},{l:'R53',v:zones.length},{l:'WAF',v:wafAcls.length},{l:'CF',v:cfDistributions.length}].forEach(s=>{
    if(s.v>0){const c=document.createElement('div');c.className='stat-chip';c.dataset.type=s.l;c.innerHTML=`<b>${s.v}</b>${s.l}`;c.addEventListener('click',()=>openResourceList(s.l));sb2.appendChild(c)}
  });
  // Compliance chip (grid layout)
  try{const findings=runComplianceChecks(_rlCtx);if(findings.length)addComplianceChip(sb2,findings)}catch(ce){console.warn('Compliance check error:',ce)}
  document.getElementById('legend').style.display='flex';
  document.getElementById('exportBar').style.display='flex';
  setTimeout(()=>d3.select('#zoomFit').dispatch('click'),100);
  }catch(e){console.error('renderMap error:',e);alert('Render error: '+e.message);document.getElementById('loadingOverlay').style.display='none'}
}

document.getElementById('renderBtn').addEventListener('click',renderMap);

// Design mode toggle
document.getElementById('designToggle').addEventListener('click',()=>{
  if(_designMode)exitDesignMode();else enterDesignMode();
});

// Export bar collapse toggle
document.getElementById('ebToggle').addEventListener('click',function(){
  const eb=document.getElementById('exportBar');
  eb.classList.toggle('collapsed');
  this.innerHTML=eb.classList.contains('collapsed')?'Export &#9654;':'Export &#9660;';
});

// Highlight lock indicator click to unlock
document.getElementById('hlLockInd').addEventListener('click',function(){
  document.dispatchEvent(new CustomEvent('hl-unlock'));
});

// detail panel close handlers
document.getElementById('dpClose').addEventListener('click',()=>{
  document.getElementById('detailPanel').classList.remove('open');
});
document.getElementById('dpBody').addEventListener('click',function(e){
  const c=e.target.closest('.copyable');
  if(c){e.stopPropagation();copyText(c.dataset.copy||c.textContent.trim());return}
  const v=e.target.closest('.dp-kv .v');
  if(v&&v.textContent.trim()){e.stopPropagation();copyText(v.textContent.trim())}
});
document.querySelector('.main').addEventListener('click',function(e){
  if(!e.target.closest('.detail-panel')&&!e.target.closest('.subnet-node')&&!e.target.closest('.gw-node')&&!e.target.closest('.lz-gw-node')&&!e.target.closest('.lz-tgw-node')&&!e.target.closest('.export-bar')&&!e.target.closest('.zoom-controls')&&!e.target.closest('.stats-bar')){
    document.getElementById('detailPanel').classList.remove('open');
  }
});

// detail panel text size
let dpScale=_prefs.dpScale||1.0;
function applyDpScale(){
  document.documentElement.style.setProperty('--dp-txt-scale',dpScale);
}
if(_prefs.dpScale) applyDpScale();
document.getElementById('dpSizeUp').addEventListener('click',()=>{dpScale=Math.min(2.0,dpScale+0.15);applyDpScale();savePrefs({dpScale})});
document.getElementById('dpSizeDown').addEventListener('click',()=>{dpScale=Math.max(0.5,dpScale-0.15);applyDpScale();savePrefs({dpScale})});
document.getElementById('dpSizeReset').addEventListener('click',()=>{dpScale=1.0;applyDpScale();savePrefs({dpScale})});

// filename-to-input mapping
const fileMap=[
  {id:'in_vpcs',patterns:['vpc','vpcs']},
  {id:'in_subnets',patterns:['subnet','subnets']},
  {id:'in_rts',patterns:['route-table','route_table','routetable','rt']},
  {id:'in_sgs',patterns:['security-group','security_group','securitygroup','sg']},
  {id:'in_nacls',patterns:['nacl','network-acl','network_acl','networkacl']},
  {id:'in_enis',patterns:['eni','network-interface','network_interface','networkinterface']},
  {id:'in_igws',patterns:['igw','internet-gateway','internet_gateway','internetgateway']},
  {id:'in_nats',patterns:['nat-gw','nat_gw','natgw','nat-gateway','nat_gateway','natgateway']},
  {id:'in_vpces',patterns:['vpc-endpoint','vpc_endpoint','vpcendpoint','vpce']},
  {id:'in_ec2',patterns:['instance','instances','ec2']},
  {id:'in_albs',patterns:['alb','nlb','elb','load-balancer','load_balancer','loadbalancer']},
  {id:'in_tgs',patterns:['target-group','target_group','targetgroup','tg']},
  {id:'in_peer',patterns:['peering','vpc-peering','peer']},
  {id:'in_vpn',patterns:['vpn','vpn-connection','vpn_connection']},
  {id:'in_vols',patterns:['volume','volumes','vol']},
  {id:'in_snaps',patterns:['snapshot','snapshots','snap']},
  {id:'in_s3',patterns:['s3-bucket','s3_bucket','s3bucket','s3']},
  {id:'in_r53',patterns:['hosted-zone','hosted_zone','hostedzone','r53','route53']},
  {id:'in_r53records',patterns:['record-set','recordset','resource-record','resourcerecord','r53record','r53-record']},
  {id:'in_waf',patterns:['waf','web-acl','webacl','web_acl']},
  {id:'in_rds',patterns:['rds','db-instance','dbinstance','db_instance']},
  {id:'in_ecs',patterns:['ecs','ecs-service','ecs_service','ecsservice']},
  {id:'in_lambda',patterns:['lambda','function','lambda-function']},
  {id:'in_elasticache',patterns:['elasticache','cache-cluster','cachecluster','redis','memcached']},
  {id:'in_redshift',patterns:['redshift','redshift-cluster']},
  {id:'in_tgwatt',patterns:['transit-gateway-attachment','tgw-attachment','tgw_attachment','tgwattachment']},
  {id:'in_cf',patterns:['cloudfront','cf-distribution','distribution']},
];

function matchFile(fname, content){
  const base=fname.replace(/\.json$/i,'').toLowerCase().replace(/[^a-z0-9-_]/g,'');
  // exact match first
  for(const fm of fileMap){
    for(const p of fm.patterns){if(base===p||base===p+'s')return fm.id}
  }
  // contains match  sort candidates by longest pattern first to avoid partial matches
  const candidates=[];
  for(const fm of fileMap){
    for(const p of fm.patterns){if(base.includes(p))candidates.push({id:fm.id,p,len:p.length})}
  }
  if(candidates.length){
    candidates.sort((a,b)=>b.len-a.len);
    const best=candidates[0].id;
    // content-override: verify filename match doesn't contradict content
    if(content&&best==='in_ec2'){
      const snip=content.slice(0,500);
      if(snip.includes('"DBInstances"')&&!snip.includes('"Reservations"'))return 'in_rds';
      if(snip.includes('"CacheClusters"'))return 'in_elasticache';
    }
    return best;
  }
  // content-based fallback  detect by JSON keys
  if(content){
    const snip=content.slice(0,500);
    if(snip.includes('"Reservations"'))return 'in_ec2';
    if(snip.includes('"DBInstances"'))return 'in_rds';
    if(snip.includes('"Vpcs"'))return 'in_vpcs';
    if(snip.includes('"Subnets"'))return 'in_subnets';
    if(snip.includes('"RouteTables"'))return 'in_rts';
    if(snip.includes('"SecurityGroups"'))return 'in_sgs';
    if(snip.includes('"NetworkAcls"'))return 'in_nacls';
    if(snip.includes('"NetworkInterfaces"'))return 'in_enis';
    if(snip.includes('"InternetGateways"'))return 'in_igws';
    if(snip.includes('"NatGateways"'))return 'in_nats';
    if(snip.includes('"VpcEndpoints"'))return 'in_vpces';
    if(snip.includes('"LoadBalancers"'))return 'in_albs';
    if(snip.includes('"TargetGroups"'))return 'in_tgs';
    if(snip.includes('"VpcPeeringConnections"'))return 'in_peer';
    if(snip.includes('"VpnConnections"'))return 'in_vpn';
    if(snip.includes('"Volumes"'))return 'in_vols';
    if(snip.includes('"Snapshots"'))return 'in_snaps';
    if(snip.includes('"Buckets"'))return 'in_s3';
    if(snip.includes('"HostedZones"'))return 'in_r53';
    if(snip.includes('"ResourceRecordSets"'))return 'in_r53records';
    if(snip.includes('"WebACLs"'))return 'in_waf';
    if(snip.includes('"TransitGatewayAttachments"'))return 'in_tgwatt';
    if(snip.includes('"DistributionList"'))return 'in_cf';
    if(snip.includes('"CacheClusters"'))return 'in_elasticache';
    if(snip.includes('"Clusters"')&&snip.includes('"Redshift"'))return 'in_redshift';
  }
  return null;
}

document.getElementById('uploadBtn').addEventListener('click',()=>document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change',async function(){
  const files=[...this.files];
  if(!files.length)return;
  const status=document.getElementById('uploadStatus');
  status.style.display='block';
  status.textContent=`Reading ${files.length} file(s)...`;
  let matched=0,skipped=[];
  for(const f of files){
    let text;
    try{text=await f.text();JSON.parse(text)}catch(e){skipped.push(f.name+' (invalid JSON)');continue}
    const inputId=matchFile(f.name, text);
    if(!inputId){skipped.push(f.name);continue}
    const el=document.getElementById(inputId);
    if(el){el.value=text;el.className='ji valid';matched++}
  }
  // expand sections with data
  document.querySelectorAll('.sec-hdr.collapsed').forEach(h=>{
    const body=h.nextElementSibling;
    if(body){const ta=body.querySelectorAll('.ji.valid');if(ta.length)h.click()}
  });
  let msg=matched+' of '+files.length+' files loaded';
  if(skipped.length)msg+=' | Skipped: '+skipped.join(', ');
  status.textContent=msg;
  status.style.color=skipped.length?'var(--accent-orange)':'var(--accent-green)';
  this.value='';
  if(matched>0)renderMap();
});
document.getElementById('clearBtn').addEventListener('click',()=>{document.querySelectorAll('.ji').forEach(el=>{el.value='';el.className='ji'});d3.select('#mapSvg').selectAll('*').remove();d3.select('#mapSvg').style('display','none');document.getElementById('emptyState').style.display='flex';document.getElementById('statsBar').style.display='none';document.getElementById('legend').style.display='none'});
document.getElementById('loadDemo').addEventListener('click',()=>{
  const m={in_vpcs:'vpcs',in_subnets:'subnets',in_rts:'rts',in_sgs:'sgs',in_nacls:'nacls',in_igws:'igws',in_nats:'nats',in_ec2:'ec2',in_albs:'albs',in_peer:'peer',in_vpn:'vpn',in_vpces:'vpces',in_vols:'vols',in_s3:'s3',in_r53:'r53',in_r53records:'r53records',in_tgs:'tgs',in_snaps:'snaps',in_enis:'enis',in_waf:'waf',in_rds:'rds',in_ecs:'ecs',in_lambda:'lambda',in_elasticache:'elasticache',in_redshift:'redshift',in_tgwatt:'tgwatt',in_cf:'cf'};
  Object.entries(m).forEach(([id,k])=>{if(demo[k])document.getElementById(id).value=JSON.stringify(demo[k],null,2)});
  document.querySelectorAll('.ji').forEach(el=>{if(el.value.trim())el.className='ji valid'});
  document.querySelectorAll('.sec-hdr.collapsed').forEach(h=>{h.click()});
  renderMap();
});

// store layout data globally for export
let exportData={vL:[],gwP:new Map(),allS:[],tG:{},peerings:[],shGws:[]};

// helper: resolve CSS vars to hex for SVG serialization
function resolveColor(cssVar){
  const el=document.createElement('div');el.style.color=cssVar;document.body.appendChild(el);
  const c=getComputedStyle(el).color;document.body.removeChild(el);
  const m=c.match(/(\d+)/g);if(!m)return'#888';
  return'#'+m.slice(0,3).map(x=>(+x).toString(16).padStart(2,'0')).join('');
}

function downloadBlob(blob,name){
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=name;a.click();URL.revokeObjectURL(a.href);
}

// PNG High-DPI Export
document.getElementById('expPng').addEventListener('click',()=>{
  const svgEl=document.getElementById('mapSvg');
  const root=svgEl.querySelector('.map-root');
  if(!root)return;
  // get untransformed bounding box
  const bb=root.getBBox();
  const pad=60;
  const cw=bb.width+pad,ch=bb.height+pad;
  const maxDim=16000;
  const scale=Math.min(3, maxDim/cw, maxDim/ch);
  const w=Math.round(cw*scale),h=Math.round(ch*scale);
  const clone=svgEl.cloneNode(true);
  clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
  clone.setAttribute('width',w);clone.setAttribute('height',h);
  clone.setAttribute('viewBox',`${bb.x-pad/2} ${bb.y-pad/2} ${cw} ${ch}`);
  // remove zoom/pan transform so content fills viewBox
  const cloneRoot=clone.querySelector('.map-root');
  if(cloneRoot)cloneRoot.removeAttribute('transform');
  const styles=document.querySelector('style').textContent;
  const styleEl=document.createElementNS('http://www.w3.org/2000/svg','style');
  styleEl.textContent=styles;
  clone.insertBefore(styleEl,clone.firstChild);
  // background rect
  const bgR=document.createElementNS('http://www.w3.org/2000/svg','rect');
  bgR.setAttribute('x',bb.x-pad/2);bgR.setAttribute('y',bb.y-pad/2);
  bgR.setAttribute('width',cw);bgR.setAttribute('height',ch);
  bgR.setAttribute('fill','#0a0e17');
  if(cloneRoot)cloneRoot.insertBefore(bgR,cloneRoot.firstChild);
  const svgStr=new XMLSerializer().serializeToString(clone);
  const img=new Image();
  img.onload=()=>{
    const canvas=document.createElement('canvas');
    canvas.width=w;canvas.height=h;
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='#0a0e17';ctx.fillRect(0,0,w,h);
    ctx.drawImage(img,0,0,w,h);
    canvas.toBlob(blob=>{if(blob)downloadBlob(blob,'aws-network-map.png')},'image/png');
  };
  img.onerror=()=>{alert('PNG render failed - try SVG export instead')};
  img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr)));
});

// VSDX (Visio) Export - best Lucidchart import path
document.getElementById('expVsdx').addEventListener('click',()=>{
  if(typeof JSZip==='undefined'){alert('JSZip not loaded');return}
  const vpcs=ext(safeParse(gv('in_vpcs')),['Vpcs']);
  const subnets=ext(safeParse(gv('in_subnets')),['Subnets']);
  const rts=ext(safeParse(gv('in_rts')),['RouteTables']);
  const igws=ext(safeParse(gv('in_igws')),['InternetGateways']);
  const nats=ext(safeParse(gv('in_nats')),['NatGateways']);
  const vpceList=ext(safeParse(gv('in_vpces')),['VpcEndpoints']);
  const peerings=ext(safeParse(gv('in_peer')),['VpcPeeringConnections']);
  let instances=[];
  const eRaw=safeParse(gv('in_ec2'));
  if(eRaw){
    const reservations=ext(eRaw,['Reservations']);
    if(reservations.length){reservations.forEach(r=>{if(r.Instances)instances=instances.concat(r.Instances);else if(r.InstanceId)instances.push(r)})}
    else{const flat=ext(eRaw,['Instances']);if(flat.length)instances=flat;else{const arr=Array.isArray(eRaw)?eRaw:[eRaw];arr.forEach(x=>{if(x.InstanceId)instances.push(x)})}}
  }
  const enis=ext(safeParse(gv('in_enis')),['NetworkInterfaces']);
  const sgs=ext(safeParse(gv('in_sgs')),['SecurityGroups']);
  const nacls=ext(safeParse(gv('in_nacls')),['NetworkAcls']);
  const albs=ext(safeParse(gv('in_albs')),['LoadBalancers']);
  const volumes=ext(safeParse(gv('in_vols')),['Volumes']);
  if(!vpcs.length){alert('Render map first');return}

  const subByVpc={};subnets.forEach(s=>(subByVpc[s.VpcId]=subByVpc[s.VpcId]||[]).push(s));
  const mainRT={};
  rts.forEach(rt=>{if((rt.Associations||[]).some(a=>a.Main))mainRT[rt.VpcId]=rt});
  const subRT={};
  rts.forEach(rt=>{(rt.Associations||[]).forEach(a=>{if(a.SubnetId)subRT[a.SubnetId]=rt})});
  subnets.forEach(s=>{if(!subRT[s.SubnetId]&&mainRT[s.VpcId])subRT[s.SubnetId]=mainRT[s.VpcId]});
  const subNacl={};nacls.forEach(n=>(n.Associations||[]).forEach(a=>{if(a.SubnetId)subNacl[a.SubnetId]=n}));
  const sgByVpc={};sgs.forEach(sg=>(sgByVpc[sg.VpcId]=sgByVpc[sg.VpcId]||[]).push(sg));
  const instBySub={};instances.forEach(i=>{if(i.SubnetId)(instBySub[i.SubnetId]=instBySub[i.SubnetId]||[]).push(i)});
  const eniBySub={};enis.forEach(e=>{if(e.SubnetId)(eniBySub[e.SubnetId]=eniBySub[e.SubnetId]||[]).push(e)});
  const albBySub={};albs.forEach(lb=>{(lb.AvailabilityZones||[]).forEach(az=>{if(az.SubnetId)(albBySub[az.SubnetId]=albBySub[az.SubnetId]||[]).push(lb)})});
  const volByInst={};volumes.forEach(v=>{(v.Attachments||[]).forEach(a=>{if(a.InstanceId)(volByInst[a.InstanceId]=volByInst[a.InstanceId]||[]).push(v)})});
  const knownInstIds2=new Set(instances.map(i=>i.InstanceId));
  const instSubFromEni2={};enis.forEach(e=>{if(e.SubnetId&&e.Attachment&&e.Attachment.InstanceId)instSubFromEni2[e.Attachment.InstanceId]=e.SubnetId});
  const volBySub={};volumes.forEach(v=>{const att=(v.Attachments||[])[0];if(att&&att.InstanceId){if(knownInstIds2.has(att.InstanceId))return;const sid=instSubFromEni2[att.InstanceId];if(sid)(volBySub[sid]=volBySub[sid]||[]).push(v)}});
  const pubSubs=new Set();
  rts.forEach(rt=>{
    const hasIgw=(rt.Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
    (rt.Associations||[]).forEach(a=>{if(a.SubnetId&&hasIgw)pubSubs.add(a.SubnetId)});
  });
  subnets.forEach(s=>{if(!pubSubs.has(s.SubnetId)&&mainRT[s.VpcId]){
    const hasIgw=(mainRT[s.VpcId].Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
    if(hasIgw)pubSubs.add(s.SubnetId);
  }});


  // --- SIZING ---
  const PX=96;
  const toIn=px=>px/PX;

  const SUB_W=520;
  const SUB_H_MIN=90;
  const SUB_GAP=24;
  const VPC_PAD=50;
  const VPC_HDR=80;
  const GW_INSIDE_W=160, GW_INSIDE_H=50, GW_INSIDE_GAP=16;
  const GW_ROW_H=70;
  const COL_GAP=280;
  const LINE_H=15;
  const TOP_MARGIN=80;

  const activeVpcs=vpcs.filter(v=>(subByVpc[v.VpcId]||[]).length>0);
  if(!activeVpcs.length){alert('No VPCs with subnets found');return}

  // --- shape collectors ---
  let shapeId=1;
  const shapes=[];
  const polyEdges=[];
  const idMap={};

  function xmlEsc(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}
  function uid(){return '{'+crypto.randomUUID()+'}'}

  function addRect(x,y,w,h,fill,stroke,strokeW,text,opts={}){
    const id=shapeId++;
    shapes.push({id,type:'rect',x,y,w,h,fill,stroke,strokeW,text,
      dashed:opts.dashed||false,fontSize:opts.fontSize||11,
      fontColor:opts.fontColor||'#1F2937',bold:opts.bold||false,
      topAlign:opts.topAlign||false,props:opts.props||[],
      hAlign:opts.hAlign||'left',linePattern:opts.linePattern||1});
    return id;
  }

  // polyline: linePattern 1=solid 2=dash 3=dot 4=dash-dot
  function addPolyEdge(waypoints,color,width,linePattern,label){
    polyEdges.push({waypoints,color,width,linePattern:linePattern||1,
      label:label||'',id:shapeId++});
  }

  // --- gateway type styles (for legend and cross-VPC lines) ---
  const gwStyles={
    'IGW':  {color:'#059669',pattern:1,label:'Internet Gateway',fill:'#ECFDF5',border:'#059669'},
    'NAT':  {color:'#D97706',pattern:2,label:'NAT Gateway',fill:'#FFFBEB',border:'#D97706'},
    'TGW':  {color:'#2563EB',pattern:1,label:'Transit Gateway',fill:'#EFF6FF',border:'#2563EB'},
    'VGW':  {color:'#7C3AED',pattern:4,label:'Virtual Private GW',fill:'#F5F3FF',border:'#7C3AED'},
    'PCX':  {color:'#EA580C',pattern:2,label:'VPC Peering',fill:'#FFF7ED',border:'#EA580C'},
    'VPCE': {color:'#0891B2',pattern:3,label:'VPC Endpoint',fill:'#ECFEFF',border:'#0891B2'},
    'GW':   {color:'#6B7280',pattern:1,label:'Gateway',fill:'#F9FAFB',border:'#6B7280'}
  };

  // --- collect gateways per VPC ---
  const gwByVpc={};
  const sharedGwMap=new Map();
  rts.forEach(rt=>{(rt.Routes||[]).forEach(r=>{
    const entries=[];
    if(r.GatewayId&&r.GatewayId!=='local')entries.push({id:r.GatewayId,type:clsGw(r.GatewayId)});
    if(r.NatGatewayId)entries.push({id:r.NatGatewayId,type:'NAT'});
    if(r.TransitGatewayId)entries.push({id:r.TransitGatewayId,type:'TGW'});
    if(r.VpcPeeringConnectionId)entries.push({id:r.VpcPeeringConnectionId,type:'PCX'});
    entries.forEach(e=>{
      if(e.type==='TGW'||e.type==='PCX'){
        if(!sharedGwMap.has(e.id))sharedGwMap.set(e.id,{...e,vpcIds:new Set()});
        sharedGwMap.get(e.id).vpcIds.add(rt.VpcId);
      } else {
        if(!gwByVpc[rt.VpcId])gwByVpc[rt.VpcId]=new Map();
        if(!gwByVpc[rt.VpcId].has(e.id))gwByVpc[rt.VpcId].set(e.id,e);
      }
    });
  })});
  igws.forEach(g=>{
    const v=(g.Attachments||[])[0];
    const vpcId=v?v.VpcId:null;
    if(vpcId){
      if(!gwByVpc[vpcId])gwByVpc[vpcId]=new Map();
      if(!gwByVpc[vpcId].has(g.InternetGatewayId))
        gwByVpc[vpcId].set(g.InternetGatewayId,{id:g.InternetGatewayId,type:'IGW'});
    }
  });
  nats.forEach(g=>{
    if(g.VpcId){
      if(!gwByVpc[g.VpcId])gwByVpc[g.VpcId]=new Map();
      if(!gwByVpc[g.VpcId].has(g.NatGatewayId))
        gwByVpc[g.VpcId].set(g.NatGatewayId,{id:g.NatGatewayId,type:'NAT'});
    }
  });

  // --- build subnet display text ---
  function buildSubText(s){
    const isPub=pubSubs.has(s.SubnetId);
    const si=instBySub[s.SubnetId]||[];
    const se=eniBySub[s.SubnetId]||[];
    const sa=albBySub[s.SubnetId]||[];
    const lines=[];
    lines.push((isPub?'[PUBLIC] ':'[PRIVATE] ')+gn(s,s.SubnetId));
    lines.push(s.CidrBlock+'  |  '+(s.AvailabilityZone||''));
    const parts=[];
    if(si.length)parts.push(si.length+' EC2');
    if(se.length)parts.push(se.length+' ENI');
    if(sa.length)parts.push(sa.length+' ALB');
    if(parts.length)lines.push(parts.join(' | '));
    const rt=subRT[s.SubnetId];
    if(rt){
      const nonLocal=(rt.Routes||[]).filter(r=>{
        const t=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId;
        return t&&t!=='local';
      });
      if(nonLocal.length){
        lines.push('Routes:');
        nonLocal.forEach(r=>{
          const dest=r.DestinationCidrBlock||r.DestinationPrefixListId||'?';
          const tgt=r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId;
          lines.push('  '+dest+' -> '+clsGw(tgt||'')+' '+sid(tgt));
        });
      }
    }
    return {text:lines.join('\n'),lineCount:lines.length};
  }

  // --- compute subnet heights ---
  const subHeights={};
  subnets.forEach(s=>{
    const bt=buildSubText(s);
    subHeights[s.SubnetId]=Math.max(SUB_H_MIN, bt.lineCount*LINE_H+30);
  });

  // ============================
  // LAYOUT: each VPC is a column
  // ============================
  const vpcLayouts=[];
  let curX=TOP_MARGIN;

  activeVpcs.forEach(vpc=>{
    const ss=subByVpc[vpc.VpcId]||[];
    const myGws=gwByVpc[vpc.VpcId]?[...gwByVpc[vpc.VpcId].values()]:[];

    // gateway row inside VPC: how many rows of gateways?
    const gwPerRow=3;
    const gwRows=Math.ceil(myGws.length/gwPerRow);
    const gwSectionH=gwRows>0?(gwRows*(GW_INSIDE_H+GW_INSIDE_GAP)+GW_INSIDE_GAP):0;

    // VPC width
    const vpcW=SUB_W+VPC_PAD*2;

    // VPC height
    let vpcH=VPC_HDR+gwSectionH;
    ss.forEach(s=>{vpcH+=(subHeights[s.SubnetId]||SUB_H_MIN)+SUB_GAP});
    vpcH+=VPC_PAD;

    vpcLayouts.push({vpc,ss,vpcW,vpcH,myGws,gwSectionH,x:curX});
    curX+=vpcW+COL_GAP;
  });

  const totalWidth=curX;

  // --- LEGEND (top-left, outside VPC area) ---
  const LEGEND_X=TOP_MARGIN;
  const LEGEND_Y=TOP_MARGIN;
  const usedTypes=new Set();
  // figure out which gw types are actually present
  Object.values(gwByVpc).forEach(m=>m.forEach(gw=>usedTypes.add(gw.type)));
  sharedGwMap.forEach(gw=>usedTypes.add(gw.type));

  const legendEntries=[...usedTypes].map(t=>gwStyles[t]||gwStyles['GW']);
  const legendH=50+legendEntries.length*28;
  addRect(LEGEND_X,LEGEND_Y,320,legendH,'#FFFFFF','#9CA3AF',1,
    'LEGEND\n\n'+[...usedTypes].map(t=>{
      const s=gwStyles[t]||gwStyles['GW'];
      return '['+t+'] '+s.label;
    }).join('\n'),
    {fontSize:11,fontColor:'#374151',bold:false,topAlign:true});

  // --- VPC start Y below legend ---
  const VPC_START_Y=LEGEND_Y+legendH+60;

  // --- place VPCs ---
  let maxVpcBot=0;
  const vpcPositions={};

  vpcLayouts.forEach(vl=>{
    const {vpc,ss,vpcW,vpcH,myGws,gwSectionH,x}=vl;

    // VPC summary text
    const vSgs=sgByVpc[vpc.VpcId]||[];
    const totalEC2=ss.reduce((a,s)=>(instBySub[s.SubnetId]||[]).length+a,0);
    let vpcLabel=gn(vpc,vpc.VpcId)+'\n'+vpc.CidrBlock;
    vpcLabel+='\n'+ss.length+' subnets | '+totalEC2+' EC2 | '+vSgs.length+' SGs';

    const vpcProps=[];
    vpcProps.push({label:'VPC ID',val:vpc.VpcId});
    vpcProps.push({label:'CIDR',val:vpc.CidrBlock});
    if(vSgs.length){
      vpcProps.push({label:'Security Groups',val:String(vSgs.length)});
      vpcProps.push({label:'SG Details',val:vSgs.slice(0,10).map(sg=>
        sg.GroupName+' ('+((sg.IpPermissions||[]).length)+' in)').join('; ')});
    }

    const vid=addRect(x,VPC_START_Y,vpcW,vpcH,'#EFF3FF','#2563EB',2.5,vpcLabel,
      {dashed:true,fontSize:13,fontColor:'#1E40AF',bold:true,topAlign:true,props:vpcProps});
    idMap[vpc.VpcId]=vid;
    vpcPositions[vpc.VpcId]={x,y:VPC_START_Y,w:vpcW,h:vpcH};

    // --- gateways INSIDE VPC at top ---
    let gwY=VPC_START_Y+VPC_HDR;
    for(let row=0;row<Math.ceil(myGws.length/3);row++){
      const rowGws=myGws.slice(row*3,(row+1)*3);
      const rowTotalW=rowGws.length*GW_INSIDE_W+(rowGws.length-1)*GW_INSIDE_GAP;
      let gwX=x+VPC_PAD+(SUB_W-rowTotalW)/2;
      rowGws.forEach(gw=>{
        const st=gwStyles[gw.type]||gwStyles['GW'];
        const nm=gwNames[gw.id]||sid(gw.id);
        const truncNm=nm.length>16?nm.substring(0,14)+'..':nm;
        const label=gw.type+': '+truncNm;
        addRect(gwX,gwY,GW_INSIDE_W,GW_INSIDE_H,st.fill,st.border,2,label,
          {fontSize:10,fontColor:st.color,bold:true,hAlign:'center'});
        gwX+=GW_INSIDE_W+GW_INSIDE_GAP;
      });
      gwY+=GW_INSIDE_H+GW_INSIDE_GAP;
    }

    // --- subnets inside VPC below gateways ---
    let sy=VPC_START_Y+VPC_HDR+gwSectionH;
    ss.forEach(s=>{
      const isPub=pubSubs.has(s.SubnetId);
      const fill=isPub?'#ECFDF5':'#F5F3FF';
      const stroke=isPub?'#059669':'#7C3AED';
      const fc=isPub?'#065F46':'#4C1D95';
      const sh=subHeights[s.SubnetId]||SUB_H_MIN;
      const bt=buildSubText(s);

      const sp=[];
      sp.push({label:'Subnet ID',val:s.SubnetId});
      sp.push({label:'CIDR',val:s.CidrBlock});
      sp.push({label:'AZ',val:s.AvailabilityZone||'N/A'});
      sp.push({label:'Type',val:isPub?'Public':'Private'});
      const rt=subRT[s.SubnetId];
      if(rt){
        sp.push({label:'Route Table',val:gn(rt,rt.RouteTableId)});
        sp.push({label:'Routes',val:(rt.Routes||[]).map(r=>
          (r.DestinationCidrBlock||'?')+' -> '+(r.GatewayId||r.NatGatewayId||r.TransitGatewayId||r.VpcPeeringConnectionId||'local')
        ).join('; ')});
      }
      const nc=subNacl[s.SubnetId];
      if(nc)sp.push({label:'NACL',val:nc.NetworkAclId});

      addRect(x+VPC_PAD,sy,SUB_W,sh,fill,stroke,1.5,bt.text,
        {fontSize:10,fontColor:fc,topAlign:true,props:sp});
      idMap[s.SubnetId]={x:x+VPC_PAD,y:sy,w:SUB_W,h:sh};
      sy+=sh+SUB_GAP;
    });

    maxVpcBot=Math.max(maxVpcBot,VPC_START_Y+vpcH);
  });

  // =======================================
  // CROSS-VPC CONNECTIONS (the ONLY lines)
  // =======================================
  // These are: TGW connections and VPC Peering
  // Use staggered horizontal bus lanes below VPCs

  const BUS_START_Y=maxVpcBot+100;
  const BUS_LANE_H=50;
  let busLaneIdx=0;

  // --- shared gateways (TGW) ---
  // Place TGW label boxes centered below, then draw orthogonal lines
  if(sharedGwMap.size>0){
    const sharedArr=[...sharedGwMap.values()];
    const tgwTotalW=sharedArr.length*200+(sharedArr.length-1)*80;
    let tgwStartX=Math.max(TOP_MARGIN,(totalWidth-tgwTotalW)/2);
    const TGW_Y=BUS_START_Y+busLaneIdx*BUS_LANE_H+120;

    sharedArr.forEach((gw,i)=>{
      const st=gwStyles[gw.type]||gwStyles['GW'];
      const nm=gwNames[gw.id]||sid(gw.id);
      const truncNm=nm.length>20?nm.substring(0,18)+'..':nm;
      const gwX=tgwStartX+i*(200+80);
      const gid=addRect(gwX,TGW_Y,200,60,st.fill,st.border,2.5,
        gw.type+': '+truncNm,
        {fontSize:12,fontColor:st.color,bold:true,hAlign:'center'});

      // draw orthogonal lines from each connected VPC to this gateway
      const connectedVpcs=[...gw.vpcIds].filter(vid=>vpcPositions[vid]);
      const busY=BUS_START_Y+busLaneIdx*BUS_LANE_H;

      connectedVpcs.forEach((vpcId,vi)=>{
        const vp=vpcPositions[vpcId];
        if(!vp)return;
        // stagger the exit points so lines dont overlap
        const exitX=vp.x+vp.w/2+(vi-connectedVpcs.length/2)*20;
        const gwCX=gwX+100;
        // offset bus lane per connection to avoid overlap
        const laneY=busY+(vi*12);
        addPolyEdge([
          {x:exitX,y:vp.y+vp.h},
          {x:exitX,y:laneY},
          {x:gwCX,y:laneY},
          {x:gwCX,y:TGW_Y}
        ],st.color,2.5,st.pattern);
      });
      busLaneIdx++;
    });
  }

  // --- VPC Peering connections ---
  peerings.forEach(pcx=>{
    if(pcx.Status&&pcx.Status.Code!=='active')return;
    const rv=pcx.RequesterVpcInfo?.VpcId;
    const av=pcx.AccepterVpcInfo?.VpcId;
    const vp1=vpcPositions[rv];
    const vp2=vpcPositions[av];
    if(!vp1||!vp2)return;
    const st=gwStyles['PCX'];
    const busY=BUS_START_Y+busLaneIdx*BUS_LANE_H;
    const cx1=vp1.x+vp1.w/2;
    const cx2=vp2.x+vp2.w/2;
    addPolyEdge([
      {x:cx1,y:vp1.y+vp1.h},
      {x:cx1,y:busY},
      {x:cx2,y:busY},
      {x:cx2,y:vp2.y+vp2.h}
    ],st.color,2.5,st.pattern);
    busLaneIdx++;
  });

  // --- PAGE DIMENSIONS ---
  let pgWpx=totalWidth+200;
  let pgHpx=BUS_START_Y+(busLaneIdx+2)*BUS_LANE_H+300;
  shapes.forEach(s=>{
    pgWpx=Math.max(pgWpx,s.x+s.w+120);
    pgHpx=Math.max(pgHpx,s.y+s.h+120);
  });
  const pgW=toIn(pgWpx)+2,pgH=toIn(pgHpx)+2;

  // ========================
  // VISIO XML GENERATION
  // ========================
  function buildShape(s){
    const wi=toIn(s.w),hi=toIn(s.h);
    const cx=toIn(s.x)+wi/2;
    const cy=pgH-(toIn(s.y)+hi/2);
    const lp=s.linePattern||1;
    const dashXml=s.dashed?`<Cell N="LinePattern" V="2"/>`:(lp!==1?`<Cell N="LinePattern" V="${lp}"/>`:'');
    const sw=toIn(s.strokeW||1);
    const fs=(s.fontSize||11)/72;

    const geom=`<Section N="Geometry" IX="0">
      <Cell N="NoFill" V="0"/><Cell N="NoLine" V="0"/>
      <Row T="MoveTo" IX="1"><Cell N="X" V="0"/><Cell N="Y" V="0"/></Row>
      <Row T="LineTo" IX="2"><Cell N="X" V="${wi}"/><Cell N="Y" V="0"/></Row>
      <Row T="LineTo" IX="3"><Cell N="X" V="${wi}"/><Cell N="Y" V="${hi}"/></Row>
      <Row T="LineTo" IX="4"><Cell N="X" V="0"/><Cell N="Y" V="${hi}"/></Row>
      <Row T="LineTo" IX="5"><Cell N="X" V="0"/><Cell N="Y" V="0"/></Row>
    </Section>`;

    const vAlign=s.topAlign?0:1;
    const hAlign=s.hAlign==='center'?1:0;

    const propsXml=s.props&&s.props.length?
      `<Section N="Property">${s.props.map((p,i)=>
        `<Row N="Row_${i}"><Cell N="Label" V="${xmlEsc(p.label)}"/><Cell N="Value" V="${xmlEsc(p.val)}"/><Cell N="Type" V="0"/></Row>`
      ).join('')}</Section>`:'';

    return `<Shape ID="${s.id}" NameU="Shape${s.id}" Type="Shape" UniqueID="${uid()}">
      <Cell N="PinX" V="${cx}"/>
      <Cell N="PinY" V="${cy}"/>
      <Cell N="Width" V="${wi}"/>
      <Cell N="Height" V="${hi}"/>
      <Cell N="LocPinX" V="${wi/2}"/>
      <Cell N="LocPinY" V="${hi/2}"/>
      <Cell N="TxtWidth" V="${wi}"/>
      <Cell N="TxtHeight" V="${hi}"/>
      <Cell N="TxtPinX" V="${wi/2}"/>
      <Cell N="TxtPinY" V="${hi/2}"/>
      <Cell N="TxtLocPinX" V="${wi/2}"/>
      <Cell N="TxtLocPinY" V="${hi/2}"/>
      <Cell N="FillForegnd" V="${s.fill}"/>
      <Cell N="FillBkgnd" V="${s.fill}"/>
      <Cell N="LineColor" V="${s.stroke}"/>
      <Cell N="LineWeight" V="${sw}"/>
      <Cell N="VerticalAlign" V="${vAlign}"/>
      <Cell N="HorzAlign" V="${hAlign}"/>
      <Cell N="TopMargin" V="0.06"/>
      <Cell N="BottomMargin" V="0.06"/>
      <Cell N="LeftMargin" V="0.1"/>
      <Cell N="RightMargin" V="0.1"/>
      ${dashXml}
      <Section N="Character" IX="0">
        <Row IX="0">
          <Cell N="Font" V="Calibri"/>
          <Cell N="Color" V="${s.fontColor||'#000000'}"/>
          <Cell N="Size" V="${fs}"/>
          <Cell N="Style" V="${s.bold?1:0}"/>
        </Row>
      </Section>
      ${geom}
      ${propsXml}
      <Text>${xmlEsc(s.text)}</Text>
    </Shape>`;
  }

  function buildPolyConnector(e){
    const pts=e.waypoints.map(wp=>({x:toIn(wp.x),y:pgH-toIn(wp.y)}));
    if(pts.length<2)return '';
    const p1=pts[0],pN=pts[pts.length-1];
    const sw=toIn(e.width||1);
    const cid=e.id;
    let geomRows=`<Row T="MoveTo" IX="1"><Cell N="X" V="${p1.x}"/><Cell N="Y" V="${p1.y}"/></Row>`;
    for(let i=1;i<pts.length;i++){
      geomRows+=`<Row T="LineTo" IX="${i+1}"><Cell N="X" V="${pts[i].x}"/><Cell N="Y" V="${pts[i].y}"/></Row>`;
    }
    return `<Shape ID="${cid}" NameU="Conn.${cid}" Type="Shape" UniqueID="${uid()}">
      <Cell N="ObjType" V="2"/>
      <Cell N="BeginX" V="${p1.x}"/>
      <Cell N="BeginY" V="${p1.y}"/>
      <Cell N="EndX" V="${pN.x}"/>
      <Cell N="EndY" V="${pN.y}"/>
      <Cell N="LineColor" V="${e.color||'#6B7280'}"/>
      <Cell N="LineWeight" V="${sw}"/>
      <Cell N="LinePattern" V="${e.linePattern||1}"/>
      <Cell N="BeginArrow" V="0"/>
      <Cell N="EndArrow" V="5"/>
      <Cell N="EndArrowSize" V="2"/>
      <Section N="Geometry" IX="0">
        <Cell N="NoFill" V="1"/><Cell N="NoLine" V="0"/>
        ${geomRows}
      </Section>
    </Shape>`;
  }

  // --- build all XML ---
  let shapesStr='';
  shapes.forEach(s=>shapesStr+=buildShape(s));
  polyEdges.forEach(e=>shapesStr+=buildPolyConnector(e));

  const page1=`<?xml version="1.0" encoding="utf-8"?>
<PageContents xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <Shapes>${shapesStr}</Shapes>
</PageContents>`;

  const pagesXml=`<?xml version="1.0" encoding="utf-8"?>
<Pages xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <Page ID="0" Name="AWS Network Map" NameU="AWS Network Map">
    <PageSheet>
      <Cell N="PageWidth" V="${pgW}"/>
      <Cell N="PageHeight" V="${pgH}"/>
      <Cell N="PrintPageOrientation" V="2"/>
    </PageSheet>
    <Rel r:id="rId1"/>
  </Page>
</Pages>`;

  const docXml=`<?xml version="1.0" encoding="utf-8"?>
<VisioDocument xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <DocumentProperties>
    <Creator>AWS Network Map Tool</Creator>
    <Description>AWS Network Infrastructure Diagram</Description>
  </DocumentProperties>
</VisioDocument>`;

  const contentTypes=`<?xml version="1.0" encoding="utf-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/visio/document.xml" ContentType="application/vnd.ms-visio.drawing.main+xml"/>
  <Override PartName="/visio/pages/pages.xml" ContentType="application/vnd.ms-visio.pages+xml"/>
  <Override PartName="/visio/pages/page1.xml" ContentType="application/vnd.ms-visio.page+xml"/>
</Types>`;

  const topRels=`<?xml version="1.0" encoding="utf-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/document" Target="visio/document.xml"/>
</Relationships>`;
  const docRels=`<?xml version="1.0" encoding="utf-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/pages" Target="pages/pages.xml"/>
</Relationships>`;
  const pagesRels=`<?xml version="1.0" encoding="utf-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/page" Target="page1.xml"/>
</Relationships>`;

  const zip=new JSZip();
  zip.file('[Content_Types].xml',contentTypes);
  zip.folder('_rels').file('.rels',topRels);
  zip.folder('visio').file('document.xml',docXml);
  zip.folder('visio/_rels').file('document.xml.rels',docRels);
  zip.folder('visio/pages').file('pages.xml',pagesXml);
  zip.folder('visio/pages').file('page1.xml',page1);
  zip.folder('visio/pages/_rels').file('pages.xml.rels',pagesRels);

  zip.generateAsync({type:'blob',mimeType:'application/vnd.ms-visio.drawing'}).then(blob=>{
    downloadBlob(blob,'aws-network-map.vsdx');
  });
});


// Lucid Standard Import (.lucid) Export
// --- Lucid Standard Import Export (with AWS-style icons) ---
// AWS architecture icon PNGs (base64)
const AWS_ICONS={
  'alb':'data:image/png;base64,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',
  'ec2':'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAMKADAAQAAAABAAAAMAAAAADbN2wMAAABO0lEQVRoBe1U2w3CMAwMiA3YCqZhEqahWzEDNB9nWdE16UcTx5WRUNw4re9hJ6X4OVLg+0q//C8h994v6+nnq37wGAcBa9fcO3CpKbgO52fNP2pnBuSW+zs9t+q0HLAGn3FXMdy2mOn9VYGqU/rskTG7ssvvtxwoz0/3LA7sYWuFnmFDV5zHATDSKjPmOj8qZthQ270DQQBWWq1xC1kpj7riAJv0uIUgU8c1bqGO4u76tMzALP3OUDNsmFn3LSQOgJFWgDHX+VExw4ba7h0IArDSapUZmKXfmRAMG+bCfQuJA2CkFWDMdX5UzLChtnsHggCstFplBmbpdyYEw4a5cN9C4gAYaQUYc50fFTNsqH0eB8CIrbM4wbC1HFjYS4P3jsOQnWBu9N6vCdZyoPbuFLkgYG2DewesBYz6fzqMaA3IXYFbAAAAAElFTkSuQmCC',
  'igw':'data:image/png;base64,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',
  'internet':'data:image/png;base64,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',
  'nat':'data:image/png;base64,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',
  'pcx':'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAMKADAAQAAAABAAAAMAAAAADbN2wMAAAIp0lEQVRoBe1aWWyUVRQ+d6atkCIad5q4UUIg7tGIvuDCA3FpO00o1eiDxESRIMiUUjRiijFRuhliUYnR+AIqIJ1Oo9EHjSExgkLctwQqEq0okQcFW7rM9fvu3Pv3n3/+2QpaH7zJnbude8537nru+Ufk/zC5I6BOhXgtWnXUyfWi5Y6IkmotUgW+LlLEACOEDaS0HIhoeTveJ3uUKJCeXDgpBTpjegEANYBJLWDMKBHKL0CfhMLbmxLqvRL7euQTUqArpq8H8HZwme9x0tIvSnoBai/SAQAbmFJmRl6GRqUK9FWYoSq0XatSEkM60+srsgv91jT3qj2+uqKyJSnwbExfMibSBiAN5K61HFFKuiMiPfFe9WVQYleNvox18T71dVZbnb4iJVIPHsvB41zbviOqpHlVQh0M0ucqF61Ae42+VUVkOxidhXgcgrsAoL0lqf4MY94R0zEous20KVm8OqESYXQbavXpGIBmKBFHeyXiUZ2ShuY+9X4YfbCuKAU66vQydNyIWAZBvZGIPLRqp/olyMyVfeDLbd0IlkxOJUjTdru+IFIuLyAbQxxFXLm6Vz2PNG8oqEBHre6A8CbDRclTTQl5It/pEQLeASioBE+zzpg8iZl7nJ20kq7mhErLdlwCKWYvdzAjnwY/hCVzN5bBuqLBa+wVGzBKG5At55IyCrqGQEreaRlyF5qGcMjG7ewHKMeLORXgmgcZlw0mQO5rTqrXx7vlzD2MFgJtW51ULY6qqVet9SmxwtXnSkH/BmXa9o0WSyh5qAI8beyGLQP6p8gwtHegcmq51EHwUj94R2KVWDq1wtwZrjpnamRCNgjKiIWYwoghLztg2njaLOKGjSekPt+yye49XgM+5qbFZgyVM04ZnjN7ok52opUbewf4mOPbT501A7ykQLAI8ThPm4mC9wuZaJ6yUyPyELEgLmqv0/OCvLIUGEulNx/P+XxHZZDRP1Ve87Y6TCzkj2n0DgYnL0MB2jaY7JvQ4QgvKUc02SmxEBNwzCdGP54MBWiYsRFKdOe6Yf2dC+VTShYyFqIr1E4sxEQ63NKL/fRlrmA2TNqqFGjV4+pLTVtv1mWVZ8Bg0zI9kpL+eFLtL5VHGD0xYSbWYx3VAutStze904EbBIXdOMP7cQxWhzEpVAceS8CDS+9sH+2uaJksWfWm6vfVTSgLq+AAFJgJa/bGpj61m0zGlxAeI4Yrjs4gd96eiO9tatDTgm2u3FmnHwT4V1Am+O8h6H2kxxDnj43KJ121elZXg56Kct5AGZQVdmPriBiDUEctVnDyFOBLipyNPe8TYRjRqtRy69Cw3ONr8rIdNfoc9OtgBZbO/Tiv58AkWDBG+1/kXcSzsBe+TQ3LX7gbduNmvZS0YcHIgCzIyzY7tOxjH8iY6fp6CgAAhfGs4vPPBA+8NQ9wO252bf5UReVOlDk7bzUlFWfBBG6+aFSWoPAHIvcbnhMyDzfrS0hDA2VgJsNtJ4vNwwoOngLIGwX4kiLnIPgw84B0bTFdjSNuOfMQ/BFTf+BdgpMDt7ksH47I+WgbRFyAJbcFb4H0oPk7IG/NjiwlHDaQeP3ANx0wtX8iNw3TPr1cy0WpiHyKsrPnLZWXpLBMorBPzgT9F6i9EPE4juGFa5LqQ48qJAM5T6N6DSIH74AelKsuPkOGDg2bN0BID1M1ghPtmtOmyI+Dw0KcxyD/dLb4Z8BQlvIDwNwTF2K9fj4WlTmFwJM3BD86mpJLkf0MsToyVe795ggnb2LBuwfQnUtndllUZsR71NdYQou5kVBXDu4bOK1ZIpTMAQ0fHq+17FQ/ZbXnqFjbpw611+qXcTk9h75zWz9QfIFlKIEl9gxY0yQfQdrId3VnvZ5tWXr71D8DptJ4D0Bl3rB4BloGLWRoO/uTb1iA5IWtDbrC31AoD8FXkwbgDgZpg+DhrTAXq8MGek8BbwYAYgDMyNHbIFTCzQRHA4x/8J9EJ5Rsq9DyKHrdMm1Y9mN970Geo5kvcKRngd+1SE+oMXnHTwx5D+BQ8EbegTc0Fhuxuj6eAtDuAKaUo3kdGrc6Ap8SK6ZUyBZXz/SxHvU7XCe3jUXkVduPm7nYcBR9luFG/c7fAY+irYMj0gglujPAkwg+JbtkvVsdPNKhs0bfgJvuIxCUbEq0turI9H0yFyfXXAj2BsXxDqZYPr9imvaWajCGmRKeAvb18zOEzYCAK8McVUEghcpuX7RuV8OFaAu1t9fry2EDfQm6w029UuWMOW8TswLrMklGKXjMCjEsph374gRjMbSFaOAQTmPSknTg2cdTwBTgaGUKTZbTY8b8fyEQCzERC8wQHu1eyFDAeol3YTOfi4Zmj2qSMxbLeYCxK+jJzlCAOGFvGOBQIk533yRjNy5HYiEOLHGaIBkhS4F4Qn0Mih2IlfRVcnNn9PgXC5Rt/aWVxBTmfs9SgPjo4kZyFDFmfJWsLCLwMYLL7sFcpLyk8j2Kgv2sbPqEjlpMQZLMTexa6Z+nixvlUczb4wDV6NrypbiA+IHjRZoCQTpjhWrZTJpgW1jZyEw7eUeJJdc3g9AZIEPrn1/JPEC9WqQSz4GcxleG7WQVojE4gtPEeBfIN1egLMq07SvzfSsouL7bY7qTXmLD7CTd6wDVmGUe+LTgmu+olfXYtOtYXYx7vaACZITpX4ZkIyLNhATdffSYIR8asNbd15lyS2BM4nzggx84AOwRGI6bQgX4KotSgPQn84kp38jzksIGXQ0RTYg8bU79JyYwNcF85Et/nVxkq37DdHfD49DT3KO+snVeku8jH20bmgf2huUlxfDPfeRL80//WidYG0rzvXpYscZvQ9cHHAN8gOf8zKqlDv38zrN/5zOrB9Zm6Gg1vkq4+1BV6q19GMdbkrZN0DwIyslXLnoP5GPC06OrRubRY0anE9Y8X3UusitfUOavBjhZ+vEKe+tU/dWAzP8PkzkCfwNSHIOCPOgVNwAAAABJRU5ErkJggg==',
  'sub_prv':'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAIAAAADnC86AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAKKADAAQAAAABAAAAKAAAAAB65masAAACd0lEQVRYCWNkWLKMYSAA00BYCrJz1GK6hfyABTULqV7UEeCv0NZyEBMX5WB/+/Pn4Vevu65dP/vuHanmMDMEBROph4mRsVxba5qZ6ZpHj7uuXSs7f3Hn8+dAvVPNTARYWYEu+EekQWBljMTn41ItzQAZmdDDR559/45shSg7+zIbqxNv3tZevIQsjp9NbBxr8vMVa2qEHzmKZivQ9Nc/f0YeOZakrGQiLITfMmRZYi0G2jrxxs0n374ha4az3/z82XblarmWFlyEIINYi+3ExI6+foPHuCOvX9uKieJRgCZFrMXiHByXP3xA04zMvfrhowg7OyOyEF42sRYzMzL++ocv2f75/x9oETDl47UOIUmsxQgdVGKNPIvxFSBvQ4OF2NjIC9r3v34Jr14LinYcAF9ZDbSVcelyHBoJCP+JigAmtL/gFIdV6ciLY3xBjTWIgIIafHy9xoaGgoLXPn4qPXf+/Pv3mCoJZmeSg1qQjW23s+PGx0+Nt++cf/fedicHKU5OTIsJipBssZeUFLDQnnXnzvPv35c+eLDu8eMQOVmC1mAqINliDmbmH3//wg368fcfOzMznEs8g2SLtz576i0tBfQ3MLfYi4nFKCqsf/yEePvgKklOXC++/wg4eHiamclGB7s7nz/HHD0GJOHGEc8g2cdAo4++fq2/dTsw3eps2bbr+QviLUNWSY7FyPpxsfEUlhAttLIYl4Pg4uRb3HT5yj/cRTHBAoTkxAV3MtBiOBuTMXiDGp+PP/z6BazdMH1DjMiXP3/wRATQBHwNAWA8Ed94Q3MN0Fb8oY3Px0CdeGpyNJtI5ZKfqkm1CU39qMVoAUI7LgAoX8MiWl1UgAAAAABJRU5ErkJggg==',
  'sub_pub':'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAIAAAADnC86AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAKKADAAQAAAABAAAAKAAAAAB65masAAACe0lEQVRYCWOsWijGMBCAaSAsBdk5ajHdQn7AgpqFVC+KC2jY6+QpSlhxc4h8+/nuwcsTh69Offr2IqnmkGAxIyOTnXaOlVbaoStTjt2Y9frjHWFeJXkxsxjHRWfvLNt3sfff/z/EW89IfD621c7WkvNcfjDl07cXyBZwcwiH28549PrsngsdyOL42cTGsSi/qo125oqDaWi2Ak3/+uPtikPpxiqR0sIG+C1DliXWYhvtrGPXZ3/89gxZM5wNjOyDlyfa6eTARQgyiLVYUczi4atTeIx7+OqkgrgFHgVoUsRazMMp+vL9dTTNyNyXH25ysQsxMjAiC+JhE2sxIyPz33+/8BgESdLAlI9HDbIUseqQ9VCFPfIsxleA1ITf5GQXIC9gv//60LpC4z/Df1za8RWZQFurF4nj0olfvDn2GTCh/f//F5eykRfH+IIaVygBy21PkwYpId1XH27tONv47N1lTJUESxKSg5qTTSDRddX1xzumbnE9e3d5vMtyPi4JTIsJipBssZqM86NXp0/fWvz5+8uL99ZefbhVW96XoDWYCki2mJWJ/fffH3CD/vz9ycLEBucSzyDZ4ptP92jIuKpLuwBzi6K4lYFSyLVH24i3D66S5MT1+furJfvj/cw7Y5wWvv10f/WRrLef78ONI55Bso+BRgMr5smbHRkYGCdtsr/97ADxliGrJMdiZP242HgKS4gWWlmMy0FwcfIt3n+x9///f3CD0BgECxCSExfcgn2XeuFsTMbgDWp8Pv7x6yOwdsP0DTEiv35/xRMRQBPwNQSA8UR84w3NNUBb8Yc2Ph8DdeKpydFsIpVLfqom1SY09aMWowUI7bgAIgfJCsZyc3UAAAAASUVORK5CYII=',
  'tgw':'data:image/png;base64,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',
  'vgw':'data:image/png;base64,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',
  'vpc':'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAIAAAADnC86AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAKKADAAQAAAABAAAAKAAAAAB65masAAADwUlEQVRYCe2WWWyNURDHf7dqaXWhqipCqRJ7W1vqwU6CoqGCByG22MKDByH2EBKpChERhNhjjV3tgibW0Apa0qrGvhSt202r5iit+33nfr3JVX1g8j2cM9v/mzlzzowtLqaEqiCPqgBVmP+B/1rm/71Ue7qY29p1aRFFSATBLagmRjY+ZJJxj4cXyfngog8HNZsr9zgymm6jSLtJxl1epPA1X7kIDqNZR1r34tou7p9zcOrKpuKIuwyjVXf2zuXjSweHz5KQL/kcQ+dQw4s7xxykFW4qKC5JbORgDi8zopb5zXrO4eV0HU79ptT0pkEYfvXLhFaLCiLuHMPNQ9g/WrnIfsv1A8TMU3HnvMe7Dm/TORVPQa6VlRWwzUZoF86st7IvlckZ12vM7SN8eo3Ng/7T6DuFU2usDK1S7RtIXvbPUrLyAUWFnN+oUIVKvnFpC0064BdkZWQFXDuA/C9Wxs5kXwt4/oDWPale05mKkybhWYMe4xi+kFepTi21AjkdqTLJdspV2vVl6jba9tEqojljQY1dTO5nts/iS5bezMyt5UO7fkQMxKMa34q5e5Kds/ELZMRSVWvvMowWGuDwARTmcXyVUdXZPiiUyEGERZF+ixNxvH6iXrdOQ4kayYNLXNhE9juNqQa4TW8ubNSoalmxSwhoRFICW6erSpRLLP8tD9zJ1fjWIyJaVXj6bRLWGa01wHUb8j7TqKfdy4k2DSc+VlVySDgRg2jUBi8f8u2quCTbV3dw4yAzdmqANVUtd0OO2UWSgU1Qx8TRczxP77B5MsXFbJmi1r0nMWoFRQV6T5qIXz2mYUvSbukNNFwbQc2JH1YuEbDks+qAZ+4pZxpWmohTr6m6kDRWKmmAH14mL4chc9SrW3mkSbWAHV2hgp64AfsndaHNJOe6b76Z7cixHNj1wMVFJO4hcS9S4d7+ju7+0E4P/NN5iWrDhv7/O25pSB6a4yrXkodM0mMmSyOzuoFTgj0LnwAK7Hj5GmSqRHKz8W+gf7ncAwa5e43bq3EsfKARWN7ttBvqYXmZYhTJ3l3g1ETVGxJ303GIakSSWOXUUz2c0p1kMhFpyhUNsEtTpsbuF0s64OiVPLpMZvKPG+ivilFu4+c3qmHIr8gwKiObmSyLy6xu4kjhJKxVbTQwhP0LkNlBJnCZvApz6TVBMQ8sMtn8YLgbcanX6rXoMVbN2FJlglonWGU76TTX9yM3U0t/BrjMtYxp0hll+LIeTEXf3VSXQZYuJFz5XCF3q9oVDK3Of2BtWiqDWWWp/g6ffx+cr3WDNAAAAABJRU5ErkJggg==',
  'vpce':'data:image/png;base64,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',
};
const ICON_MAP={
  IGW:'igw',NAT:'nat',TGW:'tgw',VGW:'vgw',VPCE:'vpce',PCX:'pcx',
  EC2:'ec2',ALB:'alb',INET:'internet',VPC:'vpc',SUB_PUB:'sub_pub',SUB_PRV:'sub_prv'
};

// Landing Zone Hub-Spoke Layout
function buildLandingZoneLayout(ctx){
  console.log('buildLandingZoneLayout called with', Object.keys(ctx));
  try{
  const {vpcs,subByVpc,sgByVpc,pubSubs,rts,instances,albs,enis,nacls,subRT,
    igws,nats,vpceList,peerings,sharedGws,gwByVpc,vpceByVpc,gwSet2L,
    gn,sid,tw,userHubName,COL,gwColors2,gwFills,ICON_MAP,volumes,zones,
    s3bk,snapshots,snapByVol,tgByAlb,tgs,wafAcls,wafByAlb,
    instBySub,albBySub,eniBySub,volByInst,volBySub,rdsBySub,ecsBySub,lambdaBySub,cfByAlb,recsByZone:lzRecsByZone}=ctx;
  const recsByZoneLZ=lzRecsByZone||{};

  const shapes=[],lines=[],iconSet=new Set();
  let lid=0;
  const NOTEXT='<p style="font-size:1pt;color:transparent">&nbsp;</p>';
  const IC=36,VP=50,VH=80,SG=32,SP=24;
  const EC2W=260,EC2H=34,EC2G=16;
  
  function addIcon(type,x,y){
    iconSet.add(type);
    shapes.push({
      id:'icon_'+(lid++),type:'rectangle',
      boundingBox:{x,y,w:IC,h:IC},
      text:NOTEXT,
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'image',ref:(ICON_MAP[type]||type.toLowerCase())+'.png'}}
    });
  }
  
  // Identify hub VPC
  const hubKeywords=['shared','connectivity','hub','transit','network','core'];
  let hubVpc=null;
  if(userHubName){
    hubVpc=vpcs.find(v=>{
      const vn=gn(v,v.VpcId).toLowerCase();
      return vn.includes(userHubName);
    });
  }
  if(!hubVpc){
    hubVpc=vpcs.find(v=>{
      const vn=gn(v,v.VpcId).toLowerCase();
      return hubKeywords.some(k=>vn.includes(k));
    });
  }
  // Fallback: VPC with most TGW/peering connections
  if(!hubVpc){
    let maxConn=0;
    vpcs.forEach(v=>{
      let conn=0;
      rts.filter(rt=>rt.VpcId===v.VpcId).forEach(rt=>{
        (rt.Routes||[]).forEach(r=>{
          if(r.TransitGatewayId||r.VpcPeeringConnectionId)conn++;
        });
      });
      peerings.forEach(p=>{
        if(p.RequesterVpcInfo?.VpcId===v.VpcId||p.AccepterVpcInfo?.VpcId===v.VpcId)conn++;
      });
      if(conn>maxConn){maxConn=conn;hubVpc=v;}
    });
  }
  if(!hubVpc)hubVpc=vpcs[0];
  
  const spokeVpcs=vpcs.filter(v=>v.VpcId!==hubVpc.VpcId);
  const shapeIds={};
  
  // Layout constants
  const HUB_X=100,HUB_Y=120;
  const SPOKE_START_X=900;
  const SPOKE_START_Y=80;
  const SPOKE_COL_W=700;
  const SPOKE_ROW_GAP=40;
  const SPOKES_PER_COL=4;
  const numSpokeCols=Math.max(1,Math.ceil(spokeVpcs.length/SPOKES_PER_COL));
  const EXT_X=SPOKE_START_X+numSpokeCols*SPOKE_COL_W+100;
  
  // Shared resource builder for LZ subnets (mirrors grid logic)
  const LZ_NAME_H=36,LZ_DETAIL_H=28,LZ_CHILD_LINE_H=22,LZ_CHILD_GAP=8,LZ_RES_PAD=10;
  const LZ_CHILD_INNER_W=EC2W-24;
  function lzChildLines(label){return Math.max(1,Math.ceil(tw(label,8)/LZ_CHILD_INNER_W));}
  function lzChildH(label){return lzChildLines(label)*LZ_CHILD_LINE_H+8;}
  function lzResHeight(r){
    const chs=r.children||[];
    let h=LZ_RES_PAD+LZ_NAME_H;
    if(r.detail)h+=LZ_DETAIL_H;
    if(chs.length>0){h+=LZ_CHILD_GAP;chs.forEach(ch=>{const lbl=ch.type+': '+ch.name+(ch.detail?' \u00b7 '+ch.detail:'');h+=lzChildH(lbl)+LZ_CHILD_GAP;});}
    h+=LZ_RES_PAD;
    return Math.max(EC2H,h);
  }
  function lzBuildResources(subId){
    const sInsts=instBySub[subId]||[];
    const sAlbs=albBySub[subId]||[];
    const sRds=(rdsBySub||{})[subId]||[];
    const sEcs=(ecsBySub||{})[subId]||[];
    const sLam=(lambdaBySub||{})[subId]||[];
    const sEni=(eniBySub||{})[subId]||[];
    const attached=new Set();
    const res=[];
    sInsts.forEach(i=>{
      const ch=[];const ie=(enis||[]).filter(e=>e.Attachment&&e.Attachment.InstanceId===i.InstanceId);
      ie.forEach(e=>attached.add(e.NetworkInterfaceId));
      if(_showNested){
        ie.forEach(e=>ch.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),detail:e.PrivateIpAddress||'',col:'#3b82f6'}));
        ((volByInst||{})[i.InstanceId]||[]).forEach(v=>{const sc=((snapByVol||{})[v.VolumeId]||[]).length;ch.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),detail:sc?sc+' snap':'',col:'#f59e0b'});});
      }
      res.push({type:'EC2',name:gn(i,i.InstanceId),id:i.InstanceId,detail:i.InstanceType,children:ch,resCol:'#10b981'});
    });
    sAlbs.forEach(lb=>{
      const ch=[];
      if(_showNested){
        ((tgByAlb||{})[lb.LoadBalancerArn]||[]).forEach(tg=>ch.push({type:'TG',name:tg.TargetGroupName||'TG',detail:(tg.Targets||[]).length+' tgt',col:'#06b6d4'}));
        ((wafByAlb||{})[lb.LoadBalancerArn]||[]).forEach(w=>ch.push({type:'WAF',name:w.Name||'WAF',detail:(w.Rules||[]).length+' rules',col:'#eab308'}));
      }
      res.push({type:'ALB',name:lb.LoadBalancerName||'ALB',id:lb.LoadBalancerArn,detail:lb.Scheme||'',children:ch,resCol:'#38bdf8'});
    });
    sRds.forEach(db=>res.push({type:'RDS',name:db.DBInstanceIdentifier||'RDS',id:db.DBInstanceIdentifier,detail:db.Engine||'',children:[],resCol:'#3b82f6'}));
    sEcs.forEach(svc=>res.push({type:'ECS',name:svc.serviceName||'ECS',id:svc.serviceName,detail:svc.launchType||'',children:[],resCol:'#f97316'}));
    sLam.forEach(fn=>res.push({type:'FN',name:fn.FunctionName||'Lambda',id:fn.FunctionName,detail:fn.Runtime||'',children:[],resCol:'#a855f7'}));
    sEni.forEach(e=>{if(!attached.has(e.NetworkInterfaceId))res.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),id:e.NetworkInterfaceId,detail:e.PrivateIpAddress||'',children:[],resCol:'#3b82f6'});});
    // Standalone EBS volumes (instance not in EC2 data, placed via ENI subnet)
    ((volBySub||{})[subId]||[]).forEach(v=>{const sc=((snapByVol||{})[v.VolumeId]||[]).length;const att=(v.Attachments||[])[0];
      res.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),id:v.VolumeId,detail:att?att.InstanceId?.slice(-8)||'':'detached',children:[],resCol:'#f59e0b'});});
    return res;
  }
  function lzSubResHeight(subId,subW){
    const resources=lzBuildResources(subId);
    const cols=Math.max(1,Math.floor((subW-SP*2)/(EC2W+EC2G)));
    const rowCount=Math.ceil(resources.length/cols);
    let totalResH=0;
    for(let row=0;row<rowCount;row++){
      let maxH=EC2H;
      for(let c=0;c<cols;c++){const ri=row*cols+c;if(ri<resources.length){const h=lzResHeight(resources[ri]);if(h>maxH)maxH=h;}}
      totalResH+=maxH+EC2G;
    }
    return resources.length>0?VH+totalResH+SP*2:60;
  }
  function lzRenderResources(resources,sx,sy,subW){
    const cols=Math.max(1,Math.floor((subW-SP*2)/(EC2W+EC2G)));
    const rowCount=Math.ceil(resources.length/cols);
    const rowHeights=[];
    for(let row=0;row<rowCount;row++){
      let maxH=EC2H;
      for(let c=0;c<cols;c++){const ri=row*cols+c;if(ri<resources.length){const h=lzResHeight(resources[ri]);if(h>maxH)maxH=h;}}
      rowHeights.push(maxH);
    }
    const rowYOff=[0];
    for(let i=0;i<rowHeights.length;i++)rowYOff.push(rowYOff[i]+rowHeights[i]+EC2G);
    resources.forEach((r,ri)=>{
      const col=ri%cols,row=Math.floor(ri/cols);
      const rx=sx+SP+col*(EC2W+EC2G);
      const ry=sy+VH+rowYOff[row];
      const rH=lzResHeight(r);
      const rc=r.resCol||'#232F3E';
      const maxResChars=Math.floor((EC2W-20)/8);
      const dispResName=r.name.length>maxResChars?r.name.substring(0,maxResChars-2)+'..':r.name;
      let resHtml='<p style="font-size:9pt;color:'+rc+';font-weight:bold;text-align:left;padding:4px 6px">'+r.type+': '+dispResName+'</p>';
      if(r.detail)resHtml+='<p style="font-size:7pt;color:#6B7280;text-align:left;padding:0 6px">'+r.detail+'</p>';
      (r.children||[]).forEach(ch=>{
        const chLabel=ch.type+': '+ch.name+(ch.detail?' \u00b7 '+ch.detail:'');
        resHtml+='<p style="font-size:8pt;color:'+ch.col+';font-weight:bold;text-align:left;padding:2px 6px;margin:4px 0">\u00a0\u00a0'+chLabel+'</p>';
      });
      shapes.push({id:'res_'+(lid++),type:'rectangle',boundingBox:{x:rx,y:ry,w:EC2W,h:rH},text:resHtml,
        style:{stroke:{color:rc,width:1},fill:{type:'color',color:'#FFFFFF'}},
        customData:[{key:'Type',value:r.type},{key:'Name',value:r.name||''},{key:'ID',value:r.id||''}]
      });
    });
  }

  // Helper to compute VPC height
  function vpcHeight(vpc){
    const ss=subByVpc[vpc.VpcId]||[];
    let h=VH+VP;
    ss.forEach(s=>{
      const subW=500;
      h+=Math.max(60,lzSubResHeight(s.SubnetId,subW))+SG;
    });
    return h;
  }
  
  // Place Hub VPC (larger, center-left)
  const hubSubs=subByVpc[hubVpc.VpcId]||[];
  const hubW=650;
  const hubH=vpcHeight(hubVpc)+100;
  const hubLabel=gn(hubVpc,hubVpc.VpcId)+' (HUB)\n'+hubVpc.CidrBlock;
  const hubId='vpc_hub';
  shapeIds[hubVpc.VpcId]=hubId;
  
  shapes.push({
    id:hubId,type:'roundedRectangleContainer',
    boundingBox:{x:HUB_X,y:HUB_Y,w:hubW,h:hubH},
    text:NOTEXT,
    style:{stroke:{color:'#7C3AED',width:4,style:'dashed'},fill:{type:'color',color:'#F5F3FF'}},
    magnetize:true,
    customData:[{key:'VPC ID',value:hubVpc.VpcId},{key:'Name',value:gn(hubVpc,hubVpc.VpcId)},{key:'Role',value:'Hub / Connectivity'},{key:'CIDR',value:hubVpc.CidrBlock}]
  });
  addIcon('VPC',HUB_X+6,HUB_Y+4);
  
  const hubLabelDisp='HUB: '+gn(hubVpc,hubVpc.VpcId)+' ('+hubVpc.CidrBlock+')';
  shapes.push({
    id:'hublbl',type:'rectangle',
    boundingBox:{x:HUB_X+IC+12,y:HUB_Y+4,w:hubW-IC-24,h:VH-10},
    text:'<p style="font-size:14pt;font-weight:bold;color:#7C3AED;text-align:left;padding:4px 8px">'+hubLabelDisp+'</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });
  
  // Hub gateways inside hub VPC
  const hubGws=gwByVpc[hubVpc.VpcId]||[];
  const hubGwBadgeW=hubW-VP*2;
  let gwY=HUB_Y+VH+20;
  hubGws.forEach((gw,i)=>{
    const nm=gwNames[gw.gwMapId]||gwNames[gw.id]||sid(gw.gwMapId||gw.id);
    const gc=gwColors2[gw.type]||'#546E7A';
    const gf=gwFills[gw.type]||'#F5F0FF';
    const gwCD=[{key:'Gateway ID',value:gw.id},{key:'Type',value:gw.type},{key:'Name',value:nm}];
    if(gw.type==='NAT'){
      const natGw=nats.find(n=>n.NatGatewayId===gw.id);
      if(natGw){
        gwCD.push({key:'State',value:natGw.State||''});
        gwCD.push({key:'Connectivity',value:natGw.ConnectivityType||'public'});
        const pubIp=(natGw.NatGatewayAddresses||[])[0]?.PublicIp;
        const privIp=(natGw.NatGatewayAddresses||[])[0]?.PrivateIp;
        if(pubIp)gwCD.push({key:'Public IP',value:pubIp});
        if(privIp)gwCD.push({key:'Private IP',value:privIp});
      }
    }
    if(gw.type==='IGW'){
      const igw=igws.find(g=>g.InternetGatewayId===gw.id);
      if(igw){
        const att=(igw.Attachments||[]).map(a=>a.VpcId).join(', ');
        gwCD.push({key:'Attached VPCs',value:att||'None'});
      }
    }
    shapes.push({
      id:'hubgw_'+i,type:'rectangle',
      boundingBox:{x:HUB_X+VP,y:gwY,w:hubGwBadgeW,h:50},
      text:NOTEXT,
      style:{stroke:{color:gc,width:2},fill:{type:'color',color:gf}},
      customData:gwCD
    });
    addIcon(gw.type,HUB_X+VP+8,gwY+7);
    shapes.push({
      id:'hubgw_lbl_'+i,type:'rectangle',
      boundingBox:{x:HUB_X+VP+50,y:gwY+8,w:hubGwBadgeW-60,h:34},
      text:'<p style="font-size:10pt;font-weight:bold;color:#232F3E;text-align:left">'+gw.type+': '+nm+'</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });
    gwY+=60;
  });
  
  // Hub subnets with resources
  let hubSubY=gwY+20;
  const hubSubW=hubW-VP*2;
  hubSubs.forEach(s=>{
    const sName=gn(s,s.SubnetId);
    const isPub=pubSubs.has(s.SubnetId);
    const fc=isPub?COL.pubFont:COL.prvFont;
    const fill=isPub?COL.pubFill:COL.prvFill;
    const stroke=isPub?COL.pubStroke:COL.prvStroke;
    const resources=lzBuildResources(s.SubnetId);
    const subH=Math.max(60,lzSubResHeight(s.SubnetId,hubSubW));
    const rt=subRT[s.SubnetId];
    const nacl=nacls?nacls[s.SubnetId]:null;
    const rtName=rt?gn(rt,rt.RouteTableId):'Main';
    const naclName=nacl?gn(nacl,nacl.NetworkAclId):'Default';
    const sx=HUB_X+VP;
    shapes.push({
      id:'hubsub_'+(lid++),type:'rectangle',
      boundingBox:{x:sx,y:hubSubY,w:hubSubW,h:subH},
      text:NOTEXT,
      style:{stroke:{color:stroke,width:2},fill:{type:'color',color:fill}},
      customData:[
        {key:'Subnet ID',value:s.SubnetId},{key:'Name',value:sName},
        {key:'CIDR',value:s.CidrBlock||''},{key:'AZ',value:s.AvailabilityZone||''},
        {key:'Type',value:isPub?'Public':'Private'},
        {key:'Route Table',value:rtName+(rt?' ('+rt.RouteTableId+')':'')},
        {key:'NACL',value:naclName+(nacl?' ('+nacl.NetworkAclId+')':'')}
      ]
    });
    addIcon(isPub?'SUB_PUB':'SUB_PRV',sx+6,hubSubY+6);
    const subLabel=sName+' ['+s.CidrBlock+']';
    const maxSubChars=Math.floor((hubSubW-IC-40)/9);
    const dispSubLabel=subLabel.length>maxSubChars?subLabel.substring(0,maxSubChars-2)+'..':subLabel;
    shapes.push({id:'sublbl_'+(lid++),type:'rectangle',
      boundingBox:{x:sx+IC+12,y:hubSubY+6,w:hubSubW-IC-24,h:32},
      text:'<p style="font-size:9pt;font-weight:bold;color:'+fc+';text-align:left;padding:4px 6px">'+dispSubLabel+'</p>',
      style:{stroke:{color:fill,width:0},fill:{type:'color',color:fill}}
    });
    if(resources.length>0) lzRenderResources(resources,sx,hubSubY,hubSubW);
    hubSubY+=subH+SG;
  });
  
  // Place Spoke VPCs
  const spokePositions={};
  let spokeY=SPOKE_START_Y;
  let spokeCol=0;
  
  spokeVpcs.forEach((vpc,idx)=>{
    if(idx>0&&idx%SPOKES_PER_COL===0){
      spokeCol++;
      spokeY=SPOKE_START_Y;
    }
    const spokeX=SPOKE_START_X+spokeCol*SPOKE_COL_W;
    const ss=subByVpc[vpc.VpcId]||[];
    const spokeW=550;
    const spokeSubWCalc=spokeW-40;
    let spokeSubsH=0;
    ss.forEach(s2=>{spokeSubsH+=Math.max(45,lzSubResHeight(s2.SubnetId,spokeSubWCalc))+SG;});
    const spokeH=Math.max(200, VH+20+spokeSubsH+40);
    const vpcId='vpc_spoke_'+idx;
    shapeIds[vpc.VpcId]=vpcId;
    spokePositions[vpc.VpcId]={x:spokeX,y:spokeY,w:spokeW,h:spokeH};
    
    shapes.push({
      id:vpcId,type:'roundedRectangleContainer',
      boundingBox:{x:spokeX,y:spokeY,w:spokeW,h:spokeH},
      text:NOTEXT,
      style:{stroke:{color:COL.vpcStroke,width:2,style:'dashed'},fill:{type:'color',color:COL.vpcFill}},
      magnetize:true,
      customData:[{key:'VPC ID',value:vpc.VpcId},{key:'Name',value:gn(vpc,vpc.VpcId)},{key:'Role',value:'Spoke / Workload'},{key:'CIDR',value:vpc.CidrBlock}]
    });
    addIcon('VPC',spokeX+6,spokeY+4);
    
    const spokeLbl=gn(vpc,vpc.VpcId)+' ('+vpc.CidrBlock+')';
    const maxChars=Math.floor((spokeW-IC-40)/9);
    const dispLbl=spokeLbl.length>maxChars?spokeLbl.substring(0,maxChars-2)+'..':spokeLbl;
    shapes.push({
      id:'spokelbl_'+idx,type:'rectangle',
      boundingBox:{x:spokeX+IC+12,y:spokeY+4,w:spokeW-IC-24,h:VH-10},
      text:'<p style="font-size:12pt;font-weight:bold;color:'+COL.vpcFont+';text-align:left;padding:4px 8px">'+dispLbl+'</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
    });
    
    // Spoke subnets - all of them
    let subY=spokeY+VH+10;
    const spokeSubW=spokeW-40;
    ss.forEach(s=>{
      const sName=gn(s,s.SubnetId);
      const isPub=pubSubs.has(s.SubnetId);
      const fc=isPub?COL.pubFont:COL.prvFont;
      const fill=isPub?COL.pubFill:COL.prvFill;
      const stroke=isPub?COL.pubStroke:COL.prvStroke;
      const rt=subRT[s.SubnetId];
      const nacl=nacls?nacls[s.SubnetId]:null;
      const rtName=rt?gn(rt,rt.RouteTableId):'Main';
      const naclName=nacl?gn(nacl,nacl.NetworkAclId):'Default';
      const resources=lzBuildResources(s.SubnetId);
      const subH=Math.max(45,lzSubResHeight(s.SubnetId,spokeSubW));
      const sx=spokeX+20;
      shapes.push({
        id:'spokesub_'+(lid++),type:'rectangle',
        boundingBox:{x:sx,y:subY,w:spokeSubW,h:subH},
        text:NOTEXT,
        style:{stroke:{color:stroke,width:1.5},fill:{type:'color',color:fill}},
        customData:[
          {key:'Subnet ID',value:s.SubnetId},{key:'Name',value:sName},
          {key:'CIDR',value:s.CidrBlock||''},{key:'AZ',value:s.AvailabilityZone||''},
          {key:'Type',value:isPub?'Public':'Private'},
          {key:'Route Table',value:rtName+(rt?' ('+rt.RouteTableId+')':'')},
          {key:'NACL',value:naclName+(nacl?' ('+nacl.NetworkAclId+')':'')}
        ]
      });
      addIcon(isPub?'SUB_PUB':'SUB_PRV',sx+6,subY+6);
      const spokeSubLabel=sName+' ['+s.CidrBlock+']';
      const maxSpokeChars=Math.floor((spokeSubW-IC-40)/8);
      const dispSpokeLabel=spokeSubLabel.length>maxSpokeChars?spokeSubLabel.substring(0,maxSpokeChars-2)+'..':spokeSubLabel;
      shapes.push({id:'sublbl_'+(lid++),type:'rectangle',
        boundingBox:{x:sx+IC+12,y:subY+6,w:spokeSubW-IC-24,h:32},
        text:'<p style="font-size:8pt;font-weight:bold;color:'+fc+';text-align:left;padding:4px 6px">'+dispSpokeLabel+'</p>',
        style:{stroke:{color:fill,width:0},fill:{type:'color',color:fill}}
      });
      if(resources.length>0) lzRenderResources(resources,sx,subY,spokeSubW);
      subY+=subH+SG;
    });
    
    spokeY+=spokeH+SPOKE_ROW_GAP;
  });
  
  // External Connectivity Zone - wider with more room
  const extY=HUB_Y;
  const extW=340;
  shapes.push({
    id:'ext_zone',type:'rectangle',
    boundingBox:{x:EXT_X,y:extY,w:extW,h:400},
    text:NOTEXT,
    style:{stroke:{color:'#64748B',width:2,style:'dashed'},fill:{type:'color',color:'#F8FAFC'}}
  });
  shapes.push({
    id:'ext_title',type:'rectangle',
    boundingBox:{x:EXT_X+10,y:extY+10,w:extW-20,h:30},
    text:'<p style="font-size:11pt;font-weight:bold;color:#334155;text-align:center">External Connectivity</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });
  
  // Internet node
  shapes.push({
    id:'inet',type:'rectangle',
    boundingBox:{x:EXT_X+30,y:extY+60,w:extW-60,h:60},
    text:NOTEXT,
    style:{stroke:{color:'#232F3E',width:2},fill:{type:'color',color:'#E2E8F0'}},
    customData:[{key:'Type',value:'Internet Gateway / Public Access'},{key:'Description',value:'External internet connectivity'}]
  });
  addIcon('INET',EXT_X+38,extY+72);
  shapes.push({
    id:'inet_lbl',type:'rectangle',
    boundingBox:{x:EXT_X+80,y:extY+72,w:extW-120,h:36},
    text:'<p style="font-size:11pt;font-weight:bold;color:#232F3E;text-align:left">Internet</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
  });
  
  // On-premises / VPN
  if(sharedGws.some(g=>g.type==='VGW')||gwSet2L.has('vgw')){
    shapes.push({
      id:'onprem',type:'rectangle',
      boundingBox:{x:EXT_X+30,y:extY+140,w:extW-60,h:60},
      text:NOTEXT,
      style:{stroke:{color:'#7C3AED',width:2},fill:{type:'color',color:'#F5F3FF'}},
      customData:[{key:'Type',value:'Virtual Private Gateway / VPN'},{key:'Description',value:'On-premises connectivity'}]
    });
    addIcon('VGW',EXT_X+38,extY+152);
    shapes.push({
      id:'onprem_lbl',type:'rectangle',
      boundingBox:{x:EXT_X+80,y:extY+152,w:extW-120,h:36},
      text:'<p style="font-size:11pt;font-weight:bold;color:#7C3AED;text-align:left">On-Premises / VPN</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });
  }
  
  // Transit Gateway (shared)
  const tgwGws=sharedGws.filter(g=>g.type==='TGW');
  if(tgwGws.length>0){
    shapes.push({
      id:'tgw_shared',type:'rectangle',
      boundingBox:{x:EXT_X+30,y:extY+220,w:extW-60,h:60},
      text:NOTEXT,
      style:{stroke:{color:'#EC4899',width:2},fill:{type:'color',color:'#FDF2F8'}},
      customData:[{key:'Type',value:'Transit Gateway'},{key:'TGW IDs',value:tgwGws.map(g=>g.id).join(', ')}]
    });
    addIcon('TGW',EXT_X+38,extY+232);
    shapes.push({
      id:'tgw_shared_lbl',type:'rectangle',
      boundingBox:{x:EXT_X+80,y:extY+232,w:extW-120,h:36},
      text:'<p style="font-size:11pt;font-weight:bold;color:#EC4899;text-align:left">Transit Gateway</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });
  }
  
  // Hub to External lines - route above all spokes using straight segments
  const routeAboveY=Math.min(HUB_Y,SPOKE_START_Y)-60;
  const extMidX=EXT_X+extW/2;
  
  // Hub -> Internet: up from hub top, across above spokes, down to ext zone top border
  lines.push({
    id:'hub_inet_1',lineType:'straight',
    stroke:{color:'#10B981',width:3},
    endpoint1:{type:'shapeEndpoint',style:'none',shapeId:hubId,position:{x:0.8,y:0}},
    endpoint2:{type:'positionEndpoint',style:'none',position:{x:HUB_X+hubW*0.8,y:routeAboveY}}
  });
  lines.push({
    id:'hub_inet_2',lineType:'straight',
    stroke:{color:'#10B981',width:3},
    endpoint1:{type:'positionEndpoint',style:'none',position:{x:HUB_X+hubW*0.8,y:routeAboveY}},
    endpoint2:{type:'positionEndpoint',style:'none',position:{x:extMidX,y:routeAboveY}}
  });
  lines.push({
    id:'hub_inet_3',lineType:'straight',
    stroke:{color:'#10B981',width:3},
    endpoint1:{type:'positionEndpoint',style:'none',position:{x:extMidX,y:routeAboveY}},
    endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:'inet',position:{x:0.5,y:0}}
  });
  
  // Hub -> TGW connection (if TGW exists) - route above spokes
  if(tgwGws.length>0){
    const tgwRouteY=routeAboveY-30;
    lines.push({
      id:'hub_tgw_1',lineType:'straight',
      stroke:{color:'#EC4899',width:2},
      endpoint1:{type:'shapeEndpoint',style:'none',shapeId:hubId,position:{x:0.6,y:0}},
      endpoint2:{type:'positionEndpoint',style:'none',position:{x:HUB_X+hubW*0.6,y:tgwRouteY}}
    });
    lines.push({
      id:'hub_tgw_2',lineType:'straight',
      stroke:{color:'#EC4899',width:2},
      endpoint1:{type:'positionEndpoint',style:'none',position:{x:HUB_X+hubW*0.6,y:tgwRouteY}},
      endpoint2:{type:'positionEndpoint',style:'none',position:{x:EXT_X+extW/2,y:tgwRouteY}}
    });
    lines.push({
      id:'hub_tgw_3',lineType:'straight',
      stroke:{color:'#EC4899',width:2},
      endpoint1:{type:'positionEndpoint',style:'none',position:{x:EXT_X+extW/2,y:tgwRouteY}},
      endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:'tgw_shared',position:{x:0.5,y:0}}
    });
  }
  
  // Hub -> Spokes (peering) and TGW -> Spokes (TGW routes)
  spokeVpcs.forEach((vpc,idx)=>{
    const sp=spokePositions[vpc.VpcId];
    if(!sp)return;
    
    // Check connection type
    let connType='peering';
    let connColor='#FB923C';
    rts.filter(rt=>rt.VpcId===vpc.VpcId).forEach(rt=>{
      (rt.Routes||[]).forEach(r=>{
        if(r.TransitGatewayId){connType='tgw';connColor='#EC4899';}
      });
    });
    
    if(connType==='tgw'&&tgwGws.length>0){
      // TGW -> Spoke: straight horizontal from TGW left to spoke right
      const tgwCount=spokeVpcs.filter((v,i)=>{
        let ct='peering';
        rts.filter(rt=>rt.VpcId===v.VpcId).forEach(rt=>{
          (rt.Routes||[]).forEach(r=>{if(r.TransitGatewayId)ct='tgw';});
        });
        return ct==='tgw'&&i<=idx;
      }).length;
      const tgwYPos=tgwCount>1?0.2+(tgwCount-1)*(0.6/(Math.max(1,spokeVpcs.length-1))):0.5;
      lines.push({
        id:'tgw_spoke_'+idx,lineType:'straight',
        stroke:{color:'#EC4899',width:2},
        endpoint1:{type:'shapeEndpoint',style:'none',shapeId:'tgw_shared',position:{x:0,y:Math.min(0.9,tgwYPos)}},
        endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:shapeIds[vpc.VpcId],position:{x:1,y:0.5}}
      });
    } else {
      // Direct hub -> spoke (peering)
      lines.push({
        id:'hub_spoke_'+idx,lineType:'elbow',
        stroke:{color:connColor,width:2,style:'dashed'},
        endpoint1:{type:'shapeEndpoint',style:'none',shapeId:hubId,position:{x:1,y:spokeVpcs.length>1?0.1+idx*(0.8/(spokeVpcs.length-1)):0.5}},
        endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:shapeIds[vpc.VpcId],position:{x:0,y:0.5}}
      });
    }
  });
  
  // Legend
  const legendX=HUB_X;
  const legendY=HUB_Y+hubH+40;
  shapes.push({
    id:'legend_box',type:'rectangle',
    boundingBox:{x:legendX,y:legendY,w:300,h:140},
    text:NOTEXT,
    style:{stroke:{color:'#CBD5E1',width:1},fill:{type:'color',color:'#FFFFFF'}}
  });
  shapes.push({
    id:'legend_title',type:'rectangle',
    boundingBox:{x:legendX+10,y:legendY+8,w:280,h:24},
    text:'<p style="font-size:11pt;font-weight:bold;color:#334155;text-align:left">Legend</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });
  
  // Legend items
  const legendItems=[
    {color:'#7C3AED',label:'Hub VPC',y:40},
    {color:'#3B82F6',label:'Spoke VPC',y:65},
    {color:'#10B981',label:'Internet Gateway',y:90},
    {color:'#EC4899',label:'Transit Gateway',y:115}
  ];
  legendItems.forEach(item=>{
    shapes.push({
      id:'leg_'+item.y,type:'rectangle',
      boundingBox:{x:legendX+15,y:legendY+item.y,w:20,h:16},
      text:NOTEXT,
      style:{stroke:{color:item.color,width:2},fill:{type:'color',color:item.color+'20'}}
    });
    shapes.push({
      id:'leglbl_'+item.y,type:'rectangle',
      boundingBox:{x:legendX+45,y:legendY+item.y,w:240,h:18},
      text:'<p style="font-size:9pt;color:#334155;text-align:left">'+item.label+'</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
    });
  });
  
  // Route 53 DNS Zone section
  if(zones&&zones.length>0){
    const dnsX=HUB_X;
    const dnsY=Math.max(HUB_Y+hubH,spokeY)+60;
    const pubZ=zones.filter(z=>!z.Config?.PrivateZone);
    const privZ=zones.filter(z=>z.Config?.PrivateZone);
    const dnsExp=(_detailLevel>=1);
    const cols=dnsExp?1:2;
    const colW=dnsExp?700:460;
    const recRowH=16;
    const recHeaderH=18;

    // Pre-calculate per-zone height
    const zoneHeights=[];
    zones.forEach(z=>{
      if(!dnsExp){zoneHeights.push(54);return}
      const isPub=!z.Config?.PrivateZone;
      const zid=z.Id.replace('/hostedzone/','');
      const assocVpcs=(!isPub&&z.VPCs)?z.VPCs.length:0;
      const zRecs=recsByZoneLZ[zid]||[];
      let h=28; // header area (name line + zone info line)
      if(assocVpcs)h+=recRowH;
      if(zRecs.length>0) h+=recHeaderH+zRecs.length*recRowH;
      zoneHeights.push(Math.max(54,h+12));
    });
    const zoneGap=8;

    let totalZoneH=0;
    if(dnsExp){zoneHeights.forEach(h=>{totalZoneH+=h+zoneGap})}
    else{totalZoneH=Math.ceil(zones.length/cols)*62}
    const dnsW=cols*colW+60;
    const dnsH=60+totalZoneH+20;

    shapes.push({
      id:'dns_zone',type:'rectangle',
      boundingBox:{x:dnsX,y:dnsY,w:dnsW,h:dnsH},
      text:NOTEXT,
      style:{stroke:{color:'#0ea5e9',width:2,style:'dashed'},fill:{type:'color',color:'#F0F9FF'}}
    });
    shapes.push({
      id:'dns_title',type:'rectangle',
      boundingBox:{x:dnsX+10,y:dnsY+8,w:dnsW-20,h:30},
      text:'<p style="font-size:12pt;font-weight:bold;color:#0ea5e9;text-align:left">Route 53 Hosted Zones ('+pubZ.length+' public, '+privZ.length+' private)</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });

    let curY=dnsY+48;
    zones.forEach((z,zi)=>{
      const isPub=!z.Config?.PrivateZone;
      const zid=z.Id.replace('/hostedzone/','');
      const assocVpcs=(!isPub&&z.VPCs)?z.VPCs.map(v=>{
        const vid=v.VPCId||v.VpcId;
        const vpc=vpcs.find(vp=>vp.VpcId===vid);
        return gn(vpc||{},vid);
      }).join(', '):'';
      const zh=zoneHeights[zi];
      const zRecs=recsByZoneLZ[zid]||[];

      if(dnsExp){
        const zx=dnsX+20;
        const zCol=isPub?'#10b981':'#0ea5e9';
        shapes.push({
          id:'dns_'+zi,type:'rectangle',
          boundingBox:{x:zx,y:curY,w:colW-20,h:zh},
          text:NOTEXT,
          style:{stroke:{color:zCol,width:1.5},fill:{type:'color',color:isPub?'#F0FDF4':'#F0F9FF'}},
          customData:[
            {key:'Zone ID',value:zid},{key:'Name',value:z.Name},
            {key:'Type',value:isPub?'Public':'Private'},
            {key:'Records',value:String(z.ResourceRecordSetCount)},
            {key:'Associated VPCs',value:assocVpcs||'N/A'}
          ]
        });
        // Line 1: type + name
        shapes.push({
          id:'dnslbl_'+zi+'a',type:'rectangle',
          boundingBox:{x:zx+6,y:curY+4,w:colW-32,h:18},
          text:'<p style="font-size:10pt;font-weight:bold;color:'+zCol+';text-align:left">'+(isPub?'[Public]':'[Private]')+' '+z.Name+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        // Line 2: record count + zone ID
        let ly=curY+22;
        shapes.push({
          id:'dnslbl_'+zi+'b',type:'rectangle',
          boundingBox:{x:zx+6,y:ly,w:colW-32,h:recRowH},
          text:'<p style="font-size:8pt;color:#64748B;text-align:left">'+z.ResourceRecordSetCount+' records | Zone ID: '+zid+' | Type: '+(isPub?'Public':'Private')+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        ly+=recRowH;
        if(assocVpcs){
          shapes.push({
            id:'dnslbl_'+zi+'d',type:'rectangle',
            boundingBox:{x:zx+6,y:ly,w:colW-32,h:recRowH},
            text:'<p style="font-size:8pt;color:#64748B;text-align:left">VPCs: '+assocVpcs+'</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
          ly+=recRowH;
        }
        // Record sets
        if(zRecs.length>0){
          shapes.push({
            id:'dnshdr_'+zi,type:'rectangle',
            boundingBox:{x:zx+6,y:ly,w:colW-32,h:recHeaderH},
            text:'<p style="font-size:7pt;font-weight:bold;color:#475569;text-align:left">NAME                                                  TYPE      VALUE</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
          ly+=recHeaderH;
          zRecs.forEach((rec,ri)=>{
            const rName=rec.Name||'';
            const rType=rec.Type||'';
            const rVal=rec.AliasTarget?'ALIAS  '+rec.AliasTarget.DNSName:
              (rec.ResourceRecords||[]).map(rr=>rr.Value).join(', ');
            const ttl=rec.TTL!=null?'  TTL:'+rec.TTL:'';
            shapes.push({
              id:'dnsrec_'+zi+'_'+ri,type:'rectangle',
              boundingBox:{x:zx+6,y:ly,w:colW-32,h:recRowH},
              text:'<p style="font-size:7pt;color:#334155;text-align:left;font-family:monospace">'+rName+' &nbsp; '+rType+' &nbsp; '+rVal+ttl+'</p>',
              style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
            });
            ly+=recRowH;
          });
        }
        curY+=zh+zoneGap;
      }else{
        // Collapsed: 2-column compact layout
        const col=zi%cols;
        const row=Math.floor(zi/cols);
        const zx=dnsX+20+col*colW;
        const zy=dnsY+48+row*62;
        shapes.push({
          id:'dns_'+zi,type:'rectangle',
          boundingBox:{x:zx,y:zy,w:colW-20,h:54},
          text:NOTEXT,
          style:{stroke:{color:isPub?'#10b981':'#0ea5e9',width:1.5},fill:{type:'color',color:isPub?'#F0FDF4':'#F0F9FF'}},
          customData:[
            {key:'Zone ID',value:zid},{key:'Name',value:z.Name},
            {key:'Type',value:isPub?'Public':'Private'},
            {key:'Records',value:String(z.ResourceRecordSetCount)},
            {key:'Associated VPCs',value:assocVpcs||'N/A'}
          ]
        });
        shapes.push({
          id:'dnslbl_'+zi+'a',type:'rectangle',
          boundingBox:{x:zx+6,y:zy+4,w:colW-32,h:22},
          text:'<p style="font-size:9pt;font-weight:bold;color:'+(isPub?'#10b981':'#0ea5e9')+';text-align:left">'+(isPub?'[Public]':'[Private]')+' '+z.Name+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        shapes.push({
          id:'dnslbl_'+zi+'b',type:'rectangle',
          boundingBox:{x:zx+6,y:zy+28,w:colW-32,h:20},
          text:'<p style="font-size:8pt;color:#64748B;text-align:left">'+z.ResourceRecordSetCount+' records | '+zid+(assocVpcs?' | VPCs: '+assocVpcs:'')+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
      }
    });
  }
  
  // S3 Buckets section
  if(s3bk&&s3bk.length>0){
    const s3Cols=3;
    const s3ColW=360;
    const s3W=s3Cols*s3ColW+60;
    const s3RowH=36;
    const s3Rows=Math.ceil(s3bk.length/s3Cols);
    const s3H=50+s3Rows*s3RowH+20;
    const dnsExists=zones&&zones.length>0;
    const _lucidDnsH=(function(){
      if(!dnsExists)return 0;
      const dExp=(_detailLevel>=1);const c=dExp?1:2;
      if(dExp){let th=0;(zones||[]).forEach(z=>{const ip=!z.Config?.PrivateZone;const av=(!ip&&z.VPCs)?z.VPCs.length:0;const zid=z.Id.replace('/hostedzone/','');const zR=recsByZoneLZ[zid]||[];let h=28;if(av)h+=16;if(zR.length>0)h+=18+zR.length*16;th+=Math.max(54,h+12)+8});return 60+th+20}
      return 60+Math.ceil((zones||[]).length/c)*62+20;
    })();
    const s3Y=dnsExists?(Math.max(HUB_Y+hubH,spokeY)+60+_lucidDnsH+40):(Math.max(HUB_Y+hubH,spokeY)+60);

    shapes.push({
      id:'s3_lz_section',type:'rectangle',
      boundingBox:{x:HUB_X,y:s3Y,w:s3W,h:s3H},
      text:NOTEXT,
      style:{stroke:{color:'#EA580C',width:2,style:'dashed'},fill:{type:'color',color:'#FFF7ED'}}
    });
    shapes.push({
      id:'s3_lz_title',type:'rectangle',
      boundingBox:{x:HUB_X+10,y:s3Y+8,w:s3W-20,h:30},
      text:'<p style="font-size:12pt;font-weight:bold;color:#EA580C;text-align:left">S3 Buckets ('+s3bk.length+')</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });
    
    s3bk.forEach((bk,bi)=>{
      const col=bi%s3Cols;
      const row=Math.floor(bi/s3Cols);
      const bx=HUB_X+20+col*s3ColW;
      const by=s3Y+48+row*s3RowH;
      
      shapes.push({
        id:'ls3_'+bi,type:'rectangle',
        boundingBox:{x:bx,y:by,w:s3ColW-20,h:28},
        text:NOTEXT,
        style:{stroke:{color:'#EA580C',width:1},fill:{type:'color',color:'#FFFFFF'}},
        customData:[
          {key:'Bucket Name',value:bk.Name},
          {key:'Created',value:(bk.CreationDate||'N/A').split('T')[0]}
        ]
      });
      shapes.push({
        id:'ls3lbl_'+bi,type:'rectangle',
        boundingBox:{x:bx+4,y:by+2,w:s3ColW-28,h:24},
        text:'<p style="font-size:8pt;color:#232F3E;text-align:left">'+bk.Name+'</p>',
        style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
      });
    });
  }

  // Compute page dimensions
  let pgW=EXT_X+extW+100;
  let pgH=Math.max(HUB_Y+hubH+200,spokeY+200);
  if(zones&&zones.length>0){
    const pgDnsH=(function(){
      const dExp=(_detailLevel>=1);const c=dExp?1:2;
      if(dExp){let th=0;zones.forEach(z=>{const ip=!z.Config?.PrivateZone;const av=(!ip&&z.VPCs)?z.VPCs.length:0;const zid=z.Id.replace('/hostedzone/','');const zR=recsByZoneLZ[zid]||[];let h=28;if(av)h+=16;if(zR.length>0)h+=18+zR.length*16;th+=Math.max(54,h+12)+8});return 60+th+20}
      return 60+Math.ceil(zones.length/c)*62+20;
    })();
    const dnsBottom=Math.max(HUB_Y+hubH,spokeY)+60+pgDnsH+40;
    pgH=Math.max(pgH,dnsBottom);
  }
  if(s3bk&&s3bk.length>0){
    const pgDnsH2=(function(){
      if(!(zones&&zones.length>0))return 0;
      const dExp=(_detailLevel>=1);const c=dExp?1:2;
      if(dExp){let th=0;zones.forEach(z=>{const ip=!z.Config?.PrivateZone;const av=(!ip&&z.VPCs)?z.VPCs.length:0;const zid=z.Id.replace('/hostedzone/','');const zR=recsByZoneLZ[zid]||[];let h=28;if(av)h+=16;if(zR.length>0)h+=18+zR.length*16;th+=Math.max(54,h+12)+8});return 60+th+20}
      return 60+Math.ceil(zones.length/c)*62+20;
    })();
    const dnsExists=zones&&zones.length>0;
    const s3Y=dnsExists?(Math.max(HUB_Y+hubH,spokeY)+60+pgDnsH2+40):(Math.max(HUB_Y+hubH,spokeY)+60);
    const s3Rows=Math.ceil(s3bk.length/3);
    const s3Bottom=s3Y+50+s3Rows*36+40;
    pgH=Math.max(pgH,s3Bottom);
  }
  
  // Build final export - format must match buildLucidExport
  const doc={version:1,pages:[{id:'page1',title:'AWS-Landing-Zone',shapes,lines}]};
  
  console.log('Landing Zone layout complete:', shapes.length, 'shapes,', lines.length, 'lines');
  return {doc,iconSet};
  }catch(e){
    console.error('Landing Zone layout error:', e);
    alert('Landing Zone layout error: '+e.message);
    return null;
  }
}

function buildLucidExport(){
  const vpcs=ext(safeParse(gv('in_vpcs')),['Vpcs']);
  const subnets=ext(safeParse(gv('in_subnets')),['Subnets']);
  const rts=ext(safeParse(gv('in_rts')),['RouteTables']);
  const sgs=ext(safeParse(gv('in_sgs')),['SecurityGroups']);
  const nacls=ext(safeParse(gv('in_nacls')),['NetworkAcls']);
  const igws=ext(safeParse(gv('in_igws')),['InternetGateways']);
  const nats=ext(safeParse(gv('in_nats')),['NatGateways']);
  const vpceList=ext(safeParse(gv('in_vpces')),['VpcEndpoints']);
  const peerings=ext(safeParse(gv('in_peer')),['VpcPeeringConnections']);
  const volumes=ext(safeParse(gv('in_vols')),['Volumes']);
  const snapshots=ext(safeParse(gv('in_snaps')),['Snapshots']);
  const s3raw=safeParse(gv('in_s3'));const s3bk=s3raw?ext(s3raw,['Buckets']):[];
  const zones=ext(safeParse(gv('in_r53')),['HostedZones']);
  const allRecordSets=ext(safeParse(gv('in_r53records')),['ResourceRecordSets']);
  const recsByZone={};
  allRecordSets.forEach(r=>{if(r.HostedZoneId)(recsByZone[r.HostedZoneId]=recsByZone[r.HostedZoneId]||[]).push(r)});
  let instances=[];
  const eRaw=safeParse(gv('in_ec2'));
  if(eRaw){
    const reservations=ext(eRaw,['Reservations']);
    if(reservations.length){reservations.forEach(r=>{if(r.Instances)instances=instances.concat(r.Instances);else if(r.InstanceId)instances.push(r)})}
    else{const flat=ext(eRaw,['Instances']);if(flat.length)instances=flat;else{const arr=Array.isArray(eRaw)?eRaw:[eRaw];arr.forEach(x=>{if(x.InstanceId)instances.push(x)})}}
  }
  const albs=ext(safeParse(gv('in_albs')),['LoadBalancers']);
  const tgs=ext(safeParse(gv('in_tgs')),['TargetGroups']);
  const enis=ext(safeParse(gv('in_enis')),['NetworkInterfaces']);
  const wafAcls=ext(safeParse(gv('in_waf')),['WebACLs']);
  const rdsInstances=ext(safeParse(gv('in_rds')),['DBInstances']);
  const ecsServices=ext(safeParse(gv('in_ecs')),['services']);
  const lambdaFns=(ext(safeParse(gv('in_lambda')),['Functions'])).filter(f=>f.VpcConfig&&f.VpcConfig.VpcId);
  const cfDistributions=ext(safeParse(gv('in_cf')),['DistributionList','Items']);
  if(!vpcs.length){alert('Render map first');return null}

  // Build lookups
  const subByVpc={};subnets.forEach(s=>(subByVpc[s.VpcId]=subByVpc[s.VpcId]||[]).push(s));
  const sgByVpc={};sgs.forEach(sg=>(sgByVpc[sg.VpcId]=sgByVpc[sg.VpcId]||[]).push(sg));
  const subNacl={};nacls.forEach(n=>(n.Associations||[]).forEach(a=>{if(a.SubnetId)subNacl[a.SubnetId]=n}));
  const exMainRT={};rts.forEach(rt=>{if((rt.Associations||[]).some(a=>a.Main))exMainRT[rt.VpcId]=rt});
  const subRT={};rts.forEach(rt=>(rt.Associations||[]).forEach(a=>{if(a.SubnetId)subRT[a.SubnetId]=rt}));
  subnets.forEach(s=>{if(!subRT[s.SubnetId]&&exMainRT[s.VpcId])subRT[s.SubnetId]=exMainRT[s.VpcId]});
  const instBySub={};instances.forEach(i=>{if(i.SubnetId)(instBySub[i.SubnetId]=instBySub[i.SubnetId]||[]).push(i)});
  const eniBySub={};enis.forEach(e=>{if(e.SubnetId)(eniBySub[e.SubnetId]=eniBySub[e.SubnetId]||[]).push(e)});
  const albBySub={};albs.forEach(lb=>{(lb.AvailabilityZones||[]).forEach(az=>{if(az.SubnetId)(albBySub[az.SubnetId]=albBySub[az.SubnetId]||[]).push(lb)})});
  const volByInst={};volumes.forEach(v=>{(v.Attachments||[]).forEach(a=>{if(a.InstanceId)(volByInst[a.InstanceId]=volByInst[a.InstanceId]||[]).push(v)})});
  const knownInstIds3=new Set(instances.map(i=>i.InstanceId));
  const instSubFromEni3={};enis.forEach(e=>{if(e.SubnetId&&e.Attachment&&e.Attachment.InstanceId)instSubFromEni3[e.Attachment.InstanceId]=e.SubnetId});
  const volBySub={};volumes.forEach(v=>{const att=(v.Attachments||[])[0];if(att&&att.InstanceId){if(knownInstIds3.has(att.InstanceId))return;const sid=instSubFromEni3[att.InstanceId];if(sid)(volBySub[sid]=volBySub[sid]||[]).push(v)}});
  const snapByVol={};snapshots.forEach(s=>{if(s.VolumeId)(snapByVol[s.VolumeId]=snapByVol[s.VolumeId]||[]).push(s)});
  const tgByAlb={};tgs.forEach(tg=>{(tg.LoadBalancerArns||[]).forEach(arn=>{(tgByAlb[arn]=tgByAlb[arn]||[]).push(tg)})});
  const wafByAlb={};wafAcls.forEach(acl=>{(acl.ResourceArns||[]).forEach(arn=>{(wafByAlb[arn]=wafByAlb[arn]||[]).push(acl)})});
  const rdsBySub={};rdsInstances.forEach(db=>{const sg=db.DBSubnetGroup;if(!sg)return;(sg.Subnets||[]).forEach(s=>{if(s.SubnetIdentifier)(rdsBySub[s.SubnetIdentifier]=rdsBySub[s.SubnetIdentifier]||[]).push(db)})});
  const ecsBySub={};ecsServices.forEach(svc=>{const nc=svc.networkConfiguration?.awsvpcConfiguration;if(!nc)return;(nc.subnets||[]).forEach(sid=>{(ecsBySub[sid]=ecsBySub[sid]||[]).push(svc)})});
  const lambdaBySub={};lambdaFns.forEach(fn=>{(fn.VpcConfig?.SubnetIds||[]).forEach(sid=>{(lambdaBySub[sid]=lambdaBySub[sid]||[]).push(fn)})});
  const cfByAlb={};cfDistributions.forEach(cf=>{(cf.Origins?.Items||[]).forEach(o=>{const dn=o.DomainName||'';albs.forEach(lb=>{if(lb.DNSName&&dn.includes(lb.DNSName))(cfByAlb[lb.LoadBalancerArn]=cfByAlb[lb.LoadBalancerArn]||[]).push(cf)})})});
  const pubSubs=new Set();
  rts.forEach(rt=>{
    const hasIgw=(rt.Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
    (rt.Associations||[]).forEach(a=>{if(a.SubnetId&&hasIgw)pubSubs.add(a.SubnetId)});
  });
  subnets.forEach(s=>{if(!pubSubs.has(s.SubnetId)&&exMainRT[s.VpcId]){
    const hasIgw=(exMainRT[s.VpcId].Routes||[]).some(r=>r.GatewayId&&r.GatewayId.startsWith('igw-'));
    if(hasIgw)pubSubs.add(s.SubnetId);
  }});

  function tw(str,pt){return(str||'').length*pt*0.62+20}

  const shapes=[],lines=[],iconSet=new Set();
  const shapeIds={};
  let lid=0;
  const IC=36;
  const VP=50;
  const VH=80;
  const SG=32;
  const SP=24;
  const EC2W=260,EC2H=34,EC2G=16;

  // Official AWS Architecture Group Icon colors
  const COL={
    vpcFill:'#FFFFFF',vpcStroke:'#8C4FFF',vpcFont:'#8C4FFF',
    pubFill:'#FFFFFF',pubStroke:'#7AA116',pubFont:'#7AA116',
    prvFill:'#FFFFFF',prvStroke:'#147EBA',prvFont:'#147EBA',
    ec2Fill:'#FFFFFF',ec2Stroke:'#ED7100',ec2Font:'#232F3E',
    igw:'#8C4FFF',nat:'#8C4FFF',tgw:'#8C4FFF',vgw:'#8C4FFF',
    vpce:'#8C4FFF',pcx:'#8C4FFF',inet:'#232F3E',
    albFill:'#FFFFFF',albStroke:'#8C4FFF',albFont:'#232F3E'
  };
  const gwFills={IGW:'#F5F0FF',NAT:'#F5F0FF',TGW:'#F5F0FF',VGW:'#F5F0FF',PCX:'#F5F0FF',VPCE:'#F5F0FF'};


  // icons as rectangles with image fill
  function addIcon(type,x,y){
    iconSet.add(type);
    shapes.push({
      id:'icon_'+(lid++),type:'rectangle',
      boundingBox:{x,y,w:IC,h:IC},
      text:'<p style="font-size:1pt;color:transparent">&nbsp;</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'image',ref:(ICON_MAP[type]||type.toLowerCase())+'.png'}}
    });
  }

  // collect gateways before VPC loop
  const gwSet2L=new Map();
  rts.forEach(rt=>{(rt.Routes||[]).forEach(r=>{
    if(r.GatewayId&&r.GatewayId!=='local')gwSet2L.set(r.GatewayId,{type:clsGw(r.GatewayId),id:r.GatewayId,vpcId:rt.VpcId});
    if(r.NatGatewayId)gwSet2L.set(r.NatGatewayId,{type:'NAT',id:r.NatGatewayId,vpcId:rt.VpcId});
    if(r.TransitGatewayId)gwSet2L.set(r.TransitGatewayId,{type:'TGW',id:r.TransitGatewayId,vpcId:'shared'});
    if(r.VpcPeeringConnectionId)gwSet2L.set(r.VpcPeeringConnectionId,{type:'PCX',id:r.VpcPeeringConnectionId,vpcId:'shared'});
  })});
  igws.forEach(g=>{if(!gwSet2L.has(g.InternetGatewayId)){const v=(g.Attachments||[])[0];gwSet2L.set(g.InternetGatewayId,{type:'IGW',id:g.InternetGatewayId,vpcId:v?v.VpcId:'unk'})}});
  nats.forEach(g=>{if(!gwSet2L.has(g.NatGatewayId))gwSet2L.set(g.NatGatewayId,{type:'NAT',id:g.NatGatewayId,vpcId:g.VpcId||'unk'})});

  // group by VPC vs shared
  const gwByVpc={};const sharedGws=[];
  gwSet2L.forEach((gw,gwId)=>{
    if(gw.type==='VPCE')return;
    if(gw.vpcId==='shared'){sharedGws.push({...gw,gwMapId:gwId});return}
    if(!gwByVpc[gw.vpcId])gwByVpc[gw.vpcId]=[];
    gwByVpc[gw.vpcId].push({...gw,gwMapId:gwId});
  });
  const vpceByVpc={};
  gwSet2L.forEach(gw=>{if(gw.type==='VPCE')(vpceByVpc[gw.vpcId]=vpceByVpc[gw.vpcId]||[]).push(gw)});
  vpceList.forEach(v=>{if(!vpceByVpc[v.VpcId])vpceByVpc[v.VpcId]=[{type:'VPCE',id:v.VpcEndpointId,vpcId:v.VpcId}]});

  const gwColors2={IGW:COL.igw,NAT:COL.nat,TGW:COL.tgw,VGW:COL.vgw,PCX:COL.pcx,VPCE:COL.vpce};
  const GW_W=350,GW_H=52,GW_GAP=10;

  const activeVpcs=vpcs.filter(v=>(subByVpc[v.VpcId]||[]).length>0);

  // Get layout mode from selector
  const layoutMode=document.getElementById('layoutMode')?.value||'grid';
  const userHubName=(document.getElementById('hubVpcName')?.value||'').toLowerCase().trim();
  console.log('buildLucidExport: layoutMode=', layoutMode, 'userHubName=', userHubName);

  // Landing Zone layout mode
  if(layoutMode==='landingzone'){
    console.log('Using Landing Zone layout mode, calling buildLandingZoneLayout...');
    const result=buildLandingZoneLayout({
      vpcs:activeVpcs,subByVpc,sgByVpc,pubSubs,rts,instances,albs,enis,nacls:subNacl,
      subRT,igws,nats,vpceList,peerings,sharedGws,gwByVpc,vpceByVpc,gwSet2L,
      gn,sid,tw,userHubName,COL,gwColors2,gwFills,ICON_MAP,volumes,zones,
      s3bk,snapshots,snapByVol,tgByAlb,tgs,wafAcls,wafByAlb,
      instBySub,albBySub,eniBySub,volByInst,volBySub,rdsBySub,ecsBySub,lambdaBySub,cfByAlb,recsByZone
    });
    console.log('buildLandingZoneLayout returned:', result?'success':'null');
    return result;
  }

  // transparent text to suppress Lucid "Text" placeholder
  const NOTEXT='<p style="font-size:1pt;color:transparent">&nbsp;</p>';

  // gateway badge sizing (wider and taller to fit text)
  const GW_BADGE_W=350,GW_BADGE_H=56,GW_BADGE_GAP=12;
  const GW_BADGES_PER_ROW=2;

  // PASS 1: compute VPC column sizes
  const vpcInfos=[];
  activeVpcs.forEach(vpc=>{
    const ss=subByVpc[vpc.VpcId]||[];
    const vpcName=gn(vpc,vpc.VpcId);
    const vpcLabel=vpcName+' ('+vpc.CidrBlock+')';
    let maxSubW=580;
    ss.forEach(s=>{
      const sName=gn(s,s.SubnetId);
      const isPub=pubSubs.has(s.SubnetId);
      const tag=isPub?'PUBLIC':'PRIVATE';
      const az=s.AvailabilityZone||'';
      const subLabel=sName+' ['+tag+'] '+s.CidrBlock+' '+az;
      const needed=tw(subLabel,10)+IC+24;
      if(needed>maxSubW)maxSubW=needed;
      const insts=instances.filter(i=>i.SubnetId===s.SubnetId);
      const albsInSub=albs.filter(lb=>(lb.AvailabilityZones||[]).some(az2=>az2.SubnetId===s.SubnetId));
      const uaEnis=(eniBySub[s.SubnetId]||[]).filter(e=>!insts.some(i=>enis.some(en=>en.Attachment&&en.Attachment.InstanceId===i.InstanceId&&en.NetworkInterfaceId===e.NetworkInterfaceId)));
      const resCount=insts.length+albsInSub.length+(rdsBySub[s.SubnetId]||[]).length+(ecsBySub[s.SubnetId]||[]).length+(lambdaBySub[s.SubnetId]||[]).length+uaEnis.length;
      const cols=Math.max(1,Math.floor((maxSubW-SP*2)/(EC2W+EC2G)));
      const neededForInst=resCount>0?cols*(EC2W+EC2G)+SP*2:0;
      if(neededForInst>maxSubW)maxSubW=neededForInst;
    });
    maxSubW=Math.min(900,Math.max(520,maxSubW));

    const myGws=gwByVpc[vpc.VpcId]||[];
    const myVpce=vpceByVpc[vpc.VpcId]||[];
    const allGwItems=[...myGws];
    if(myVpce.length>0)allGwItems.push({type:'VPCE',id:'vpce_bundle',isVpce:true,count:myVpce.length});

    // Use fixed badge width
    const maxBadgeW=GW_BADGE_W;
    
    // ensure VPC wide enough for gateway badges
    const gwRowW=Math.min(allGwItems.length,GW_BADGES_PER_ROW)*(maxBadgeW+GW_BADGE_GAP)+VP*2;
    if(gwRowW>maxSubW)maxSubW=Math.max(maxSubW,gwRowW);

    const vpcW=maxSubW+VP*2;
    const vpcLabelW=tw(vpcLabel,14)+IC+24;
    const finalVpcW=Math.max(vpcW,vpcLabelW+VP*2);

    // gateway badge section height
    const gwRows=Math.ceil(allGwItems.length/GW_BADGES_PER_ROW);
    const gwSectionH=gwRows>0?(gwRows*(GW_BADGE_H+GW_BADGE_GAP)+GW_BADGE_GAP+10):0;

    const P1_NAME_H=36,P1_DETAIL_H=28,P1_CHILD_LINE_H=22,P1_CHILD_GAP=8,P1_RES_PAD=10;
    const P1_CHILD_INNER_W=EC2W-24;
    function p1ChildH(label){return Math.max(1,Math.ceil(tw(label,8)/P1_CHILD_INNER_W))*P1_CHILD_LINE_H+8;}
    function p1ResH(r){
      const chs=r.children||[];
      let h=P1_RES_PAD+P1_NAME_H;
      if(r.detail)h+=P1_DETAIL_H;
      if(chs.length>0){
        h+=P1_CHILD_GAP;
        chs.forEach(ch=>{h+=p1ChildH(ch.label||'')+P1_CHILD_GAP;});
      }
      h+=P1_RES_PAD;
      return Math.max(EC2H,h);
    }
    let subStackH=0;
    const subHeights={};
    ss.forEach(s=>{
      const sInsts=instances.filter(i=>i.SubnetId===s.SubnetId);
      const sAlbs=albs.filter(lb=>(lb.AvailabilityZones||[]).some(az=>az.SubnetId===s.SubnetId));
      const sRds=(rdsBySub[s.SubnetId]||[]);
      const sEcs=(ecsBySub[s.SubnetId]||[]);
      const sLam=(lambdaBySub[s.SubnetId]||[]);
      const sEni=(eniBySub[s.SubnetId]||[]);
      const p1Attached=new Set();
      // Build resources with children for height calc
      const p1Res=[];
      sInsts.forEach(i=>{
        const ie=enis.filter(e=>e.Attachment&&e.Attachment.InstanceId===i.InstanceId);
        ie.forEach(e=>p1Attached.add(e.NetworkInterfaceId));
        const ch=[];
        if(_showNested){
          ie.forEach(e=>ch.push({label:'ENI: '+e.NetworkInterfaceId.slice(-8)+(e.PrivateIpAddress?' \u00b7 '+e.PrivateIpAddress:'')}));
          (volByInst[i.InstanceId]||[]).forEach(v=>{const sc=(snapByVol[v.VolumeId]||[]).length;ch.push({label:'VOL: '+v.Size+'GB '+(v.VolumeType||'')+(sc?' \u00b7 '+sc+' snap':'')})});
        }
        p1Res.push({detail:i.InstanceType,children:ch});
      });
      sAlbs.forEach(lb=>{
        const ch=[];
        if(_showNested){
          (tgByAlb[lb.LoadBalancerArn]||[]).forEach(t=>ch.push({label:'TG: '+(t.TargetGroupName||'TG')+' \u00b7 '+((t.Targets||[]).length)+' tgt'}));
          (wafByAlb[lb.LoadBalancerArn]||[]).forEach(w=>ch.push({label:'WAF: '+(w.Name||'WAF')+' \u00b7 '+((w.Rules||[]).length)+' rules'}));
          (cfByAlb[lb.LoadBalancerArn]||[]).forEach(cf=>ch.push({label:'CF: '+(cf.DomainName||'CF')}));
        }
        p1Res.push({detail:lb.Scheme||'',children:ch});
      });
      sRds.forEach(db=>p1Res.push({detail:db.Engine||'',children:[]}));
      sEcs.forEach(svc=>p1Res.push({detail:svc.launchType||'',children:[]}));
      sLam.forEach(fn=>p1Res.push({detail:fn.Runtime||'',children:[]}));
      sEni.forEach(e=>{if(!p1Attached.has(e.NetworkInterfaceId))p1Res.push({detail:e.PrivateIpAddress||'',children:[]})});
      // Standalone EBS volumes
      ((volBySub||{})[s.SubnetId]||[]).forEach(v=>p1Res.push({detail:v.Size+'GB '+(v.VolumeType||''),children:[]}));
      const cols=Math.max(1,Math.floor((maxSubW-SP*2)/(EC2W+EC2G)));
      const rowCount=Math.ceil(p1Res.length/cols);
      let totalResH=0;
      for(let row=0;row<rowCount;row++){
        let maxH=EC2H;
        for(let c=0;c<cols;c++){const ri=row*cols+c;if(ri<p1Res.length){const h=p1ResH(p1Res[ri]);if(h>maxH)maxH=h;}}
        totalResH+=maxH+EC2G;
      }
      const subH=VH+totalResH+SP*2;
      const finalSubH=Math.max(60,subH);
      subHeights[s.SubnetId]=finalSubH;
      subStackH+=finalSubH+SG;
    });
    const vpcH=VH+gwSectionH+subStackH+VP;
    vpcInfos.push({vpc,ss,vpcLabel,maxSubW,finalVpcW,vpcH,allGwItems,gwSectionH,subHeights,maxBadgeW});
  });

  const VPC_TOP=80;
  const COL_SPACE=500; // extra space for per-VPC gateways on the right

  // track VPC positions for line routing
  const vpcPositions={};

  // PASS 2: place shapes
  let vpcX=120;

  vpcInfos.forEach(info=>{
    const {vpc,ss,vpcLabel,maxSubW,finalVpcW,vpcH,allGwItems,gwSectionH,subHeights,maxBadgeW}=info;
    info.vpcX=vpcX; // store for later use in line drawing
    const vpcId='vpc_'+(lid++);
    shapeIds[vpc.VpcId]=vpcId;
    
    // Get VPC stats
    const vpcSgs=sgByVpc[vpc.VpcId]||[];
    const vpcRts=rts.filter(rt=>rt.VpcId===vpc.VpcId);
    const vpcVpces=vpceList.filter(v=>v.VpcId===vpc.VpcId);
    const vpcInsts=instances.filter(i=>ss.some(s=>s.SubnetId===i.SubnetId));
    const vpcEnis=enis.filter(e=>e.VpcId===vpc.VpcId);
    const region=ss[0]?.AvailabilityZone?.replace(/-[a-z]$/,'')||'';

    // VPC container
    shapes.push({
      id:vpcId,type:'roundedRectangleContainer',
      boundingBox:{x:vpcX,y:VPC_TOP,w:finalVpcW,h:vpcH},
      text:NOTEXT,
      style:{stroke:{color:COL.vpcStroke,width:3,style:'dashed'},fill:{type:'color',color:COL.vpcFill}},
      magnetize:true,
      customData:[
        {key:'VPC ID',value:vpc.VpcId},
        {key:'Name',value:gn(vpc,vpc.VpcId)},
        {key:'CIDR',value:vpc.CidrBlock||''},
        {key:'Region',value:region},
        {key:'Subnets',value:String(ss.length)},
        {key:'Security Groups',value:String(vpcSgs.length)},
        {key:'Route Tables',value:String(vpcRts.length)},
        {key:'EC2 Instances',value:String(vpcInsts.length)},
        {key:'ENIs',value:String(vpcEnis.length)},
        {key:'VPC Endpoints',value:String(vpcVpces.length)}
      ]
    });
    // store VPC position for line routing
    vpcPositions[vpc.VpcId]={x:vpcX,w:finalVpcW,h:vpcH,bottomY:VPC_TOP+vpcH};
    addIcon('VPC',vpcX+6,VPC_TOP+4);
    // Truncate VPC label to fit - conservative estimate
    const maxVpcChars=Math.floor((finalVpcW-IC-50)/11);
    const dispVpcLabel=vpcLabel.length>maxVpcChars?vpcLabel.substring(0,maxVpcChars-2)+'..':vpcLabel;
    shapes.push({
      id:'vpclbl_'+(lid++),type:'rectangle',
      boundingBox:{x:vpcX+IC+12,y:VPC_TOP+4,w:finalVpcW-IC-24,h:VH-10},
      text:'<p style="font-size:14pt;font-weight:bold;color:'+COL.vpcFont+';text-align:left;padding:4px 8px">'+dispVpcLabel+'</p>',
      style:{stroke:{color:COL.vpcFill,width:0},fill:{type:'color',color:COL.vpcFill}}
    });

    // gateway badges inside VPC, below header
    const thisBadgeW=maxBadgeW||GW_BADGE_W;
    let gwBadgeY=VPC_TOP+VH+6;
    for(let row=0;row<Math.ceil(allGwItems.length/GW_BADGES_PER_ROW);row++){
      const rowItems=allGwItems.slice(row*GW_BADGES_PER_ROW,(row+1)*GW_BADGES_PER_ROW);
      let gwBX=vpcX+VP;
      rowItems.forEach(gw=>{
        const gc=gwColors2[gw.type]||'#546E7A';
        const gf=gwFills[gw.type]||'#F5F0FF';
        if(gw.isVpce){
          // Truncate VPCE text
          const vpceText='VPCE ('+gw.count+')';
          // VPCE badge with text
          shapes.push({
            id:'vpce_'+(lid++),type:'rectangle',
            boundingBox:{x:gwBX,y:gwBadgeY,w:thisBadgeW,h:GW_BADGE_H},
            text:NOTEXT,
            style:{stroke:{color:COL.vpce,width:2,style:'dashed'},fill:{type:'color',color:'#F5F0FF'}}
          });
          addIcon('VPCE',gwBX+10,gwBadgeY+10);
          shapes.push({
            id:'vpce_lbl_'+(lid++),type:'rectangle',
            boundingBox:{x:gwBX+52,y:gwBadgeY+10,w:thisBadgeW-62,h:36},
            text:'<p style="font-size:10pt;color:#232F3E;font-weight:bold;text-align:left">'+vpceText+'</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
        } else {
          const nm=gwNames[gw.id]||sid(gw.id);
          
          // Build gateway-specific customData
          let gwCustomData=[
            {key:'Gateway ID',value:gw.id},
            {key:'Type',value:gw.type==='IGW'?'Internet Gateway':gw.type==='NAT'?'NAT Gateway':gw.type==='VGW'?'Virtual Private Gateway':gw.type},
            {key:'Name',value:nm}
          ];
          
          // Add NAT-specific info
          if(gw.type==='NAT'){
            const natGw=nats.find(n=>n.NatGatewayId===gw.id);
            if(natGw){
              gwCustomData.push({key:'State',value:natGw.State||''});
              gwCustomData.push({key:'Connectivity',value:natGw.ConnectivityType||'public'});
              const pubIp=(natGw.NatGatewayAddresses||[])[0]?.PublicIp;
              const privIp=(natGw.NatGatewayAddresses||[])[0]?.PrivateIp;
              if(pubIp)gwCustomData.push({key:'Public IP',value:pubIp});
              if(privIp)gwCustomData.push({key:'Private IP',value:privIp});
            }
          }
          
          // Add IGW-specific info
          if(gw.type==='IGW'){
            const igw=igws.find(g=>g.InternetGatewayId===gw.id);
            if(igw){
              const attachedVpcs=(igw.Attachments||[]).map(a=>a.VpcId).join(', ');
              gwCustomData.push({key:'Attached VPCs',value:attachedVpcs||'None'});
              gwCustomData.push({key:'State',value:(igw.Attachments||[])[0]?.State||''});
            }
          }
          
          // Truncate text to fit
          const maxBChars=Math.floor((thisBadgeW-60)/7);
          const fullBText=gw.type+': '+nm;
          const dispBText=fullBText.length>maxBChars?fullBText.substring(0,maxBChars-2)+'..':fullBText;
          
          // Gateway badge with text
          shapes.push({
            id:'gwb_'+(lid++),type:'rectangle',
            boundingBox:{x:gwBX,y:gwBadgeY,w:thisBadgeW,h:GW_BADGE_H},
            text:NOTEXT,
            style:{stroke:{color:gc,width:2},fill:{type:'color',color:gf}},
            customData:gwCustomData
          });
          addIcon(gw.type,gwBX+10,gwBadgeY+10);
          shapes.push({
            id:'gwb_lbl_'+(lid++),type:'rectangle',
            boundingBox:{x:gwBX+52,y:gwBadgeY+10,w:thisBadgeW-62,h:36},
            text:'<p style="font-size:10pt;font-weight:bold;color:#232F3E;text-align:left">'+dispBText+'</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
        }
        gwBX+=thisBadgeW+GW_BADGE_GAP;
      });
      gwBadgeY+=GW_BADGE_H+GW_BADGE_GAP;
    }

    // subnets below gateway badges
    let subY=VPC_TOP+VH+gwSectionH;
    ss.forEach(s=>{
      const sName=gn(s,s.SubnetId);
      const isPub=pubSubs.has(s.SubnetId);
      const tag=isPub?'PUBLIC':'PRIVATE';
      const az=s.AvailabilityZone||'';
      const subLabel=sName+' ['+tag+'] '+s.CidrBlock+' '+az;
      const subId='sub_'+(lid++);
      shapeIds[s.SubnetId]=subId;
      const insts=instBySub[s.SubnetId]||[];
      const subEnis=eniBySub[s.SubnetId]||[];
      const subAlbs=albBySub[s.SubnetId]||[];
      const subRds=rdsBySub[s.SubnetId]||[];
      const subEcs=ecsBySub[s.SubnetId]||[];
      const subLambda=lambdaBySub[s.SubnetId]||[];
      const NAME_H=36,DETAIL_H=28,CHILD_LINE_H=22,CHILD_GAP=8,RES_PAD=10;
      const CHILD_INNER_W=EC2W-24;
      function childLines(label){return Math.max(1,Math.ceil(tw(label,8)/CHILD_INNER_W));}
      function childH(label){return childLines(label)*CHILD_LINE_H+8;}
      const attachedEnis=new Set();
      const resources=[];
      // EC2 with ENI + VOL children
      insts.forEach(i=>{
        const ch=[];
        const ie=enis.filter(e=>e.Attachment&&e.Attachment.InstanceId===i.InstanceId);
        ie.forEach(e=>attachedEnis.add(e.NetworkInterfaceId));
        if(_showNested){
          ie.forEach(e=>ch.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),detail:e.PrivateIpAddress||'',col:'#3b82f6'}));
          (volByInst[i.InstanceId]||[]).forEach(v=>{
            const sc=(snapByVol[v.VolumeId]||[]).length;
            ch.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),detail:sc?sc+' snap':'',col:'#f59e0b'});
          });
        }
        resources.push({type:'EC2',name:gn(i,i.InstanceId),id:i.InstanceId,detail:i.InstanceType,children:ch,resCol:'#10b981'});
      });
      // ALB with TG + WAF + CF children
      subAlbs.forEach(lb=>{
        const ch=[];
        if(_showNested){
          (tgByAlb[lb.LoadBalancerArn]||[]).forEach(tg=>ch.push({type:'TG',name:tg.TargetGroupName||'TG',detail:(tg.Targets||[]).length+' tgt',col:'#06b6d4'}));
          (wafByAlb[lb.LoadBalancerArn]||[]).forEach(w=>ch.push({type:'WAF',name:w.Name||'WAF',detail:(w.Rules||[]).length+' rules',col:'#eab308'}));
          (cfByAlb[lb.LoadBalancerArn]||[]).forEach(cf=>ch.push({type:'CF',name:cf.DomainName||'CF',detail:'',col:'#8b5cf6'}));
        }
        resources.push({type:'ALB',name:lb.LoadBalancerName||'ALB',id:lb.LoadBalancerArn,detail:lb.Scheme||'',children:ch,resCol:'#38bdf8'});
      });
      // RDS
      subRds.forEach(db=>resources.push({type:'RDS',name:db.DBInstanceIdentifier||'RDS',id:db.DBInstanceIdentifier,detail:db.Engine||'',children:[],resCol:'#3b82f6'}));
      // ECS
      subEcs.forEach(svc=>resources.push({type:'ECS',name:svc.serviceName||'ECS',id:svc.serviceName,detail:svc.launchType||'',children:[],resCol:'#f97316'}));
      // Lambda
      subLambda.forEach(fn=>resources.push({type:'FN',name:fn.FunctionName||'Lambda',id:fn.FunctionName,detail:fn.Runtime||'',children:[],resCol:'#a855f7'}));
      // Unattached ENIs
      subEnis.forEach(e=>{
        if(attachedEnis.has(e.NetworkInterfaceId))return;
        resources.push({type:'ENI',name:e.NetworkInterfaceId.slice(-8),id:e.NetworkInterfaceId,detail:e.PrivateIpAddress||'',children:[],resCol:'#3b82f6'});
      });
      // Standalone EBS volumes
      ((volBySub||{})[s.SubnetId]||[]).forEach(v=>{const att=(v.Attachments||[])[0];
        resources.push({type:'VOL',name:v.Size+'GB '+(v.VolumeType||''),id:v.VolumeId,detail:att?att.InstanceId?.slice(-8)||'':'detached',children:[],resCol:'#f59e0b'});
      });
      // Calculate per-resource height (name + detail + children + padding)
      function resHeight(r){
        const chs=r.children||[];
        let h=RES_PAD+NAME_H;
        if(r.detail)h+=DETAIL_H;
        if(chs.length>0){
          h+=CHILD_GAP;
          chs.forEach(ch=>{
            const lbl=ch.type+': '+ch.name+(ch.detail?' \u00b7 '+ch.detail:'');
            h+=childH(lbl)+CHILD_GAP;
          });
        }
        h+=RES_PAD;
        return Math.max(EC2H,h);
      }
      const cols=Math.max(1,Math.floor((maxSubW-SP*2)/(EC2W+EC2G)));
      // For row height, use max height of resources in that row
      const rowCount=Math.ceil(resources.length/cols);
      let totalResH=0;
      for(let row=0;row<rowCount;row++){
        let maxH=EC2H;
        for(let c=0;c<cols;c++){const ri=row*cols+c;if(ri<resources.length){const h=resHeight(resources[ri]);if(h>maxH)maxH=h;}}
        totalResH+=maxH+EC2G;
      }
      const subH=VH+totalResH+SP*2;
      const finalSubH=Math.max(60,subH);
      const sx=vpcX+VP,sy=subY;
      const fc=isPub?COL.pubFont:COL.prvFont;
      const fill=isPub?COL.pubFill:COL.prvFill;
      const stroke=isPub?COL.pubStroke:COL.prvStroke;
      
      // Get NACL and route table info
      const nacl=subNacl[s.SubnetId];
      const rt=subRT[s.SubnetId];
      const naclName=nacl?gn(nacl,nacl.NetworkAclId):'Default';
      const rtName=rt?gn(rt,rt.RouteTableId):'Main';
      const routes=(rt?.Routes||[]).filter(r=>r.GatewayId!=='local').map(r=>(r.DestinationCidrBlock||r.DestinationPrefixListId||'?')+' > '+(r.GatewayId||r.NatGatewayId||r.TransitGatewayId||'?')).join('; ');
      
      shapes.push({
        id:subId,type:'rectangle',
        boundingBox:{x:sx,y:sy,w:maxSubW,h:finalSubH},
        text:NOTEXT,
        style:{stroke:{color:stroke,width:2},fill:{type:'color',color:fill}},
        customData:[
          {key:'Subnet ID',value:s.SubnetId},
          {key:'Name',value:gn(s,s.SubnetId)},
          {key:'CIDR',value:s.CidrBlock||''},
          {key:'AZ',value:s.AvailabilityZone||''},
          {key:'Type',value:isPub?'Public':'Private'},
          {key:'NACL',value:naclName+(nacl?' ('+nacl.NetworkAclId+')':'')},
          {key:'Route Table',value:rtName+(rt?' ('+rt.RouteTableId+')':'')},
          {key:'Routes',value:routes||'local only'},
          {key:'EC2 Instances',value:String(insts.length)},
          {key:'ENIs',value:String(subEnis.length)},
          {key:'Load Balancers',value:String(subAlbs.length)}
        ]
      });
      addIcon(isPub?'SUB_PUB':'SUB_PRV',sx+6,sy+6);
      // Truncate subnet label to fit - conservative estimate
      const maxSubChars=Math.floor((maxSubW-IC-40)/9);
      const dispSubLabel=subLabel.length>maxSubChars?subLabel.substring(0,maxSubChars-2)+'..':subLabel;
      shapes.push({
        id:'sublbl_'+(lid++),type:'rectangle',
        boundingBox:{x:sx+IC+12,y:sy+6,w:maxSubW-IC-24,h:32},
        text:'<p style="font-size:10pt;font-weight:bold;color:'+fc+';text-align:left;padding:4px 6px">'+dispSubLabel+'</p>',
        style:{stroke:{color:fill,width:0},fill:{type:'color',color:fill}}
      });
      // Compute row Y offsets using variable row heights
      const rowHeights=[];
      for(let row=0;row<rowCount;row++){
        let maxH=EC2H;
        for(let c=0;c<cols;c++){const ri=row*cols+c;if(ri<resources.length){const h=resHeight(resources[ri]);if(h>maxH)maxH=h;}}
        rowHeights.push(maxH);
      }
      const rowYOff=[0];
      for(let i=0;i<rowHeights.length;i++)rowYOff.push(rowYOff[i]+rowHeights[i]+EC2G);

      resources.forEach((r,ri)=>{
        const col=ri%cols,row=Math.floor(ri/cols);
        const rx=sx+SP+col*(EC2W+EC2G);
        const ry=sy+VH+rowYOff[row];
        const isAlb=r.type==='ALB';
        const rH=resHeight(r);

        // Build customData based on resource type
        const resCustomData=[{key:'Type',value:r.type},{key:'Name',value:r.name||''},{key:'ID',value:r.id||''}];
        if(r.detail)resCustomData.push({key:'Detail',value:r.detail});

        // Truncate name to fit box
        const maxResChars=Math.floor((EC2W-20)/8);
        const dispResName=r.name.length>maxResChars?r.name.substring(0,maxResChars-2)+'..':r.name;

        // Build rich text: type badge + name + detail + children
        const rc=r.resCol||COL.ec2Font;
        let resHtml='<p style="font-size:9pt;color:'+rc+';font-weight:bold;text-align:left;padding:4px 6px">'+r.type+': '+dispResName+'</p>';
        if(r.detail){
          resHtml+='<p style="font-size:7pt;color:#6B7280;text-align:left;padding:0 6px">'+r.detail+'</p>';
        }
        (r.children||[]).forEach(ch=>{
          const chLabel=ch.type+': '+ch.name+(ch.detail?' \u00b7 '+ch.detail:'');
          resHtml+='<p style="font-size:8pt;color:'+ch.col+';font-weight:bold;text-align:left;padding:2px 6px;margin:4px 0">\u00a0\u00a0'+chLabel+'</p>';
        });

        // Resource container box
        shapes.push({
          id:'res_'+(lid++),type:'rectangle',
          boundingBox:{x:rx,y:ry,w:EC2W,h:rH},
          text:resHtml,
          style:{
            stroke:{color:rc,width:1},
            fill:{type:'color',color:'#FFFFFF'}
          },
          customData:resCustomData
        });
      });
      subY+=finalSubH+SG;
    });

    vpcX+=finalVpcW+COL_SPACE;
  });

  // Build subnet positions lookup (needed for gateway line routing)
  const subnetPositions={};
  vpcInfos.forEach(vi=>{
    const vpcX=vi.vpcX;
    let sy=VPC_TOP+VH+vi.gwSectionH;
    vi.ss.forEach((s,si)=>{
      const finalSubH=vi.subHeights[s.SubnetId]||60;
      subnetPositions[s.SubnetId]={
        x:vpcX+VP,
        y:sy,
        w:vi.maxSubW,
        h:finalSubH,
        vpcId:vi.vpc.VpcId,
        vpcX:vpcX,
        vpcW:vi.finalVpcW,
        vpcH:vi.vpcH,
        subIndex:si,
        centerX:vpcX+VP+vi.maxSubW/2,
        centerY:sy+finalSubH/2
      };
      sy+=finalSubH+SG;
    });
  });

  // --- Per-VPC Gateways (IGW, NAT, VGW) to the RIGHT of each VPC ---
  const PER_VPC_GW_X_OFFSET=60; // distance from VPC right edge
  const PER_VPC_GW_MAX_W=COL_SPACE-PER_VPC_GW_X_OFFSET-40; // max width to fit in column gap
  const PER_VPC_GW_H=56;
  const PER_VPC_GW_GAP=50;
  const perVpcGwPos={}; // gwId -> {x,y,centerX,centerY}
  
  vpcInfos.forEach(vi=>{
    const vpcRightX=vi.vpcX+vi.finalVpcW;
    const gwX=vpcRightX+PER_VPC_GW_X_OFFSET;
    
    // Get per-VPC gateways (IGW, NAT, VGW) for this VPC
    const vpcGws=vi.allGwItems.filter(g=>!g.isVpce && (g.type==='IGW'||g.type==='NAT'||g.type==='VGW'));
    
    // Use fixed width that fits within column space
    const maxGwW=PER_VPC_GW_MAX_W;
    
    let gwY=VPC_TOP+50;
    vpcGws.forEach((gw,gi)=>{
      const nm=gwNames[gw.id]||sid(gw.id);
      const gc=gwColors2[gw.type]||'#546E7A';
      const gf=gwFills[gw.type]||'#F5F0FF';
      const gwShapeId='pvgw_'+(lid++);
      shapeIds[gw.id]=gwShapeId;
      
      // Truncate text aggressively to fit within box (accounting for icon)
      const maxChars=Math.floor((maxGwW-70)/9);
      const fullText=gw.type+': '+nm;
      const dispText=fullText.length>maxChars?fullText.substring(0,maxChars-2)+'..':fullText;
      
      // Rectangle with text - icon overlaps but text stays in bounds
      shapes.push({
        id:gwShapeId,type:'rectangle',
        boundingBox:{x:gwX,y:gwY,w:maxGwW,h:PER_VPC_GW_H},
        text:'<p style="font-size:9pt;font-weight:bold;color:'+gc+';text-align:center">'+dispText+'</p>',
        style:{stroke:{color:gc,width:2},fill:{type:'color',color:gf}},
        customData:[
          {key:'Gateway ID',value:gw.id},
          {key:'Type',value:gw.type==='IGW'?'Internet Gateway':gw.type==='NAT'?'NAT Gateway':'Virtual Private Gateway'},
          {key:'Name',value:nm},
          {key:'VPC',value:vi.vpc.VpcId}
        ]
      });
      // Icon
      addIcon(gw.type,gwX+10,gwY+10);
      
      perVpcGwPos[gw.id]={
        x:gwX,
        y:gwY,
        centerX:gwX+maxGwW/2,
        centerY:gwY+PER_VPC_GW_H/2,
        leftEdge:gwX,
        vpcId:vi.vpc.VpcId
      };
      
      gwY+=PER_VPC_GW_H+PER_VPC_GW_GAP;
    });
  });

  // Build reverse map: rtId -> all subnets using it (for both per-VPC and shared gw lines)
  const rtToSubs={};
  subnets.forEach(s=>{
    const rt=subRT[s.SubnetId];
    if(rt){(rtToSubs[rt.RouteTableId]=rtToSubs[rt.RouteTableId]||[]).push(s.SubnetId)}
  });

  // --- Lines from subnets to per-VPC gateways (IGW, NAT, VGW) ---
  const perVpcGwLines={};
  rts.forEach(rt=>{
    const vId=rt.VpcId;
    const rtSubnets=rtToSubs[rt.RouteTableId]||[];
    if(rtSubnets.length===0)return;
    
    (rt.Routes||[]).forEach(r=>{
      // Check for IGW, NAT, VGW routes
      let gwId=null,gwType=null;
      if(r.GatewayId?.startsWith('igw-')){gwId=r.GatewayId;gwType='IGW';}
      else if(r.NatGatewayId){gwId=r.NatGatewayId;gwType='NAT';}
      else if(r.GatewayId?.startsWith('vgw-')){gwId=r.GatewayId;gwType='VGW';}
      
      if(!gwId||!perVpcGwPos[gwId])return;
      
      rtSubnets.forEach(subId=>{
        const key=subId+'|'+gwId;
        if(perVpcGwLines[key])return;
        perVpcGwLines[key]=true;
        
        const subPos=subnetPositions[subId];
        if(!subPos||!shapeIds[subId]||!shapeIds[gwId])return;
        
        const gwPos=perVpcGwPos[gwId];
        const gc=gwColors2[gwType]||'#546E7A';
        
        // Get names for metadata
        const subObj=subnets.find(s=>s.SubnetId===subId);
        const subName=subObj?gn(subObj,subId):subId;
        const gwName=gwNames[gwId]||sid(gwId);
        
        // Line from right edge of subnet to left edge of gateway
        // Route: right of subnet -> trunk outside VPC -> gateway
        const trunkX=subPos.vpcX+subPos.vpcW+30;
        
        lines.push({
          id:'pvln_'+(lid++),lineType:'straight',
          stroke:{color:gc,width:1.5},
          endpoint1:{type:'shapeEndpoint',style:'none',shapeId:shapeIds[subId],position:{x:1,y:0.5}},
          endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:shapeIds[gwId],position:{x:0,y:0.5}},
          joints:[
            {x:trunkX,y:subPos.centerY},
            {x:trunkX,y:gwPos.centerY}
          ],
          customData:[
            {key:'From Subnet',value:subName},
            {key:'Subnet ID',value:subId},
            {key:'To Gateway',value:gwName},
            {key:'Gateway ID',value:gwId},
            {key:'Gateway Type',value:gwType},
            {key:'Route',value:r.DestinationCidrBlock||''}
          ]
        });
      });
    });
  });

  // --- shared gateways (TGW, PCX) centered BELOW all VPCs ---
  const maxVpcH=vpcInfos.length>0?Math.max(...vpcInfos.map(v=>v.vpcH)):200;
  const BUS_Y=VPC_TOP+maxVpcH+80; // horizontal routing channel
  const SHARED_ROW_Y=VPC_TOP+maxVpcH+200;
  
  // Use fixed width for shared gateways
  const sharedTotalW=sharedGws.length*(GW_W+60);
  let sharedStartX=Math.max(40,(vpcX-sharedTotalW)/2);
  const sharedGwPos={};
  let sharedCurX=sharedStartX;
  sharedGws.forEach((gw,i)=>{
    const nm=gwNames[gw.id]||sid(gw.id);
    const gwLabel=gw.type+': '+nm;
    const gc=gwColors2[gw.type]||'#546E7A';
    const gf=gwFills[gw.type]||'#F5F0FF';
    const gwShapeId='sgw_'+(lid++);
    shapeIds[gw.gwMapId]=gwShapeId;
    const gwX=sharedCurX;
    const thisGwW=GW_W;
    
    // Find connected VPCs
    const connectedVpcs=new Set();
    rts.forEach(rt=>{
      (rt.Routes||[]).forEach(r=>{
        if((r.TransitGatewayId===gw.id)||(r.VpcPeeringConnectionId===gw.id)){
          connectedVpcs.add(rt.VpcId);
        }
      });
    });
    
    let gwCustomData=[
      {key:'Gateway ID',value:gw.id},
      {key:'Type',value:gw.type==='TGW'?'Transit Gateway':gw.type==='PCX'?'VPC Peering':'Gateway'},
      {key:'Name',value:nm},
      {key:'Connected VPCs',value:String(connectedVpcs.size)}
    ];
    
    // Add peering-specific info
    if(gw.type==='PCX'){
      const pcx=peerings.find(p=>p.VpcPeeringConnectionId===gw.id);
      if(pcx){
        gwCustomData.push({key:'Requester VPC',value:pcx.RequesterVpcInfo?.VpcId||''});
        gwCustomData.push({key:'Accepter VPC',value:pcx.AccepterVpcInfo?.VpcId||''});
        gwCustomData.push({key:'Status',value:pcx.Status?.Code||''});
      }
    }
    
    // Truncate text to fit
    const maxSChars=Math.floor((thisGwW-20)/9);
    const dispSText=gwLabel.length>maxSChars?gwLabel.substring(0,maxSChars-2)+'..':gwLabel;
    
    // Rectangle with text
    shapes.push({
      id:gwShapeId,type:'rectangle',
      boundingBox:{x:gwX,y:SHARED_ROW_Y,w:thisGwW,h:GW_H},
      text:'<p style="font-size:10pt;font-weight:bold;color:'+gc+';text-align:center">'+dispSText+'</p>',
      style:{stroke:{color:gc,width:2},fill:{type:'color',color:gf}},
      customData:gwCustomData
    });
    addIcon(gw.type,gwX+10,SHARED_ROW_Y+8);
    sharedGwPos[gw.gwMapId]={x:gwX,centerX:gwX+thisGwW/2,topY:SHARED_ROW_Y};
    sharedCurX+=thisGwW+60;
  });

  // --- LINES: Subnet -> shared TGW/PCX (per-subnet, routed around VPCs) ---
  // Track which subnet-gateway pairs we've drawn
  const subGwSeen=new Set();
  
  // Count lines per gateway for spreading connection points
  const gwLineCount={};
  rts.forEach(rt=>{
    const rtSubnets=rtToSubs[rt.RouteTableId]||[];
    (rt.Routes||[]).forEach(r=>{
      const tid=r.TransitGatewayId||r.VpcPeeringConnectionId;
      if(!tid)return;
      rtSubnets.forEach(subId=>{
        const ek=subId+'|'+tid;
        if(!subGwSeen.has(ek)){
          subGwSeen.add(ek);
          gwLineCount[tid]=(gwLineCount[tid]||0)+1;
        }
      });
    });
  });
  subGwSeen.clear();
  
  // Track current line index per gateway for spreading
  const gwLineIdx={};
  let globalLineIdx=0;
  
  rts.forEach(rt=>{
    const vId=rt.VpcId;
    if(!vpcPositions[vId])return;

    const rtSubnets=rtToSubs[rt.RouteTableId]||[];
    if(rtSubnets.length===0)return;

    (rt.Routes||[]).forEach(r=>{
      const tid=r.TransitGatewayId||r.VpcPeeringConnectionId;
      if(!tid||!shapeIds[tid]||!sharedGwPos[tid])return;
      const gc=gwColors2[gwSet2L.get(tid)?.type]||'#546E7A';
      const gwPos=sharedGwPos[tid];
      const totalLines=gwLineCount[tid]||1;

      rtSubnets.forEach(subId=>{
        const ek=subId+'|'+tid;
        if(subGwSeen.has(ek))return;
        subGwSeen.add(ek);
        
        const subPos=subnetPositions[subId];
        if(!subPos||!shapeIds[subId])return;
        
        // Get this line's index for this gateway
        if(gwLineIdx[tid]===undefined)gwLineIdx[tid]=0;
        const lineNum=gwLineIdx[tid]++;
        
        // Spread trunk lines across left margin of VPC
        const trunkX=subPos.vpcX-15-(subPos.subIndex%5)*4;
        
        // Spread bus Y levels
        const busYOff=globalLineIdx*2;
        
        // Spread connection points across gateway top (0.1 to 0.9)
        const spreadRatio=totalLines>1?lineNum/(totalLines-1):0.5;
        const gwConnectXRel=0.1+spreadRatio*0.8;
        
        // Get subnet and gateway names for line metadata
        const subObj=subnets.find(s=>s.SubnetId===subId);
        const subName=subObj?gn(subObj,subId):subId;
        const gwName=gwNames[tid]||sid(tid);
        
        lines.push({
          id:'ln_'+(lid++),lineType:'straight',
          stroke:{color:gc,width:1},
          endpoint1:{type:'shapeEndpoint',style:'none',shapeId:shapeIds[subId],position:{x:0,y:0.5}},
          endpoint2:{type:'shapeEndpoint',style:'arrow',shapeId:shapeIds[tid],position:{x:gwConnectXRel,y:0}},
          joints:[
            {x:trunkX,y:subPos.centerY},
            {x:trunkX,y:BUS_Y+busYOff},
            {x:gwPos.x+GW_W*gwConnectXRel,y:BUS_Y+busYOff}
          ],
          customData:[
            {key:'From Subnet',value:subName},
            {key:'Subnet ID',value:subId},
            {key:'To Gateway',value:gwName},
            {key:'Gateway ID',value:tid},
            {key:'Route Table',value:rt.RouteTableId||''}
          ]
        });
        globalLineIdx++;
      });
    });
  });

  // --- peering lines routed ABOVE VPCs ---
  const PEER_Y=VPC_TOP-30; // above all VPCs
  peerings.forEach((pcx,pi)=>{
    if(pcx.Status&&pcx.Status.Code!=='active')return;
    const rv=pcx.RequesterVpcInfo?.VpcId,av=pcx.AccepterVpcInfo?.VpcId;
    if(!shapeIds[rv]||!shapeIds[av])return;
    if(!vpcPositions[rv]||!vpcPositions[av])return;
    const vpcPosR=vpcPositions[rv];
    const vpcPosA=vpcPositions[av];
    
    // Get VPC names
    const vpcR=vpcs.find(v=>v.VpcId===rv);
    const vpcA=vpcs.find(v=>v.VpcId===av);
    const nameR=vpcR?gn(vpcR,rv):rv;
    const nameA=vpcA?gn(vpcA,av):av;
    
    // Get peering name
    const peerName=gn(pcx,pcx.VpcPeeringConnectionId)||pcx.VpcPeeringConnectionId;
    
    // Route via top edge of VPCs
    const exitXR=vpcPosR.x+vpcPosR.w*0.3+(pi%4)*20;
    const exitXA=vpcPosA.x+vpcPosA.w*0.7-(pi%4)*20;
    const peerYOff=pi*6;
    const midX=(exitXR+exitXA)/2;
    
    // Compute label dimensions first
    const maxPeerChars=35;
    const dispPeerName=peerName.length>maxPeerChars?peerName.substring(0,maxPeerChars-2)+'..':peerName;
    const labelW=Math.min(dispPeerName.length*9+32,320);
    const labelH=26;
    const labelX=midX-labelW/2;
    const labelY=PEER_Y-peerYOff-labelH/2;
    const labelPad=8;
    
    // Line segment 1: VPC R to label left edge
    lines.push({
      id:'pcx_L_'+(lid++),lineType:'straight',
      stroke:{color:COL.pcx,width:2,style:'dashed'},
      endpoint1:{type:'shapeEndpoint',style:'none',shapeId:shapeIds[rv],position:{x:0.3+(pi%4)*0.05,y:0}},
      endpoint2:{type:'positionEndpoint',style:'none',position:{x:labelX-labelPad,y:PEER_Y-peerYOff}},
      joints:[{x:exitXR,y:PEER_Y-peerYOff}],
      customData:[
        {key:'Peering ID',value:pcx.VpcPeeringConnectionId||''},
        {key:'Name',value:peerName},
        {key:'Requester VPC',value:nameR+' ('+rv+')'},
        {key:'Accepter VPC',value:nameA+' ('+av+')'},
        {key:'Status',value:pcx.Status?.Code||''}
      ]
    });
    
    // Line segment 2: label right edge to VPC A
    lines.push({
      id:'pcx_R_'+(lid++),lineType:'straight',
      stroke:{color:COL.pcx,width:2,style:'dashed'},
      endpoint1:{type:'positionEndpoint',style:'none',position:{x:labelX+labelW+labelPad,y:PEER_Y-peerYOff}},
      endpoint2:{type:'shapeEndpoint',style:'none',shapeId:shapeIds[av],position:{x:0.7-(pi%4)*0.05,y:0}},
      joints:[{x:exitXA,y:PEER_Y-peerYOff}]
    });
    
    // Label in the gap between line segments
    shapes.push({
      id:'pcxlbl_'+(lid++),type:'rectangle',
      boundingBox:{x:labelX,y:labelY,w:labelW,h:labelH},
      text:'<p style="font-size:10pt;color:'+COL.pcx+';text-align:center;font-weight:bold">'+dispPeerName+'</p>',
      style:{stroke:{color:COL.pcx,width:1.5},fill:{type:'color',color:'#FFFFFF'}}
    });
  });

  // --- Route 53 DNS Zones section ---
  if(zones.length>0){
    const pubZ=zones.filter(z=>!z.Config?.PrivateZone);
    const privZ=zones.filter(z=>z.Config?.PrivateZone);
    const dnsExp=(_detailLevel>=1);
    const dnsCols=dnsExp?1:2;
    const dnsColW=dnsExp?700:460;
    const dnsX=120;
    const dnsY=SHARED_ROW_Y+GW_H+80;
    const lzRecRowH=16,lzRecHdrH=18;

    const lzZoneHeights=[];
    zones.forEach(z=>{
      if(!dnsExp){lzZoneHeights.push(54);return}
      const isPub=!z.Config?.PrivateZone;
      const av=(!isPub&&z.VPCs)?z.VPCs.length:0;
      const zid=z.Id.replace('/hostedzone/','');
      const zR=recsByZone[zid]||[];
      let h=28;if(av)h+=lzRecRowH;
      if(zR.length>0)h+=lzRecHdrH+zR.length*lzRecRowH;
      lzZoneHeights.push(Math.max(54,h+12));
    });
    const lzZoneGap=8;
    let lzTotalZoneH=0;
    if(dnsExp){lzZoneHeights.forEach(h=>{lzTotalZoneH+=h+lzZoneGap})}
    else{lzTotalZoneH=Math.ceil(zones.length/dnsCols)*62}

    const dnsW=dnsCols*dnsColW+60;
    const dnsH=60+lzTotalZoneH+20;

    shapes.push({
      id:'dns_section',type:'rectangle',
      boundingBox:{x:dnsX,y:dnsY,w:dnsW,h:dnsH},
      text:NOTEXT,
      style:{stroke:{color:'#0ea5e9',width:2,style:'dashed'},fill:{type:'color',color:'#F0F9FF'}}
    });
    shapes.push({
      id:'dns_sec_title',type:'rectangle',
      boundingBox:{x:dnsX+10,y:dnsY+8,w:dnsW-20,h:30},
      text:'<p style="font-size:12pt;font-weight:bold;color:#0ea5e9;text-align:left">Route 53 Hosted Zones ('+pubZ.length+' public, '+privZ.length+' private)</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });

    let lzCurY=dnsY+48;
    zones.forEach((z,zi)=>{
      const isPub=!z.Config?.PrivateZone;
      const zid=z.Id.replace('/hostedzone/','');
      const assocVpcs=(!isPub&&z.VPCs)?z.VPCs.map(v=>{
        const vid=v.VPCId||v.VpcId;
        const vpc=vpcs.find(vp=>vp.VpcId===vid);
        return gn(vpc||{},vid);
      }).join(', '):'';
      const zh=lzZoneHeights[zi];
      const zRecs=recsByZone[zid]||[];

      if(dnsExp){
        const zx=dnsX+20;
        const zCol=isPub?'#10b981':'#0ea5e9';
        shapes.push({
          id:'gdns_'+zi,type:'rectangle',
          boundingBox:{x:zx,y:lzCurY,w:dnsColW-20,h:zh},
          text:NOTEXT,
          style:{stroke:{color:zCol,width:1.5},fill:{type:'color',color:isPub?'#F0FDF4':'#F0F9FF'}},
          customData:[
            {key:'Zone ID',value:zid},{key:'Name',value:z.Name},
            {key:'Type',value:isPub?'Public':'Private'},
            {key:'Records',value:String(z.ResourceRecordSetCount)},
            {key:'Associated VPCs',value:assocVpcs||'N/A'}
          ]
        });
        shapes.push({
          id:'gdnslbl_'+zi+'a',type:'rectangle',
          boundingBox:{x:zx+6,y:lzCurY+4,w:dnsColW-32,h:18},
          text:'<p style="font-size:10pt;font-weight:bold;color:'+zCol+';text-align:left">'+(isPub?'[Public]':'[Private]')+' '+z.Name+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        let ly=lzCurY+22;
        shapes.push({
          id:'gdnslbl_'+zi+'b',type:'rectangle',
          boundingBox:{x:zx+6,y:ly,w:dnsColW-32,h:lzRecRowH},
          text:'<p style="font-size:8pt;color:#64748B;text-align:left">'+z.ResourceRecordSetCount+' records | Zone ID: '+zid+' | Type: '+(isPub?'Public':'Private')+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        ly+=lzRecRowH;
        if(assocVpcs){
          shapes.push({
            id:'gdnslbl_'+zi+'d',type:'rectangle',
            boundingBox:{x:zx+6,y:ly,w:dnsColW-32,h:lzRecRowH},
            text:'<p style="font-size:8pt;color:#64748B;text-align:left">VPCs: '+assocVpcs+'</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
          ly+=lzRecRowH;
        }
        if(zRecs.length>0){
          shapes.push({
            id:'gdnshdr_'+zi,type:'rectangle',
            boundingBox:{x:zx+6,y:ly,w:dnsColW-32,h:lzRecHdrH},
            text:'<p style="font-size:7pt;font-weight:bold;color:#475569;text-align:left">NAME                                                  TYPE      VALUE</p>',
            style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
          });
          ly+=lzRecHdrH;
          zRecs.forEach((rec,ri)=>{
            const rName=rec.Name||'';
            const rType=rec.Type||'';
            const rVal=rec.AliasTarget?'ALIAS  '+rec.AliasTarget.DNSName:
              (rec.ResourceRecords||[]).map(rr=>rr.Value).join(', ');
            const ttl=rec.TTL!=null?'  TTL:'+rec.TTL:'';
            shapes.push({
              id:'gdnsrec_'+zi+'_'+ri,type:'rectangle',
              boundingBox:{x:zx+6,y:ly,w:dnsColW-32,h:lzRecRowH},
              text:'<p style="font-size:7pt;color:#334155;text-align:left;font-family:monospace">'+rName+' &nbsp; '+rType+' &nbsp; '+rVal+ttl+'</p>',
              style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
            });
            ly+=lzRecRowH;
          });
        }
        lzCurY+=zh+lzZoneGap;
      }else{
        const col=zi%dnsCols;
        const row=Math.floor(zi/dnsCols);
        const zx=dnsX+20+col*dnsColW;
        const zy=dnsY+48+row*62;
        shapes.push({
          id:'gdns_'+zi,type:'rectangle',
          boundingBox:{x:zx,y:zy,w:dnsColW-20,h:54},
          text:NOTEXT,
          style:{stroke:{color:isPub?'#10b981':'#0ea5e9',width:1.5},fill:{type:'color',color:isPub?'#F0FDF4':'#F0F9FF'}},
          customData:[
            {key:'Zone ID',value:zid},{key:'Name',value:z.Name},
            {key:'Type',value:isPub?'Public':'Private'},
            {key:'Records',value:String(z.ResourceRecordSetCount)},
            {key:'Associated VPCs',value:assocVpcs||'N/A'}
          ]
        });
        shapes.push({
          id:'gdnslbl_'+zi+'a',type:'rectangle',
          boundingBox:{x:zx+6,y:zy+4,w:dnsColW-32,h:22},
          text:'<p style="font-size:9pt;font-weight:bold;color:'+(isPub?'#10b981':'#0ea5e9')+';text-align:left">'+(isPub?'[Public]':'[Private]')+' '+z.Name+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
        shapes.push({
          id:'gdnslbl_'+zi+'b',type:'rectangle',
          boundingBox:{x:zx+6,y:zy+28,w:dnsColW-32,h:20},
          text:'<p style="font-size:8pt;color:#64748B;text-align:left">'+z.ResourceRecordSetCount+' records | '+zid+(assocVpcs?' | VPCs: '+assocVpcs:'')+'</p>',
          style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
        });
      }
    });
  }

  // --- S3 Buckets section ---
  if(s3bk.length>0){
    const s3Cols=3;
    const s3ColW=360;
    const s3W=s3Cols*s3ColW+60;
    const s3RowH=36;
    const s3Rows=Math.ceil(s3bk.length/s3Cols);
    const s3H=50+s3Rows*s3RowH+20;
    const s3X=120;
    const dnsExists=zones.length>0;
    const _lzDnsH=(function(){
      if(!dnsExists)return 0;
      const dExp=(_detailLevel>=1);const c=dExp?1:2;
      if(dExp){let th=0;zones.forEach(z=>{const ip=!z.Config?.PrivateZone;const av=(!ip&&z.VPCs)?z.VPCs.length:0;const zid=z.Id.replace('/hostedzone/','');const zR=recsByZone[zid]||[];let h=28;if(av)h+=16;if(zR.length>0)h+=18+zR.length*16;th+=Math.max(54,h+12)+8});return 60+th+20}
      return 60+Math.ceil(zones.length/c)*62+20;
    })();
    const s3Y=dnsExists?(SHARED_ROW_Y+GW_H+80+_lzDnsH+40):(SHARED_ROW_Y+GW_H+80);

    shapes.push({
      id:'s3_section',type:'rectangle',
      boundingBox:{x:s3X,y:s3Y,w:s3W,h:s3H},
      text:NOTEXT,
      style:{stroke:{color:'#EA580C',width:2,style:'dashed'},fill:{type:'color',color:'#FFF7ED'}}
    });
    shapes.push({
      id:'s3_sec_title',type:'rectangle',
      boundingBox:{x:s3X+10,y:s3Y+8,w:s3W-20,h:30},
      text:'<p style="font-size:12pt;font-weight:bold;color:#EA580C;text-align:left">S3 Buckets ('+s3bk.length+')</p>',
      style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
    });
    
    s3bk.forEach((bk,bi)=>{
      const col=bi%s3Cols;
      const row=Math.floor(bi/s3Cols);
      const bx=s3X+20+col*s3ColW;
      const by=s3Y+48+row*s3RowH;
      
      shapes.push({
        id:'gs3_'+bi,type:'rectangle',
        boundingBox:{x:bx,y:by,w:s3ColW-20,h:28},
        text:NOTEXT,
        style:{stroke:{color:'#EA580C',width:1},fill:{type:'color',color:'#FFFFFF'}},
        customData:[
          {key:'Bucket Name',value:bk.Name},
          {key:'Created',value:(bk.CreationDate||'N/A').split('T')[0]}
        ]
      });
      shapes.push({
        id:'gs3lbl_'+bi,type:'rectangle',
        boundingBox:{x:bx+4,y:by+2,w:s3ColW-28,h:24},
        text:'<p style="font-size:8pt;color:#232F3E;text-align:left">'+bk.Name+'</p>',
        style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF00'}}
      });
    });
  }

  // --- LEGEND ---
  const legendX=vpcX+40;
  const legendY=VPC_TOP+20;
  const LEGEND_W=220,LEGEND_H=100;
  shapes.push({
    id:'legend_box',type:'rectangle',
    boundingBox:{x:legendX,y:legendY,w:LEGEND_W,h:LEGEND_H},
    text:NOTEXT,
    style:{stroke:{color:'#546E7A',width:1},fill:{type:'color',color:'#FFFFFF'}}
  });
  shapes.push({
    id:'legend_title',type:'rectangle',
    boundingBox:{x:legendX+8,y:legendY+8,w:LEGEND_W-16,h:20},
    text:'<p style="font-size:11pt;font-weight:bold;color:#232F3E;text-align:left">Legend</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });
  // TGW line sample (solid)
  lines.push({
    id:'legend_tgw_line',lineType:'straight',
    stroke:{color:COL.tgw,width:2},
    endpoint1:{type:'positionEndpoint',style:'none',position:{x:legendX+12,y:legendY+45}},
    endpoint2:{type:'positionEndpoint',style:'arrow',position:{x:legendX+55,y:legendY+45}}
  });
  shapes.push({
    id:'legend_tgw_label',type:'rectangle',
    boundingBox:{x:legendX+62,y:legendY+36,w:150,h:20},
    text:'<p style="font-size:9pt;color:#232F3E;text-align:left">Transit Gateway</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });
  // PCX line sample (dashed)
  lines.push({
    id:'legend_pcx_line',lineType:'straight',
    stroke:{color:COL.pcx,width:2,style:'dashed'},
    endpoint1:{type:'positionEndpoint',style:'none',position:{x:legendX+12,y:legendY+75}},
    endpoint2:{type:'positionEndpoint',style:'none',position:{x:legendX+55,y:legendY+75}}
  });
  shapes.push({
    id:'legend_pcx_label',type:'rectangle',
    boundingBox:{x:legendX+62,y:legendY+66,w:150,h:20},
    text:'<p style="font-size:9pt;color:#232F3E;text-align:left">VPC Peering</p>',
    style:{stroke:{color:'#FFFFFF',width:0},fill:{type:'color',color:'#FFFFFF'}}
  });

  const doc={version:1,pages:[{id:'page1',title:'AWS-Network-Map',shapes,lines}]};
  return{doc,iconSet};
}

// generate .lucid ZIP blob
async function buildLucidZip(){
  const result=buildLucidExport();
  if(!result)return null;
  const{doc,iconSet}=result;
  if(typeof JSZip==='undefined'){alert('JSZip not loaded');return null}
  const zip=new JSZip();
  zip.file('document.json',JSON.stringify(doc));
  const imgFolder=zip.folder('images');
  for(const type of iconSet){
    const key=ICON_MAP[type]||type.toLowerCase();
    const dataUri=AWS_ICONS[key];
    if(!dataUri)continue;
    const b64=dataUri.split(',')[1];
    const bin=atob(b64);
    const arr=new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i);
    imgFolder.file(key+'.png',arr);
  }
  return zip.generateAsync({type:'blob'});
}

// Download .lucid file
document.getElementById('expLucidDl').addEventListener('click',async()=>{
  try{
    const blob=await buildLucidZip();
    const mode=document.getElementById('layoutMode').value;
    const fname=mode==='landingzone'?'AWS-Landing-Zone.lucid':'AWS-Network-Map.lucid';
    if(blob)downloadBlob(blob,fname);
    else alert('Export returned empty. Load data first.');
  }catch(e){alert('Lucid export error: '+e.message);console.error(e)}
});


// Layout mode selector
if(_prefs.layoutMode){document.getElementById('layoutMode').value=_prefs.layoutMode;const hi=document.getElementById('hubVpcName');if(hi)hi.style.display=_prefs.layoutMode==='landingzone'?'block':'none';document.getElementById('detailBtns').style.display=_prefs.layoutMode==='executive'?'none':'flex'}
document.getElementById('layoutMode').addEventListener('change',function(){
  const hubInput=document.getElementById('hubVpcName');
  hubInput.style.display=this.value==='landingzone'?'block':'none';
  document.getElementById('detailBtns').style.display=this.value==='executive'?'none':'flex';
  savePrefs({layoutMode:this.value});
  const svg=d3.select('#mapSvg');
  if(svg.node()&&svg.style('display')!=='none'){
    renderMap();
  }
});
document.getElementById('hubVpcName').addEventListener('change',function(){
  const svg=d3.select('#mapSvg');
  if(svg.node()&&svg.style('display')!=='none'){
    renderMap();
  }
});

// Map detail level toggle
function updateDetailBtns(){
  document.getElementById('btnExpand').classList.toggle('active',_detailLevel===2);
  document.getElementById('btnCollapse').classList.toggle('active',_detailLevel===0);
}
document.getElementById('btnExpand').addEventListener('click',function(){
  _detailLevel=(_detailLevel===2)?1:2;
  _showNested=(_detailLevel===2);
  updateDetailBtns();
  const svg=d3.select('#mapSvg');
  if(svg.node()&&svg.style('display')!=='none') renderMap();
});
document.getElementById('btnCollapse').addEventListener('click',function(){
  _detailLevel=(_detailLevel===0)?1:0;
  _showNested=false;
  updateDetailBtns();
  const svg=d3.select('#mapSvg');
  if(svg.node()&&svg.style('display')!=='none') renderMap();
});

// Initialize button state on load
updateDetailBtns();

// Keyboard shortcuts
document.addEventListener('keydown',function(e){
  const tag=e.target.tagName;
  if(tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
  if(e.key==='Escape'){
    document.getElementById('detailPanel').classList.remove('open');
    if(typeof _hlLocked!=='undefined'){_hlLocked=false;_hlKey=null;_hlType=null}
    const lockInd=document.getElementById('hlLockInd');
    if(lockInd) lockInd.style.display='none';
    if(_designMode)exitDesignMode();
    return;
  }
  if(e.ctrlKey||e.metaKey){
    if(e.key==='='||e.key==='+'){e.preventDefault();gTxtScale=Math.min(2.5,gTxtScale+0.15);applyGlobalTxtScale();savePrefs({gTxtScale});return}
    if(e.key==='-'){e.preventDefault();gTxtScale=Math.max(0.5,gTxtScale-0.15);applyGlobalTxtScale();savePrefs({gTxtScale});return}
    if(e.key==='0'){e.preventDefault();gTxtScale=1.0;applyGlobalTxtScale();savePrefs({gTxtScale});return}
  }
  if(e.key==='+'||e.key==='='){d3.select('#zoomIn').dispatch('click');return}
  if(e.key==='-'){d3.select('#zoomOut').dispatch('click');return}
  if(e.key==='f'){d3.select('#zoomFit').dispatch('click');return}
  if(e.key==='d'){if(_designMode)exitDesignMode();else enterDesignMode();return}
  if(e.key==='z'&&_designMode){undoLastChange();return}
  if(e.key==='e'&&_designMode&&_designChanges.length){exportDesignPlan('design-plan');return}
});

</script>
</body>
</html>
